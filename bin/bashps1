#!/bin/bash
##################################################################################
#
#       Filename:  bashps1
#
#    Description:  BASH PS1 with GIT support
#
#                  Colored command prompt adapted to GIT repository. VERY 
#                  colorfull, not for the faint hearted
#
#  Configuration:  place this file somewhere in your PATH and source it in your
#                  .bashrc
#
#                     source /path/to/bashps1
#
#   Dependencies:  Depends on GIT, might work on windows with Cygwin
#
#   GVIM Version:  1.7+ (?)
#
#         Author:  Pierre Lhoste
#        Twitter:  http://twitter.com/peterhost
#
#        Version:  0.1
#        Created:  01.05.2011
#        License:  WTFPL V2
#
# DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE Version 2, December 2004 
#
# Copyright (C) 2004 Sam Hocevar <sam@hocevar.net> 
#
# Everyone is permitted to copy and distribute verbatim or modified
# copies of this license document, and changing it is allowed as long as
# the name is changed. 
#
#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE TERMS AND
#            CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION 
#
#  0. You just DO WHAT THE FUCK YOU WANT TO. 
#
#------------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# COLOR VARS : declare those ANSI color codes in variables ONCE and for ALL
#              (mostly used in 'echo -ne' statements thoughout this .bashrc)
#              this somewhat pollutes the GLOBAL SCOPE but the variable names
#              are (thought to be) unique enough so that won't cause problems
#

function __define_echo_ne_colors() {
  # regular colors
  export __K_="\033[0;30m"    # black
  export __R_="\033[0;31m"    # red
  export __G_="\033[0;32m"    # green
  export __Y_="\033[0;33m"    # yellow
  export __B_="\033[0;34m"    # blue
  export __M_="\033[0;35m"    # magenta
  export __C_="\033[0;36m"    # cyan
  export __W_="\033[0;37m"    # white
  # empahsized (bolded) colors
  export __EMK_="\033[1;30m"
  export __EMR_="\033[1;31m"
  export __EMG_="\033[1;32m"
  export __EMY_="\033[1;33m"
  export __EMB_="\033[1;34m"
  export __EMM_="\033[1;35m"
  export __EMC_="\033[1;36m"
  export __EMW_="\033[1;37m"
  # background colors
  export __BGK_="\033[40m"
  export __BGR_="\033[41m"
  export __BGG_="\033[42m"
  export __BGY_="\033[43m"
  export __BGB_="\033[44m"
  export __BGM_="\033[45m"
  export __BGC_="\033[46m"
  export __BGW_="\033[47m"
  # styles
  export __NN_="\033[0m"  # unsets color to term's fg color
  export __EM_="\033[1m"  #bold
  export __DM_="\033[2m"  #dim
  export __UN_="\033[4m"  #underline
  export __BL_="\033[5m"  #blink
  export __RV_="\033[7m"  #reverse
  export __EMQ_="\033[21m" #END bold
  export __DMQ_="\033[22m" #END dim
  export __UNQ_="\033[24m" #END underline
  export __BLQ_="\033[25m" #END blink
  export __RVQ_="\033[27m" #END reverse
  # default user colors
  export __UC_=$_G_                         # user's color
  export __EMUC_=$_EMG_                     # user's bold color
  export __ERRUC_=$_R_                      # user's ERROR color
  export __ERREMUC_=$_EMR_                  # user's bold ERROR color
  # root colors
  [ $UID -eq "0" ] && __UC_=$_R_           # root's color
  [ $UID -eq "0" ] && __EMUC_=$_EMR_       # root's bold color
  [ $UID -eq "0" ] && __ERRUC_=$_K_        # root's ERROR color
  [ $UID -eq "0" ] && __ERREMUC_=$_EMK_    # root's bold ERROR color



}
__define_echo_ne_colors



# -----------------------------------------------------------------------------
# BASH PROMPT


__last_exit=0

function bash_prompt_command() {
  #First, store last_exit
  __last_exit="$?" # keep here.. so we get the last command
  # How many characters of the $PWD should be kept
  local pwdmaxlen=25
  # Indicate that there has been dir truncation
  local trunc_symbol=".."
  local dir=${PWD##*/}
  pwdmaxlen=$(( ( pwdmaxlen < ${#dir} ) ? ${#dir} : pwdmaxlen ))
  NEW_PWD=${PWD/#$HOME/\~}
  local pwdoffset=$(( ${#NEW_PWD} - pwdmaxlen ))
  if [ ${pwdoffset} -gt "0" ]
  then
      NEW_PWD=${NEW_PWD:$pwdoffset:$pwdmaxlen}
      NEW_PWD=${trunc_symbol}/${NEW_PWD#*/}
  fi

  # CONSISTENT HISTORY across shells
  # only in case .bash_history exists and is non-empty
  if [ -f ~/.bash_history ] && [[ "$(cat ~/.bash_history 2>&1 | wc -l)" -gt 0 ]]; then
    #history -a #store each command in the history as soon as it's executed
    history -a;history -c; history -r; #store; clear; reload ---> makes history consistent across shells
  fi

  # UPDATE TERMINAL window TITLE
    #echo -n -e "\033]0;${USER}@$(hostname): ${NEW_PWD}\007"
    echo -n -e "\033]0;$(hostname): ${NEW_PWD}\007"
}






function __ps1_marker() {
  # setup marker that acts off of last exit code
  local marker
  if [ 0 -eq $__last_exit ]; then   #! __last_exit is a global variable
    marker="${__UC_}"
  else
    marker="${__ERRUC_}"
  fi
  marker="${marker}\$${__NN_}"
  echo -e $marker
}



function __gitps1_repo_name()
{
  local notartify=$1   #TRUE for no color
  local color
  local nocolor
  #? are we inside a GIT repo
  if git rev-parse --git-dir >/dev/null 2>&1
  then
    # Print the REPO's name
    color="\n${__DM_}${_K_}"
    nocolor=$(echo `cd $(git rev-parse --git-dir); cd ../;pwd` | sed 's,.*/,,' | tr -d '\n')
    color=$color$nocolor
    color=$color"/${__NN_}"
  fi
  [ $notartify ] &&  echo -ne $nocolor || echo -ne $color
}





function __gitps1_stash()
{
  local notartify=$1   #TRUE for no color
  local color
  local nocolor
  #? are we inside a GIT repo
  if git rev-parse --git-dir >/dev/null 2>&1
  then
    if [ $(git stash list | wc -l) -gt 0 ]
    then

      # One star per stash
      color="${_NN_}${_EMY_}"
      nocolor="  "
      for (( i=0; i< $(git stash list | wc -l); i++ ))
      do
        nocolor=$nocolor"☆ "
      done
      nocolor=$nocolor"   "
      color="$color$nocolor""${_NN_}"

    fi
  fi
  [ $notartify ] &&  echo -ne $nocolor || echo -e $color
}





#count the nb of commits between two branches of two repositorie
#   ex: __gitps1_diff_count HEAD origin/master
#   ex: __gitps1_diff_count upstream/dev HEAD
function __gitps1_diff_count() {
    echo "$(git rev-list $1..$2 2>/dev/null | awk 'END {print NR}')"
}



# COLORED mode
#
# unstaged modifications :              RED
# uncommited material :                 MAGENTA
# unpushed commits to tracked remote :  YELLOW
# all is commited and pushed :          GREEN
#
# untracked files :                     UNDERLINED
#
# NON COLORED mode
# optionnal return value $nocolor_infos
#
#   nocolor_info="(S|C|P|O)(U)?(M)?"
#       S:unstaged, C:uncommited, P:unpushed, O:allisOK,
#       U:untracked, M:unmerged
#
function __gitps1_branch()
{

  local notartify=$1   #TRUE for no color
  local givemeinfos=$2 #TRUE prepends $nocolor_info"|" to the result
  local color
  local nocolor
  local nocolor_infos # store color infos in an easilly parseable string
  #? are we inside a GIT repo
  if git rev-parse --git-dir >/dev/null 2>&1
  then
    local gitdir_=`git rev-parse --git-dir`

    local commited=false
    local remotelogentries
    local isunstaged
    local isuntracked
    local branchname=$(git branch 2>/dev/null| sed -n '/^\*/s/^\* //p')
    color=${__NN_}
    # NON-EMPTY GIT REPO
    # VERIFY that .git/refs/heads/ directory is not empty
    if [ $(ls $gitdir_/refs/heads/ | wc -l) -gt 0 ]
    then

      #? ALL modified files are STAGED
      if git diff --quiet >/dev/null 2>&1
      then


        #? all STAGED changes commited
        #  YES : green
        if [ !  $(git diff  --cached | wc -l) -gt 0  ]
        then
          color=$color$__G_ #GREEN
          nocolor_infos="O"


          #? is there a remote for this repo ?
          if [ $(git remote show | wc -l) -gt 0 ]
          then
            # restrict test to the remote called 'origin'
            if git remote show | grep origin >/dev/null
            then

              #? all comits in current branch have been pushed to remote with in same branch
              #  NO : yellow
              remotelogentries=$(git log origin/$branchname.. | wc -l )
              if [ $remotelogentries  -gt 0 ]
              then
                color=$color$__EMY_ #YELLOW BOLD
                nocolor_infos="P"
              fi
            fi
          fi
        #  NO: MAGENTA
        else
          color=$color$__M_ #MAGENTA
          nocolor_infos="C"
        fi

      #  NO : RED
      else
        color=$color$__EMR_} #BOLD RED
        nocolor_infos="S"
        commited=false
      fi


      #? UNTRACKED FILES -> underlined
      if [ -n "$(git ls-files --others --exclude-standard)" ]; then
        color=$color$__UN_
        nocolor_infos=$nocolor_infos"U"
      fi

      color=$color$branchname$__NN_
      nocolor=$branchname

      # ---------- UNMERGED FILES -------------
      if [ $(git ls-files -u | wc -l ) -gt 0 ]
      then
        color=$__BL_$__EMR_"   ✖  "$__NN_$color #BOLD RED BLINKING CROSS
        nocolor_infos=$nocolor_infos"M"
      fi


    fi

  else
    return 0
  fi

  [ $notartify ] &&  {
      [ $givemeinfos ] && echo -ne $nocolor_infos"|"$nocolor || echo -ne $nocolor 
  } || echo -e $color
}







function __gitps1_remote
{

  local notartify=$1   #TRUE for no color
  local color
  local nocolor
  #? are we inside a GIT repo
  if git rev-parse --git-dir >/dev/null 2>&1
  then
    local gitdir_=`git rev-parse --git-dir`
    local branchname=$(git branch 2>/dev/null| sed -n '/^\*/s/^\* //p')
    color="  "$__NN_

    # NON-EMPTY GIT REPO
    # VERIFY that .git/refs/heads/ directory is not empty
    if [ $(ls $gitdir_/refs/heads/ | wc -l) -gt 0 ]
    then

      # ------- REMOTES INFO ( + BRANCH TRACKED ) --------
      local marker
      local marker_color
      local before_traked
      local after_tracked

      # loop through remotes
      for remotename in $(git remote show); do

        # special markers for origin and upstream
        # nb: a tracked remote is preceded by a little ➝ symbol
        case $remotename in
            origin)   marker="O"; marker_color="${__G_}"   ;;  #green
          upstream)   marker="U"; marker_color="${__M_}"   ;;  #magenta
                  *)   marker="⇧"; marker_color="${__Y_}"   ;;  #yellow
        esac

        # CURRENT BRANCH is tracked to CURRENT REMOTE ?
        if [[ $(git config --get branch.$branchname.remote) =~ $remotename ]]
        then
          [ $notartify ]  &&  { before_traked="➝ "; after_tracked=""; } ||
                              { before_traked="➝${__EM_} "; after_tracked="${_EMQ_}"; }
        else
          before_traked=""; after_tracked=""
        fi


        # nb of commits AHEAD/BEHIND
        local ahead_count="$(__gitps1_diff_count $remotename/$branchname HEAD)"
        local behind_count="$(__gitps1_diff_count HEAD $remotename/$branchname)"
        local diffcount=""
        local diffcountnocol=""
        if [ 0 -lt "$ahead_count" ]; then
            diffcount="${__G_}${ahead_count}"
            diffcountnocol="+${ahead_count}"
        fi

        if [ 0 -lt "$behind_count" ]; then
            [ -n "$diffcount" ] && { 
                    diffcount="${diffcount}${marker_color}/"
                    diffcountnocol="${diffcountnocol}/"
                  }
            diffcount="${diffcount}${__R_}${behind_count}"
            diffcountnocol="${diffcountnocol}-${behind_count}"
        fi

        [ -n "$diffcount" ] && diffcount=" ${marker_color}($diffcount${marker_color}) "
        [ -n "$diffcountnocol" ] && diffcountnocol=" ($diffcountnocol) "
        #echo "$diffcount"


        color=$color"${marker_color}${before_traked}${marker}${after_tracked}${diffcount}${__NN_}"
        nocolor=$nocolor"${before_traked}${marker}${after_tracked}${diffcountnocol}"

      done
    fi
  else
    return 0
  fi
  [ $notartify ] &&  echo -ne $nocolor || echo -e $color
}





## return a string containing all the infos about the current git repo in
## a format parseable by our vimscript
#function __gitps1_vim() {
  #__fromvim=1
  #local vimstatusline = $(__gitps1_repo_name)"|"$(__gitps1_branch)"|"$(__gitps1_remote)"|"$(__gitps1_stash)
  #unset __fromvim
#}


PS1="\$(__gitps1_repo_name)\$(__gitps1_branch)  \$(__gitps1_remote) \$(__gitps1_stash)${__NN_}\n[${__UC_}\u${_EMK_}@${_EMUC_}\h ${_C_}\${NEW_PWD}${_EMK_}]\$(__ps1_marker) ${_NN_}"


PROMPT_COMMAND=bash_prompt_command
export -f __gitps1_diff_count
export -f __gitps1_repo_name
export -f __gitps1_branch
export -f __gitps1_remote
export -f __gitps1_stash



#!/bin/bash
##################################################################################
#
#       Filename:  bashps1
#
#    Description:  BASH PS1 with GIT support
#
#                  Colored command prompt adapted to GIT repository. VERY
#                  colorfull, not for the faint hearted
#
#  Configuration:  place this file somewhere in your PATH and source it in your
#                  .bashrc
#
#                     source /path/to/bashps1
#
#   Dependencies:  Depends on GIT, might work on windows with Cygwin
#
#   GVIM Version:  1.7+ (?)
#
#         Author:  Pierre Lhoste
#        Twitter:  http://twitter.com/peterhost
#
#        Version:  0.1
#        Created:  01.05.2011
#        License:  WTFPL V2
#
# DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE Version 2, December 2004
#
# Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>
#
# Everyone is permitted to copy and distribute verbatim or modified
# copies of this license document, and changing it is allowed as long as
# the name is changed.
#
#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE TERMS AND
#            CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
#
#  0. You just DO WHAT THE FUCK YOU WANT TO.
#
#------------------------------------------------------------------------------
#

# USAGE : Just call the tartify() function from the command line
#
#         PROMPT integration : call tartify() inside your $PS1. Examples:
#
#           PS1="\$(tartify) [\u@\h]\$ "
#           PS1="\$(tartify)\n[\u@\h]\$ "
#           ...
#
#         You can also pass arguments to tartify() to make it display only
#         certain informations
#
#           tartify -h
#
#

#PS1="${__PS1NN_}${__PS1EMK_}[${__PS1UC_}\u${__PS1EMK_}@${__PS1EMUC_}\h ${__PS1C_}\${NEW_PWD}${__PS1EMK_}] \$"
#PROMPT_COMMAND=tartify
#
#
#
#------------------------------------------------------------------------------
#
# ISSUE :
#
#   * no support for SVN upstream (as I don't use SVN), feel free to augment
#     this script
#
#   * Line Wrapping Calculation
#
#     Two things that I know of can confuse line wrapping (when browsing
#     command history with long lines, for ex) :
#
#       1 - non-printable characters in the PS1 variable have to be "escaped"
#       by enclosing them between a pair of escaped brackets :
#
#           \[\033[0;30m\]   instead of  \033[0;30m
#
#       2 - function calls inside the PS1 variable that issue non-printable
#       characters
#
#           "\$(myFunc)"
#
#       need to be issued on a line prior to the last line of the PS1 variable,
#       otherwise they will confuse wrapping too
#
#       (SEE:http://hintsforums.macworld.com/archive/index.php/t-17068.html)
#
#
#------------------------------------------------------------------------------
#
# NOTA :
#          Special Character Codes
#          \a – an ASCII bell character (07)
#          \d – the date in “Weekday Month Date” format (e.g., “Tue May 26″)
#          \D{format} – the format is passed to strftime(3) and the result is inserted into the prompt string; an empty format results in a locale-specific time representation. The braces are required
#          \e – an ASCII escape character (033)  (hence : \e and \033 are equivalent)
#          \h – the hostname up to the first `.’
#          \H – the hostname
#          \j – the number of jobs currently managed by the shell
#          \l – the basename of the shell’s terminal device name
#          \n – newline
#          \r – carriage return
#          \s – the name of the shell, the basename of $0 (the portion following the final slash)
#          \t – the current time in 24-hour HH:MM:SS format
#          \T – the current time in 12-hour HH:MM:SS format
#          \@ – the current time in 12-hour am/pm format
#          \A – the current time in 24-hour HH:MM format
#          \u – the username of the current user
#          \v – the version of bash (e.g., 2.00)
#          \V – the release of bash, version + patchelvel (e.g., 2.00.0)
#          \w – the current working directory
#          \W – the basename of the current working directory
#          \! – the history number of this command
#          \# – the command number of this command
#          \$ – if the effective UID is 0, a #, otherwise a $
#          \nnn – the character corresponding to the octal number nnn
#          \\ – a backslash
#          \[ - begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt
#          \] – end a sequence of non-printing characters
#
#          (http://www.wiredrevolution.com/bash-programming/customize-the-bash-ps1-command-prompt)



#------------------------------------------------------------------------------
#
#             SHELL DETECTION
#
#------------------------------------------------------------------------------
# SHELL detection
__thisShell=`ps $$ | grep $$ | awk '{ print $5 }'`

# Darwin detection
if uname -s | grep "Darwin" >/dev/null 2>&1
then
  __OSflavor="Darwin" # macos
fi

# BAIL if using SH on OSX, (scrambles "echo -ne" commands)
[[ "$__OSflavor" =~ Darwin  &&  "$__thisShell" == sh ]] && exit 1

#------------------------------------------------------------------------------
#
#             MISC GLOBAL VARIABLES
#
#------------------------------------------------------------------------------
# COLOR VARS : declare those ANSI color codes in variables ONCE and for ALL.
#              This somewhat pollutes the GLOBAL SCOPE but the variable names
#              are (thought to be) unique enough so that won't cause problems
#
# Define Colors (to be used in standard echo & printf commands)
#------------------------------------------------------------------------------
function __define_echo_ne_colors() {
  # regular colors
  export __K_="\033[0;30m"    # black
  export __R_="\033[0;31m"    # red
  export __G_="\033[0;32m"    # green
  export __Y_="\033[0;33m"    # yellow
  export __B_="\033[0;34m"    # blue
  export __M_="\033[0;35m"    # magenta
  export __C_="\033[0;36m"    # cyan
  export __W_="\033[0;37m"    # white
  # empahsized (bolded) colors
  export __EMK_="\033[1;30m"
  export __EMR_="\033[1;31m"
  export __EMG_="\033[1;32m"
  export __EMY_="\033[1;33m"
  export __EMB_="\033[1;34m"
  export __EMM_="\033[1;35m"
  export __EMC_="\033[1;36m"
  export __EMW_="\033[1;37m"
  # background colors
  export __BGK_="\033[40m"
  export __BGR_="\033[41m"
  export __BGG_="\033[42m"
  export __BGY_="\033[43m"
  export __BGB_="\033[44m"
  export __BGM_="\033[45m"
  export __BGC_="\033[46m"
  export __BGW_="\033[47m"
  # styles
  export __NN_="\033[0m"  # unsets color to term's fg color
  export __EM_="\033[1m"  #bold
  export __DM_="\033[2m"  #dim
  export __UN_="\033[4m"  #underline
  export __BL_="\033[5m"  #blink
  export __RV_="\033[7m"  #reverse
  export __EMQ_="\033[21m" #END bold
  export __DMQ_="\033[22m" #END dim
  export __UNQ_="\033[24m" #END underline
  export __BLQ_="\033[25m" #END blink
  export __RVQ_="\033[27m" #END reverse
  # default user colors
  export __UC_=$__G_                         # user's color
  export __EMUC_=$__EMG_                     # user's bold color
  export __ERRUC_=$__R_                      # user's ERROR color
  export __ERREMUC_=$__EMR_                  # user's bold ERROR color
  # root colors
  [ $UID -eq "0" ] && __UC_=$__R_           # root's color
  [ $UID -eq "0" ] && __EMUC_=$__EMR_       # root's bold color
  [ $UID -eq "0" ] && __ERRUC_=$__K_        # root's ERROR color
  [ $UID -eq "0" ] && __ERREMUC_=$__EMK_    # root's bold ERROR color
}
__define_echo_ne_colors
#
#
# Define Colors (to be used in the PS1 variable)
function __define_PS1_colors() {
  # regular colors
  export __PS1K_="\[\e[0;30m\]"    # black
  export __PS1R_="\[\e[0;31m\]"    # red
  export __PS1G_="\[\e[0;32m\]"    # green
  export __PS1Y_="\[\e[0;33m\]"    # yellow
  export __PS1B_="\[\e[0;34m\]"    # blue
  export __PS1M_="\[\e[0;35m\]"    # magenta
  export __PS1C_="\[\e[0;36m\]"    # cyan
  export __PS1W_="\[\e[0;37m\]"    # white
  # empahsized (bolded) colors
  export __PS1EMK_="\[\e[1;30m\]"
  export __PS1EMR_="\[\e[1;31m\]"
  export __PS1EMG_="\[\e[1;32m\]"
  export __PS1EMY_="\[\e[1;33m\]"
  export __PS1EMB_="\[\e[1;34m\]"
  export __PS1EMM_="\[\e[1;35m\]"
  export __PS1EMC_="\[\e[1;36m\]"
  export __PS1EMW_="\[\e[1;37m\]"
  # background colors
  export __PS1BGK_="\[\e[40m\]"
  export __PS1BGR_="\[\e[41m\]"
  export __PS1BGG_="\[\e[42m\]"
  export __PS1BGY_="\[\e[43m\]"
  export __PS1BGB_="\[\e[44m\]"
  export __PS1BGM_="\[\e[45m\]"
  export __PS1BGC_="\[\e[46m\]"
  export __PS1BGW_="\[\e[47m\]"
  # styles
  export __PS1NN_="\[\e[0m\]"  # unsets color to term's fg color
  export __PS1EM_="\[\e[1m\]"  #bold
  export __PS1DM_="\[\e[2m\]"  #dim
  export __PS1UN_="\[\e[4m\]"  #underline
  export __PS1BL_="\[\e[5m\]"  #blink
  export __PS1RV_="\[\e[7m\]"  #reverse
  export __PS1EMQ_="\[\e[21m\]" #END bold
  export __PS1DMQ_="\[\e[22m\]" #END dim
  export __PS1UNQ_="\[\e[24m\]" #END underline
  export __PS1BLQ_="\[\e[25m\]" #END blink
  export __PS1RVQ_="\[\e[27m\]" #END reverse
  # default user colors
  export __PS1UC_=$__PS1G_                         # user's color
  export __PS1EMUC_=$__PS1EMG_                     # user's bold color
  export __PS1ERRUC_=$__PS1R_                      # user's ERROR color
  export __PS1ERREMUC_=$__PS1EMR_                  # user's bold ERROR color
  # root colors
  [ $UID -eq "0" ] && __PS1UC_=$__PS1R_           # root's color
  [ $UID -eq "0" ] && __PS1EMUC_=$__PS1EMR_       # root's bold color
  [ $UID -eq "0" ] && __PS1ERRUC_=$__PS1K_        # root's ERROR color
  [ $UID -eq "0" ] && __PS1ERREMUC_=$__PS1EMK_    # root's bold ERROR color
}
__define_PS1_colors


#------------------------------------------------------------------------------
# TARTIFY PARAMETERS : those can all be adapted by your needs
#------------------------------------------------------------------------------

export TARTIFY_ORIGIN_CHAR="O"              # marker for remote repo called 'origin'
export TARTIFY_UPSTREAM_CHAR="U"            # marker for remote repo called 'upstream'
export TARTIFY_REMOTE_CHAR="⇧"              # generic marker for remote repo

export TARTIFY_TRACKING_CHAR="➝"            # marker for tracked branch

export TARTIFY_STASH_CHAR="☆"               # marker for stash
export TARTIFY_COUNTSTASHES=0               # 0: count stashes, 1 don't

export TARTIFY_NOBRANCH_CHAR="nobranch"   # "branch name" replacement string for empty repository
#export TARTIFY_NOBRANCH_CHAR="∅"            # "branch name" replacement string for empty repository
export TARTIFY_DOTGIT_CHAR="<.git>"         # "branch name" replacement string for .git directory
export TARTIFY_BARE_CHAR="<BARE>"           # "branch name" replacement string for bare .git directory

export TARTIFY_UNMERGED_CHAR="✖ "           # there are unmerged files

export TARTIFY_TIMETOCOMMIT=24              # Max nb hours between commits

                                            # (default is 0)
# COLORS/STYLES
export TARTIFY_STYLE_UNTRACKED=${__UN_}     # Untracked Files                 UNDERLINED
export TARTIFY_STYLE_TIMETOCOMMIT=${__EM_}  # Style when commit is overdue    BOLD

export TARTIFY_COLOR_UNSTAGED=${__R_}       # unstaged changes                RED
export TARTIFY_COLOR_STAGED=${__M_}         # staged changes                  MAGENTA
export TARTIFY_COLOR_AHEADOFREMOTE=${__Y_}  # tracked remote behind HEAD      YELLOW
export TARTIFY_COLOR_UPTODATE=${__G_}       # tracked remote == HEAD          GREEN
export TARTIFY_COLOR_NOREMTRACK=${__B_}     # no remote tracking branch       BLUE

export TARTIFY_COLOR_DOTGIT=${__C_}         # inside .git dir                 CYAN

export TARTIFY_COLOR_UNMERGED=${__BL_}${__EMR_} # unmerged files              BOLD RED BLINKING
                                                # (yeah, obnoxious)
#------------------------------------------------------------------------------
#
#             HELPER FUNCTIONS
#
#------------------------------------------------------------------------------
#
#count the nb of commits between two branches of two repositorie
#   ex: __gitps1_diff_count HEAD origin/master
#   ex: __gitps1_diff_count upstream/dev HEAD
function __gitps1_diff_count() {
    echo "$(git rev-list $1..$2 2>/dev/null | awk 'END {print NR}')"
}


function __gitps1_find_tracked(){
  local __branchname=$1
  # find (possible) tracked remote for current branch in repository
  for remotename in $(git remote show); do
    # CURRENT BRANCH is tracked to CURRENT REMOTE ?
    if [[ $(git config --get branch.$__branchname.remote) =~ $remotename ]]; then
        echo $remotename
    fi
  done
}

# Display the help message
function __tart_usage(){
  echo -e "
  ${__UN_}Description${__UNQ_} : One-Liner extended GIT status

  ${__UN_}Usage${__UNQ_} is : ${__EM_}tartify${__EMQ_} [${__Y_}options${__NN_}]

  ${__UN_}Options${__UNQ_} : is a single word (case insensitive) containing any of the following letters :
      ${__Y_}[Elements]${__NN_}
      ${__Y_}n${__NN_}       repository ${__EMY_}N${__NN_}ame
      ${__Y_}b${__NN_}       ${__EMY_}B${__NN_}ranch name
      ${__Y_}r${__NN_}       ${__EMY_}R${__NN_}emotes info
      ${__Y_}s${__NN_}       ${__EMY_}S${__NN_}tash info
      ${__Y_}l${__NN_}       ${__EMY_}L${__NN_}ast commit info

      ${__Y_}[Modes]${__NN_}
      ${__Y_}t${__NN_}       shor${__EMY_}T${__NN_}er    less verbose (not yet implemented)
      ${__Y_}c${__NN_}       no${__EMY_}C${__NN_}olor    strip all colors (whatever the result)
      ${__Y_}o${__NN_}       ${__EMY_}O${__NN_}ldschool  __GITPS1 mode
      ${__Y_}v${__NN_}       ${__EMY_}V${__NN_}im mode   result formated for the Vim tartify plugin
                         (color info appended to result)

      mode order of precedence: ${__EMY_}v${__NN_} > ${__EMY_}o${__NN_} > ${__EMY_}t${__NN_}
      no${__EMY_}C${__NN_}olor mode: only works alone or in cunjunction with shor${__EMY_}T${__NN_}er


      ${__Y_}h|?${__NN_}     ${__EMY_}H${__NN_}elp (display this help message, and ignore the rest)

  ${__UN_}Default${__UNQ_}   tartify   : is equivalent to ${__EM_}tartify${__EMQ_} ${__Y_}nbrsl${__NN_}
            tartify o : is equivalent to ${__EM_}tartify${__EMQ_} ${__Y_}obsr${__NN_}


"
}

#------------------------------------------------------------------------------
#
#             GIT PS1 commands
#
#------------------------------------------------------------------------------
function __gitps1_repo_name()
{
  local nocolors=$1   #TRUE for no color
  local color
  local nocolor
  #? are we inside a GIT repo
  if git rev-parse --git-dir >/dev/null 2>&1
  then
    # Print the REPO's name
    color="\n${__DM_}${__K_}"
    nocolor=$(echo `cd $(git rev-parse --git-dir); cd ../;pwd` | sed 's,.*/,,' | tr -d '\n')
    color=$color$nocolor
    color=$color"/${__NN_}"
  fi
  [ $nocolors ] &&  echo -ne $nocolor || echo -ne $color
}


function __gitps1_stash()
{
  local nocolors=$1   #TRUE for no color
  local color
  local nocolor
  #? are we inside a GIT repo
  if git rev-parse --git-dir >/dev/null 2>&1; then
    #? are we inside a GIT repo's working tree
    if `git rev-parse --is-inside-work-tree`; then
      if [ $(git stash list | wc -l) -gt 0 ]; then

        # One star per stash
        color="${_NN_}${_EMY_}"
        nocolor="  "
        for (( i=0; i< $(git stash list | wc -l); i++ ))
        do
          nocolor=$nocolor$TARTIFY_STASHCHAR" "
        done
        nocolor=$nocolor"   "
        color="$color$nocolor""${_NN_}"

        [[ "$mode" =~ OLDSCHOOL ]] && nocolor="%"
      fi
    fi
  fi
  [ $nocolors ] &&  echo -ne $nocolor || echo -e $color
}


function __gitps1_branch()
{
  # OLDSCHOOL mode
  #
  #   * unstaged
  #   + staged
  #   % untracked
  #
  # VIM mode
  #
  #   $nocolor_infos prepended to branch name
  #
  #   nocolor_infos =~ /[U]?[SAONGBE][T]?[M]?/
  #
  #       [U]nstaged modif(s)
  #
  #       [S]taged modif(s),
  #       [A]head of remote     & nothing staged
  #       [O]K (remote == HEAD) & nothing staged
  #       [N]o tracked remote   & nothing staged
  #       inside .[G]it directory (branch info irrelevant)
  #       inside  [B]are repository (branch info irrelevant)
  #       [E]mpty repository (no branch)
  #
  #       un[T]racked files,
  #       un[M]erged files
  #

  local nocolors=$1     #TRUE for no color
  local mode=$2         #either VIM or OLDSCHOOL
  local color
  local color_base      # branch name base color
  local color_unstaged  # first 2 chars of branch name in case of unstaged modifs
  local style_untracked # special style in case of untracked files
  local nocolor
  local nocolor_infos   # store color infos in an easilly parseable string
  ##? GIT repo
  if git rev-parse --git-dir >/dev/null 2>&1
  then
    local gitdir_=`git rev-parse --git-dir`
    local remotelogentries
    local branchname=$(git branch 2>/dev/null| sed -n '/^\*/s/^\* //p')
    color=${__NN_}
    #? WORKING TREE
    if `git rev-parse --is-inside-work-tree`; then
      #? NON-EMPTY repo
      if [ $(ls $gitdir_/refs/heads/ | wc -l) -gt 0 ]; then

        # --------- WORKING DIR STATE--------
        #? UNSTAGED modifs
        if ! git diff --quiet >/dev/null 2>&1; then
          color_unstaged=$TARTIFY_COLOR_UNSTAGED
          [[ "$mode" =~ VIM ]] && nocolor_infos=$nocolor_infos"U"
          [[ "$mode" =~ OLDSCHOOL ]] && nocolor_infos=$nocolor_infos"*"
        fi

        # ---------- INDEX STATE-------------
        #? Empty INDEX
        if [ !  $(git diff  --cached | wc -l) -gt 0  ]; then
          # ASSUME tracked remote, uptodate with HEAD
          color_base=$TARTIFY_COLOR_UPTODATE
          [[ "$mode" =~ VIM ]] && nocolor_infos=$nocolor_infos"O"

          #? TRACKED Remote
          local hastrackedremote=`__gitps1_find_tracked $branchname`
          if [ $hastrackedremote != "" ]; then
            #? branch's HEAD ahead of tracked remote's
            remotelogentries=$(git log origin/$branchname.. | wc -l )
            if [ $remotelogentries  -gt 0 ]; then
              color_base=$TARTIFY_COLOR_AHEADOFREMOTE
              [[ "$mode" =~ VIM ]] && nocolor_infos=$nocolor_infos"A"
            fi
          # NO TRACKED remote
          else
            color_base=$TARTIFY_COLOR_NOREMTRACK
            [[ "$mode" =~ VIM ]] && nocolor_infos=$nocolor_infos"N"
          fi

        # NON-Empty INDEX
        else
          color_base=$TARTIFY_COLOR_STAGED
          [[ "$mode" =~ VIM ]] && nocolor_infos=$nocolor_infos"S"
          [[ "$mode" =~ OLDSCHOOL ]] && nocolor_infos=$nocolor_infos"+"
        fi


        # ---------- UNMERGED FILES -------------
        if [ $(git ls-files -u | wc -l ) -gt 0 ]
        then
          color=$TARTIFY_COLOR_UNMERGED$TARTIFY_UNMERGED_CHAR$color
          nocolor=$TARTIFY_UNMERGED_CHAR
          [[ "$mode" =~ VIM ]] && nocolor_infos=$nocolor_infos"M"
          #[[ "$mode" =~ OLDSCHOOL ]] && nocolor_infos=$nocolor_infos"M"
        fi


      # EMPTY repo
      else
        branchname=$TARTIFY_NOBRANCH_CHAR
        color_base=$TARTIFY_COLOR_NOREMTRACK
        [[ "$mode" =~ VIM ]] && nocolor_infos="E"
        #[[ "$mode" =~ OLDSCHOOL ]] && nocolor_infos="E"
      fi

      # UNTRACKED FILES
      if [ -n "$(git ls-files --others --exclude-standard)" ]; then
        style_untracked=$TARTIFY_STYLE_UNTRACKED
        [[ "$mode" =~ VIM ]] && nocolor_infos=$nocolor_infos"T"
        [[ "$mode" =~ OLDSCHOOL ]] && nocolor_infos=$nocolor_infos"%"
      fi


    # SPECIAL_CASE: we're inside the .git dir
    else
			# BARE repo
			if [ "true" = "$(git rev-parse --is-bare-repository 2>/dev/null)" ]; then
        branchname=$TARTIFY_BARE_CHAR
        [[ "$mode" =~ VIM ]] && nocolor_infos="B"
      # Non-BARE repo
      else
        branchname=$TARTIFY_DOTGIT_CHAR
        [[ "$mode" =~ VIM ]] && nocolor_infos="G"
      fi
      color_base=$TARTIFY_COLOR_DOTGIT
    fi

    # Highlight the first two characters of branch name with $color_unstaged
    # (if nonempty)
    [[ $color_unstaged == "" ]] && color_unstaged=$color_base
    local __first2=$color_unstaged$style_untracked${branchname:0:2}
    local __remain=$color_base$style_untracked${branchname:2:${#branchname}}
    color=$color$__first2$__remain$__NN_
    #color=$color$color_base$style_untracked$branchname$__NN_
    nocolor=$nocolor$branchname

  else
    return 0
  fi

  [ $nocolors ] &&  {
    if [[ "$mode" =~ VIM ]]; then
      echo -ne $nocolor_infos"|"$nocolor
    elif [[ "$mode" =~ OLDSCHOOL ]]; then
      echo -ne $nocolor$nocolor_infos
    else
      echo -ne $nocolor
    fi
  } || {
    echo -e $color
    #echo ${argstr:0:2}; echo ${argstr:2:${#argstr}}

  }
}


function __gitps1_remote()
{
  # OLDSCHOOL :
  #
  #    #:no upstream

  local nocolors=$1   #TRUE for no color
  local color
  local nocolor
  #? are we inside a GIT repo
  if git rev-parse --git-dir >/dev/null 2>&1
  then
    local gitdir_=`git rev-parse --git-dir`
    local branchname=$(git branch 2>/dev/null| sed -n '/^\*/s/^\* //p')
    color="  "$__NN_

    # NON-EMPTY GIT REPO
    # VERIFY that .git/refs/heads/ directory is not empty
    if [ $(ls $gitdir_/refs/heads/ | wc -l) -gt 0 ]
    then

      # ------- REMOTES INFO ( + BRANCH TRACKED ) --------
      local marker
      local marker_color
      local before_traked
      local after_tracked
      local before_untraked
      local after_untracked

      # loop through remotes
      for remotename in $(git remote show); do

        # special markers for origin and upstream
        # nb: a tracked remote is preceded by a little ➝ symbol
        case $remotename in
            origin)   marker="O"; marker_color="${__G_}"   ;;  #green
          upstream)   marker="U"; marker_color="${__M_}"   ;;  #magenta
                  *)   marker="⇧"; marker_color="${__Y_}"   ;;  #yellow
        esac

        # CURRENT BRANCH is tracked to CURRENT REMOTE ?
        if [[ $(git config --get branch.$branchname.remote) =~ $remotename ]]
        then
          [ $nocolors ]  &&  { before_traked=" ➝ "; after_tracked="";
                                before_untraked=" "; after_untracked=""; } ||
                              { before_traked=" ➝${__EM_} "; after_tracked="${_EMQ_}";
                                before_untraked=" "; after_untracked=""; }
        else
          before_traked=""; after_tracked="";before_traked=" "; after_tracked=""; 
        fi


        # nb of commits AHEAD/BEHIND
        local ahead_count="$(__gitps1_diff_count $remotename/$branchname HEAD)"
        local behind_count="$(__gitps1_diff_count HEAD $remotename/$branchname)"
        local diffcount=""
        local diffcountnocol=""
        if [ 0 -lt "$ahead_count" ]; then
            diffcount="${__G_}${ahead_count}"
            diffcountnocol="+${ahead_count}"
        fi

        if [ 0 -lt "$behind_count" ]; then
            [ -n "$diffcount" ] && { 
                    diffcount="${diffcount}${marker_color}/"
                    diffcountnocol="${diffcountnocol}/"
                  }
            diffcount="${diffcount}${__R_}${behind_count}"
            diffcountnocol="${diffcountnocol}-${behind_count}"
        fi

        [ -n "$diffcount" ] && diffcount=" ${marker_color}($diffcount${marker_color}) "
        [ -n "$diffcountnocol" ] && diffcountnocol=" ($diffcountnocol) "
        #echo "$diffcount"


        color=$color"${marker_color}${before_traked}${marker}${after_tracked}${diffcount}${__NN_}"
        nocolor=$nocolor"${before_traked}${marker}${after_tracked}${diffcountnocol}"

      done
    fi
  else
    return 0
  fi
  [ $nocolors ] &&  echo -ne $nocolor || echo -e $color
}


function __gitps1_timeLastCommit(){
  echo ""
}


#------------------------------------------------------------------------------
#
#             TARTIFY
#
#------------------------------------------------------------------------------
function tartify()
{
  # To Lower Case
  local argstr=`echo $1 | tr '[A-Z]' '[a-z]'`
  # Help
  [[ "$argstr" =~ ? || "$argstr" =~ h ]] && { __tart_usage; return 0; }
  # Empty arg (default)
  [ ${#argstr} == 0 ] && argstr="nbrsl"

  local separator
  local nocolor
  local mode
  # No Colors MODE : strip all color info, whatever the result
  [[ "$argstr" =~ v ]] && { 
      nocolor=TRUE
  }
  # Vim MODE : no color, prepend color infos for 'branch', use '#' as separator
  [[ "$argstr" =~ v ]] && { 
      separator="#"
      nocolor=TRUE
      mode="VIM"
  }
  # OldSchool MODE : no color, branch results with $*+, stash results with %
  [[ "$argstr" =~ o ]] && { 
      # tartify o == tartify bsr
      [ ${#argstr} == 1 ] && argstr="bsr"

      export TARTIFY_STASHCHAR="%"
      separator=" "
      nocolor=TRUE
      mode="OLDSCHOOL"
  }

  local tartAnswer=""
  local i
  for ((i=0;i<${#argstr};i++))
  do
    local ch=${argstr:$i:1}
    case $ch in
      n) tartAnswer=$tartAnswer$separator$(__gitps1_repo_name $nocolor);;
      b) tartAnswer=$tartAnswer$separator$(__gitps1_branch $nocolor $mode);;
      r) tartAnswer=$tartAnswer$separator$(__gitps1_remote $nocolor);;
      s) tartAnswer=$tartAnswer$separator$(__gitps1_stash $nocolor);;
      l) tartAnswer=$tartAnswer$separator$(__gitps1_timeLastCommit $nocolor);;
      o) ;;
      v) ;;
      *) echo "Unknown option \"$ch\""; __tart_usage; return 1 ;;
    esac
  done


  #echo -e "$(__gitps1_repo_name)$(__gitps1_branch)  $(__gitps1_remote) $(__gitps1_stash)"
  echo -e $tartAnswer
}

#------------------------------------------------------------------------------
#
#             EXPORTING (for use in other things : Vim,...)
#
#------------------------------------------------------------------------------
export -f __gitps1_diff_count
export -f __gitps1_repo_name
export -f __gitps1_branch
export -f __gitps1_remote
export -f __gitps1_stash
export -f tartify
#export -f __echoe
export __tartify_shell_loaded=1








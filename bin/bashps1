#!/bin/bash
##################################################################################
#
#       Filename:  bashps1
#
#    Description:  BASH PS1 with GIT support
#
#                  Colored command prompt adapted to GIT repository. VERY
#                  colorfull, not for the faint hearted
#
#  Configuration:  place this file somewhere in your PATH and source it in your
#                  .bashrc
#
#                     source /path/to/bashps1
#
#   Dependencies:  Depends on GIT, might work on windows with Cygwin
#
#   GVIM Version:  1.7+ (?)
#
#         Author:  Pierre Lhoste
#        Twitter:  http://twitter.com/peterhost
#
#        Version:  0.1
#        Created:  01.05.2011
#        License:  WTFPL V2
#
# DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE Version 2, December 2004
#
# Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>
#
# Everyone is permitted to copy and distribute verbatim or modified
# copies of this license document, and changing it is allowed as long as
# the name is changed.
#
#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE TERMS AND
#            CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
#
#  0. You just DO WHAT THE FUCK YOU WANT TO.
#
#------------------------------------------------------------------------------
#

# USAGE : Just call the tartify() function from the command line
#
#         PROMPT integration : call tartify() inside your $PS1. Examples:
#
#           PS1="\$(tartify) [\u@\h]\$ "
#           PS1="\$(tartify)\n[\u@\h]\$ "
#           ...
#
#         You can also pass arguments to tartify() to make it display only
#         certain informations
#
#           tartify -h
#
#

#PS1="${__PS1NN_}${__PS1EMK_}[${__PS1UC_}\u${__PS1EMK_}@${__PS1EMUC_}\h ${__PS1C_}\${NEW_PWD}${__PS1EMK_}] \$"
#PROMPT_COMMAND=tartify
#
#
#
#------------------------------------------------------------------------------
#
# ISSUE :
#
#   * no support for SVN upstream
#
#   * Line Wrapping Calculation
#
#     Two things that I know of can confuse line wrapping (when browsing
#     command history with long lines, for ex) :
#
#       1 - non-printable characters in the PS1 variable have to be "escaped"
#       by enclosing them between a pair of escaped brackets :
#
#           \[\033[0;30m\]   instead of  \033[0;30m
#
#       2 - function calls inside the PS1 variable that issue non-printable
#       characters
#
#           "\$(myFunc)"
#
#       need to be issued on a line prior to the last line of the PS1 variable,
#       otherwise they will confuse wrapping too
#
#       (SEE:http://hintsforums.macworld.com/archive/index.php/t-17068.html)
#
#
#------------------------------------------------------------------------------
#
# NOTA :
#          Special Character Codes
#          \a – an ASCII bell character (07)
#          \d – the date in “Weekday Month Date” format (e.g., “Tue May 26″)
#          \D{format} – the format is passed to strftime(3) and the result is inserted into the prompt string; an empty format results in a locale-specific time representation. The braces are required
#          \e – an ASCII escape character (033)  (hence : \e and \033 are equivalent)
#          \h – the hostname up to the first `.’
#          \H – the hostname
#          \j – the number of jobs currently managed by the shell
#          \l – the basename of the shell’s terminal device name
#          \n – newline
#          \r – carriage return
#          \s – the name of the shell, the basename of $0 (the portion following the final slash)
#          \t – the current time in 24-hour HH:MM:SS format
#          \T – the current time in 12-hour HH:MM:SS format
#          \@ – the current time in 12-hour am/pm format
#          \A – the current time in 24-hour HH:MM format
#          \u – the username of the current user
#          \v – the version of bash (e.g., 2.00)
#          \V – the release of bash, version + patchelvel (e.g., 2.00.0)
#          \w – the current working directory
#          \W – the basename of the current working directory
#          \! – the history number of this command
#          \# – the command number of this command
#          \$ – if the effective UID is 0, a #, otherwise a $
#          \nnn – the character corresponding to the octal number nnn
#          \\ – a backslash
#          \[ - begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt
#          \] – end a sequence of non-printing characters
#
#          (http://www.wiredrevolution.com/bash-programming/customize-the-bash-ps1-command-prompt)



#------------------------------------------------------------------------------
#
#             SHELL DETECTION
#
#------------------------------------------------------------------------------
# SHELL detection
__thisShell=`ps $$ | grep $$ | awk '{ print $5 }'`

# Darwin detection
if uname -s | grep "Darwin" >/dev/null 2>&1
then
  __OSflavor="Darwin" # macos
fi

# BAIL if using SH on OSX, (scrambles "echo -ne" commands)
[[ "$__OSflavor" =~ Darwin  &&  "$__thisShell" == sh ]] && exit 1

#------------------------------------------------------------------------------
#
#             MISC GLOBAL VARIABLES
#
#------------------------------------------------------------------------------
# COLOR VARS : declare those ANSI color codes in variables ONCE and for ALL.
#              This somewhat pollutes the GLOBAL SCOPE but the variable names
#              are (thought to be) unique enough so that won't cause problems
#
# Define Colors (to be used in standard echo & printf commands)
#------------------------------------------------------------------------------
function __define_echo_ne_colors() {
  # regular colors
  export __K_="\033[0;30m"    # black
  export __R_="\033[0;31m"    # red
  export __G_="\033[0;32m"    # green
  export __Y_="\033[0;33m"    # yellow
  export __B_="\033[0;34m"    # blue
  export __M_="\033[0;35m"    # magenta
  export __C_="\033[0;36m"    # cyan
  export __W_="\033[0;37m"    # white
  # empahsized (bolded) colors
  export __EMK_="\033[1;30m"
  export __EMR_="\033[1;31m"
  export __EMG_="\033[1;32m"
  export __EMY_="\033[1;33m"
  export __EMB_="\033[1;34m"
  export __EMM_="\033[1;35m"
  export __EMC_="\033[1;36m"
  export __EMW_="\033[1;37m"
  # background colors
  export __BGK_="\033[40m"
  export __BGR_="\033[41m"
  export __BGG_="\033[42m"
  export __BGY_="\033[43m"
  export __BGB_="\033[44m"
  export __BGM_="\033[45m"
  export __BGC_="\033[46m"
  export __BGW_="\033[47m"
  # styles
  export __NN_="\033[0m"  # unsets color to term's fg color
  export __EM_="\033[1m"  #bold
  export __DM_="\033[2m"  #dim
  export __UN_="\033[4m"  #underline
  export __BL_="\033[5m"  #blink
  export __RV_="\033[7m"  #reverse
  export __EMQ_="\033[21m" #END bold
  export __DMQ_="\033[22m" #END dim
  export __UNQ_="\033[24m" #END underline
  export __BLQ_="\033[25m" #END blink
  export __RVQ_="\033[27m" #END reverse
  # default user colors
  export __UC_=$__G_                         # user's color
  export __EMUC_=$__EMG_                     # user's bold color
  export __ERRUC_=$__R_                      # user's ERROR color
  export __ERREMUC_=$__EMR_                  # user's bold ERROR color
  # root colors
  [ $UID -eq "0" ] && __UC_=$__R_           # root's color
  [ $UID -eq "0" ] && __EMUC_=$__EMR_       # root's bold color
  [ $UID -eq "0" ] && __ERRUC_=$__K_        # root's ERROR color
  [ $UID -eq "0" ] && __ERREMUC_=$__EMK_    # root's bold ERROR color
}
__define_echo_ne_colors
#
#
# Define Colors (to be used in the PS1 variable)
function __define_PS1_colors() {
  # regular colors
  export __PS1K_="\[\e[0;30m\]"    # black
  export __PS1R_="\[\e[0;31m\]"    # red
  export __PS1G_="\[\e[0;32m\]"    # green
  export __PS1Y_="\[\e[0;33m\]"    # yellow
  export __PS1B_="\[\e[0;34m\]"    # blue
  export __PS1M_="\[\e[0;35m\]"    # magenta
  export __PS1C_="\[\e[0;36m\]"    # cyan
  export __PS1W_="\[\e[0;37m\]"    # white
  # empahsized (bolded) colors
  export __PS1EMK_="\[\e[1;30m\]"
  export __PS1EMR_="\[\e[1;31m\]"
  export __PS1EMG_="\[\e[1;32m\]"
  export __PS1EMY_="\[\e[1;33m\]"
  export __PS1EMB_="\[\e[1;34m\]"
  export __PS1EMM_="\[\e[1;35m\]"
  export __PS1EMC_="\[\e[1;36m\]"
  export __PS1EMW_="\[\e[1;37m\]"
  # background colors
  export __PS1BGK_="\[\e[40m\]"
  export __PS1BGR_="\[\e[41m\]"
  export __PS1BGG_="\[\e[42m\]"
  export __PS1BGY_="\[\e[43m\]"
  export __PS1BGB_="\[\e[44m\]"
  export __PS1BGM_="\[\e[45m\]"
  export __PS1BGC_="\[\e[46m\]"
  export __PS1BGW_="\[\e[47m\]"
  # styles
  export __PS1NN_="\[\e[0m\]"  # unsets color to term's fg color
  export __PS1EM_="\[\e[1m\]"  #bold
  export __PS1DM_="\[\e[2m\]"  #dim
  export __PS1UN_="\[\e[4m\]"  #underline
  export __PS1BL_="\[\e[5m\]"  #blink
  export __PS1RV_="\[\e[7m\]"  #reverse
  export __PS1EMQ_="\[\e[21m\]" #END bold
  export __PS1DMQ_="\[\e[22m\]" #END dim
  export __PS1UNQ_="\[\e[24m\]" #END underline
  export __PS1BLQ_="\[\e[25m\]" #END blink
  export __PS1RVQ_="\[\e[27m\]" #END reverse
  # default user colors
  export __PS1UC_=$__PS1G_                         # user's color
  export __PS1EMUC_=$__PS1EMG_                     # user's bold color
  export __PS1ERRUC_=$__PS1R_                      # user's ERROR color
  export __PS1ERREMUC_=$__PS1EMR_                  # user's bold ERROR color
  # root colors
  [ $UID -eq "0" ] && __PS1UC_=$__PS1R_           # root's color
  [ $UID -eq "0" ] && __PS1EMUC_=$__PS1EMR_       # root's bold color
  [ $UID -eq "0" ] && __PS1ERRUC_=$__PS1K_        # root's ERROR color
  [ $UID -eq "0" ] && __PS1ERREMUC_=$__PS1EMK_    # root's bold ERROR color
}
__define_PS1_colors



#------------------------------------------------------------------------------
#
#             HELPER FUNCTIONS
#
#------------------------------------------------------------------------------
#

# NOTE: we support only BASH for the moment
#
## Darwin detection
#if uname -s | grep "Darwin" >/dev/null 2>&1
#then
#  __OSflavor="Darwin" # macos
#fi

## SHELL detection
#__thisShell=`ps $$ | grep $$ | awk '{ print $5 }'`

## fix "echo -e" (non)implementation for SH on OSX

#function __echoe(){
#  [[ "$__OSflavor" =~ Darwin  &&  "$__thisShell" == sh ]] && echo $1 || echo -e $1
#}
#function __echone(){
#  [[ "$__OSflavor" =~ Darwin  &&  "$__thisShell" == sh ]] && echo -n $1 || echo -e $1
#}




#[[ "$__OSflavor" =~ Darwin  &&  "$__thisShell" =~ sh ]] && {
#    eval "__echoe(){ echo \$1 }"
#    eval "__echone(){ echo -n \$1 }"
#  } || {
#    eval "__echoe(){ echo -e \$1 }"
#    eval "__echone(){ echo -ne \$1 }"
#  }



#count the nb of commits between two branches of two repositorie
#   ex: __gitps1_diff_count HEAD origin/master
#   ex: __gitps1_diff_count upstream/dev HEAD
function __gitps1_diff_count() {
    echo "$(git rev-list $1..$2 2>/dev/null | awk 'END {print NR}')"
}


#------------------------------------------------------------------------------
#
#             GIT PS1 commands
#
#------------------------------------------------------------------------------
function __gitps1_repo_name()
{
  local notartify=$1   #TRUE for no color
  local color
  local nocolor
  #? are we inside a GIT repo
  if git rev-parse --git-dir >/dev/null 2>&1
  then
    # Print the REPO's name
    color="\n${__DM_}${__K_}"
    nocolor=$(echo `cd $(git rev-parse --git-dir); cd ../;pwd` | sed 's,.*/,,' | tr -d '\n')
    color=$color$nocolor
    color=$color"/${__NN_}"
  fi
  [ $notartify ] &&  echo -ne $nocolor || echo -ne $color
}


function __gitps1_stash()
{
  local notartify=$1   #TRUE for no color
  local color
  local nocolor
  #? are we inside a GIT repo
  if git rev-parse --git-dir >/dev/null 2>&1
  then
    #? are we inside a GIT repo's working tree
    if `git rev-parse --is-inside-work-tree`
    then
      if [ $(git stash list | wc -l) -gt 0 ]
      then

        # One star per stash
        color="${_NN_}${_EMY_}"
        nocolor="  "
        for (( i=0; i< $(git stash list | wc -l); i++ ))
        do
          nocolor=$nocolor"☆ "
        done
        nocolor=$nocolor"   "
        color="$color$nocolor""${_NN_}"

      fi
    fi
  fi
  [ $notartify ] &&  echo -ne $nocolor || echo -e $color
}


function __gitps1_branch()
{
  # COLORED mode
  #
  # unstaged modifications :              RED
  # uncommited material :                 MAGENTA
  # unpushed commits to tracked remote :  YELLOW
  # all is commited and pushed :          GREEN
  #
  # untracked files :                     UNDERLINED
  #
  # inside .git dir :                     BLUE
  #
  # NON COLORED mode
  # optionnal return value $nocolor_infos
  #
  #   nocolor_info="(S|C|P|O|G)(U)?(M)?"
  #       S:unstaged, C:uncommited, P:unpushed, O:allisOK,G:insideDotGit
  #       U:untracked, M:unmerged
  #

  local notartify=$1   #TRUE for no color
  local givemeinfos=$2 #TRUE prepends $nocolor_info"|" to the result
  local color
  local nocolor
  local nocolor_infos # store color infos in an easilly parseable string
  #? are we inside a GIT repo's working tree
  if git rev-parse --git-dir >/dev/null 2>&1
  then
    local gitdir_=`git rev-parse --git-dir`

    local commited=false
    local remotelogentries
    local isunstaged
    local isuntracked
    local branchname=$(git branch 2>/dev/null| sed -n '/^\*/s/^\* //p')
    color=${__NN_}
    if `git rev-parse --is-inside-work-tree`; then
    ##? are we inside a GIT repo
      # NON-EMPTY GIT REPO
      # VERIFY that .git/refs/heads/ directory is not empty
      if [ $(ls $gitdir_/refs/heads/ | wc -l) -gt 0 ]
      then

        #? ALL modified files are STAGED
        if git diff --quiet >/dev/null 2>&1
        then


          #? all STAGED changes commited
          #  YES : green
          if [ !  $(git diff  --cached | wc -l) -gt 0  ]
          then
            color=$color$__G_ #GREEN
            nocolor_infos="O"


            #? is there a remote for this repo ?
            if [ $(git remote show | wc -l) -gt 0 ]
            then
              # restrict test to the remote called 'origin'
              if git remote show | grep origin >/dev/null
              then

                #? all comits in current branch have been pushed to remote with in same branch
                #  NO : yellow
                remotelogentries=$(git log origin/$branchname.. | wc -l )
                if [ $remotelogentries  -gt 0 ]
                then
                  color=$color$__EMY_ #YELLOW BOLD
                  nocolor_infos="P"
                fi
              fi
            fi
          #  NO: MAGENTA
          else
            color=$color$__M_ #MAGENTA
            nocolor_infos="C"
          fi

        #  NO : RED
        else
          color=$color$__EMR_ #BOLD RED
          nocolor_infos="S"
          commited=false
        fi


        #? UNTRACKED FILES -> underlined
        if [ -n "$(git ls-files --others --exclude-standard)" ]; then
          color=$color$__UN_
          nocolor_infos=$nocolor_infos"U"
        fi

        color=$color$branchname$__NN_
        nocolor=$branchname

        # ---------- UNMERGED FILES -------------
        if [ $(git ls-files -u | wc -l ) -gt 0 ]
        then
          color=$__BL_$__EMR_"   ✖  "$__NN_$color #BOLD RED BLINKING CROSS
          nocolor_infos=$nocolor_infos"M"
        fi


      fi

    # SPECIAL_CASE: we're inside the .git dir
    else
        color=$color$__B_"<.git>" #BLUE
        nocolor="<.git>"
        nocolor_infos="G"
    fi
  else
    return 0
  fi

  [ $notartify ] &&  {
      [ $givemeinfos ] && echo -ne $nocolor_infos"|"$nocolor || echo -ne $nocolor 
  } || echo -e $color
}


function __gitps1_remote()
{

  local notartify=$1   #TRUE for no color
  local color
  local nocolor
  #? are we inside a GIT repo
  if git rev-parse --git-dir >/dev/null 2>&1
  then
    local gitdir_=`git rev-parse --git-dir`
    local branchname=$(git branch 2>/dev/null| sed -n '/^\*/s/^\* //p')
    color="  "$__NN_

    # NON-EMPTY GIT REPO
    # VERIFY that .git/refs/heads/ directory is not empty
    if [ $(ls $gitdir_/refs/heads/ | wc -l) -gt 0 ]
    then

      # ------- REMOTES INFO ( + BRANCH TRACKED ) --------
      local marker
      local marker_color
      local before_traked
      local after_tracked
      local before_untraked
      local after_untracked

      # loop through remotes
      for remotename in $(git remote show); do

        # special markers for origin and upstream
        # nb: a tracked remote is preceded by a little ➝ symbol
        case $remotename in
            origin)   marker="O"; marker_color="${__G_}"   ;;  #green
          upstream)   marker="U"; marker_color="${__M_}"   ;;  #magenta
                  *)   marker="⇧"; marker_color="${__Y_}"   ;;  #yellow
        esac

        # CURRENT BRANCH is tracked to CURRENT REMOTE ?
        if [[ $(git config --get branch.$branchname.remote) =~ $remotename ]]
        then
          [ $notartify ]  &&  { before_traked=" ➝ "; after_tracked="";
                                before_untraked=" "; after_untracked=""; } ||
                              { before_traked=" ➝${__EM_} "; after_tracked="${_EMQ_}";
                                before_untraked=" "; after_untracked=""; }
        else
          before_traked=""; after_tracked="";before_traked=" "; after_tracked=""; 
        fi


        # nb of commits AHEAD/BEHIND
        local ahead_count="$(__gitps1_diff_count $remotename/$branchname HEAD)"
        local behind_count="$(__gitps1_diff_count HEAD $remotename/$branchname)"
        local diffcount=""
        local diffcountnocol=""
        if [ 0 -lt "$ahead_count" ]; then
            diffcount="${__G_}${ahead_count}"
            diffcountnocol="+${ahead_count}"
        fi

        if [ 0 -lt "$behind_count" ]; then
            [ -n "$diffcount" ] && { 
                    diffcount="${diffcount}${marker_color}/"
                    diffcountnocol="${diffcountnocol}/"
                  }
            diffcount="${diffcount}${__R_}${behind_count}"
            diffcountnocol="${diffcountnocol}-${behind_count}"
        fi

        [ -n "$diffcount" ] && diffcount=" ${marker_color}($diffcount${marker_color}) "
        [ -n "$diffcountnocol" ] && diffcountnocol=" ($diffcountnocol) "
        #echo "$diffcount"


        color=$color"${marker_color}${before_traked}${marker}${after_tracked}${diffcount}${__NN_}"
        nocolor=$nocolor"${before_traked}${marker}${after_tracked}${diffcountnocol}"

      done
    fi
  else
    return 0
  fi
  [ $notartify ] &&  echo -ne $nocolor || echo -e $color
}


function tartify()
{
    echo -e "$(__gitps1_repo_name)$(__gitps1_branch)  $(__gitps1_remote) $(__gitps1_stash)"

}

#------------------------------------------------------------------------------
#
#             EXPORTING (for use in other things : Vim,...)
#
#------------------------------------------------------------------------------
export -f __gitps1_diff_count
export -f __gitps1_repo_name
export -f __gitps1_branch
export -f __gitps1_remote
export -f __gitps1_stash
#export -f __echoe
export __tartify_shell_loaded=1








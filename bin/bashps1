#!/bin/bash
##################################################################################
#
#       Filename:  bashps1
#
#    Description:  BASH PS1 with GIT support
#
#                  Colored command prompt adapted to GIT repository. VERY
#                  colorfull, not for the faint hearted
#
#  Configuration:  place this file somewhere in your PATH and source it in your
#                  .bashrc
#
#                     source /path/to/bashps1
#
#   Dependencies:  Depends on GIT, might work on windows with Cygwin
#
#   GVIM Version:  1.7+ (?)
#
#         Author:  Pierre Lhoste
#        Twitter:  http://twitter.com/peterhost
#
#        Version:  0.1
#        Created:  01.05.2011
#        License:  WTFPL V2
#
# DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE Version 2, December 2004
#
# Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>
#
# Everyone is permitted to copy and distribute verbatim or modified
# copies of this license document, and changing it is allowed as long as
# the name is changed.
#
#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE TERMS AND
#            CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
#
#  0. You just DO WHAT THE FUCK YOU WANT TO.
#
#------------------------------------------------------------------------------
#

# USAGE : Just call the tartify() function from the command line
#
#         PROMPT integration : call tartify() inside your $PS1. Examples:
#
#           PS1="\$(tartify) [\u@\h]\$ "
#           PS1="\$(tartify)\n[\u@\h]\$ "
#           ...
#
#         You can also pass arguments to tartify() to make it display only
#         certain informations
#
#           tartify -h
#
#

#PS1="${__PS1NN_}${__PS1EMK_}[${__PS1UC_}\u${__PS1EMK_}@${__PS1EMUC_}\h ${__PS1C_}\${NEW_PWD}${__PS1EMK_}] \$"
#PROMPT_COMMAND=tartify
#
#
#
#------------------------------------------------------------------------------
#
# ISSUE :
#
#   * no support for SVN upstream (as I don't use SVN), feel free to augment
#     this script
#
#   * Line Wrapping Calculation
#
#     The one thing (that I know of) which confuse line wrapping (when browsing
#     command history with long lines, for ex) is non-printable characters 
#     (such as ansi escape color codes, cursor movement,...). So:
#
#       1 - non-printable characters in the PS1 variable have to be "escaped"
#       by enclosing them between a pair of escaped brackets :
#
#           \[\033[0;30m\]   instead of  \033[0;30m
#
#       And this has to be done at PS1 definition-time, as PS1 is only assigned
#       ONCE but evaluated at EACH PROMPT.
#
#       2 - function calls inside the PS1 variable that issue non-printable
#       characters will confuse the prompt, naturally, if the said n-p-chars
#       are not escaped IN the PS1 variable itself at assignement time. Example :
#
#               PS1=">"
#               > pwd
#               /some/dir
#               > myfunc(){ echo  "\[\033[0;30m\]\$(pwd) > \[\033[0m\]"; }
#               > myfunc
#               \[\033[0;30m\]$(pwd) > \[\033[0m\]
#
#           this will work
#               > PS1=$(myfunc)
#               /some/dir > echo $PS1
#               \[\033[0;30m\]$(pwd) > \[\033[0m\]
#               /some/dir > cd tmp
#               /some/dir/tmp >
#
#            this won't:
#               /some/dir/tmp > PS1='$(myfunc)'
#               \[\]stevejobs~ echo $PS1
#               $(myfunc)

#            As you can see in the latter, there are no escaped ansi codes
#            whatsoever, just a function call.  the prompt will print
#            litterally '\[\033[0;30m\]' each time, as this escaped substring
#            was not hardcoded in the PS1 variable at the time when it was
#            assigned, but generated by a function call evaluated for each
#            prompt, INSIDE the PS1 variable

#       MORE: on the subject
#       http://www.issociate.de/board/post/481503/bash_command_substitution,_functions_and_quoting_:_need_help.html
#
#     Problem is : if a function used in the PS1 variable is to adapt it's colored
#                  output according to context, there is no way to hardcode that
#                  directly in $PS1 with the '\[' escapes.
#
#       -> better use `printf` rather than `echo` (which somewhat sucks and which
#       behaviour is inconsistant across shells and OSes)
#
#       OR...
#       -> need to be issued on a line prior to the last line of the prompt, with :
#           * either \n insertion,
#
#               PS1="\$(tartify)\n$ "
#
#           * or use of the PROMPT_COMMAND environment variable
#
#               __somefunc() {
#                 ...
#                 tartify
#                 ...
#               }
#               export PROMPT_COMMAND=__somefunc
#               PS1=...
#
#       otherwise they will confuse wrapping too. Hence, your PS1 better look
#       something like :
#
#
#
#       (SEE:http://hintsforums.macworld.com/archive/index.php/t-17068.html)
#
#    * Quick n dirty benchmark
#      loop over 1000 executions of `tartify` on a 3.06GHz Intel Core 2 Duo Imac
#      without any methodology
#
#       **execution-time (ms)**
#       _____________________________________________________________
#      |    REPO   | TINY       | SMALL     | MEDIUM    | LARGE      |
#      |           | ms   %     | ms   %    | ms   %    | ms   %     |
#      |___________|____________|___________|___________|____________|
#      |    remote | 48   25%   | 59   29%  | 92   27%  | 93  23%    |
#      |   1 stash | 56   30%   | 56   28%  | 179  52%  | 202 50%    |
#      |    branch | 60   32%   | 63   31%  | 46   13%  | 81  20%    |
#      |      repo | 14    7%   | 13    6%  | 13    4%  | 14   3%    |
#      |  timelast | 11    6%   | 11    5%  | 12    3%  | 12   3%    |
#      |           |            |           |           |            |
#      |     total | 189        | 202       | 342       | 402        |
#      |           |            |           |           |            |
#      | __git_ps1 |            |           |           | 63         |
#      |___________|____________|___________|___________|____________|
#
#
#------------------------------------------------------------------------------
#
# NOTA :
#          Special Character Codes
#          \a – an ASCII bell character (07)
#          \d – the date in “Weekday Month Date” format (e.g., “Tue May 26″)
#          \D{format} – the format is passed to strftime(3) and the result is inserted into the prompt string; an empty format results in a locale-specific time representation. The braces are required
#          \e – an ASCII escape character (033)  (hence : \e and \033 are equivalent)
#          \h – the hostname up to the first `.’
#          \H – the hostname
#          \j – the number of jobs currently managed by the shell
#          \l – the basename of the shell’s terminal device name
#          \n – newline
#          \r – carriage return
#          \s – the name of the shell, the basename of $0 (the portion following the final slash)
#          \t – the current time in 24-hour HH:MM:SS format
#          \T – the current time in 12-hour HH:MM:SS format
#          \@ – the current time in 12-hour am/pm format
#          \A – the current time in 24-hour HH:MM format
#          \u – the username of the current user
#          \v – the version of bash (e.g., 2.00)
#          \V – the release of bash, version + patchelvel (e.g., 2.00.0)
#          \w – the current working directory
#          \W – the basename of the current working directory
#          \! – the history number of this command
#          \# – the command number of this command
#          \$ – if the effective UID is 0, a #, otherwise a $
#          \nnn – the character corresponding to the octal number nnn
#          \\ – a backslash
#          \[ - begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt
#          \] – end a sequence of non-printing characters
#
#          (http://www.wiredrevolution.com/bash-programming/customize-the-bash-ps1-command-prompt)



#------------------------------------------------------------------------------
#
#             SHELL DETECTION
#
#------------------------------------------------------------------------------
# SHELL detection
__thisShell=`ps $$ | grep $$ | awk '{ print $5 }'`

# Darwin detection
if uname -s | grep "Darwin" >/dev/null 2>&1
then
  __OSflavor="Darwin" # macos
fi

# BAIL if using SH on OSX, (scrambles "echo -ne" commands)
[[ "$__OSflavor" =~ Darwin  &&  "$__thisShell" == sh ]] && exit 1

#------------------------------------------------------------------------------
#
#             MISC GLOBAL VARIABLES
#
#------------------------------------------------------------------------------

__tartify_define_colors() {
# COLOR VARS : declare those ANSI color codes in variables ONCE and for ALL.
#              This somewhat pollutes the GLOBAL SCOPE but the variable names
#              are (thought to be) unique enough so that won't cause problems
#
# Define Colors (to be used in standard echo & printf commands)

  # regular colors
  export __K_="\033[0;30m"    # black
  export __R_="\033[0;31m"    # red
  export __G_="\033[0;32m"    # green
  export __Y_="\033[0;33m"    # yellow
  export __B_="\033[0;34m"    # blue
  export __M_="\033[0;35m"    # magenta
  export __C_="\033[0;36m"    # cyan
  export __W_="\033[0;37m"    # white
  # empahsized (bolded) colors
  export __EMK_="\033[1;30m"
  export __EMR_="\033[1;31m"
  export __EMG_="\033[1;32m"
  export __EMY_="\033[1;33m"
  export __EMB_="\033[1;34m"
  export __EMM_="\033[1;35m"
  export __EMC_="\033[1;36m"
  export __EMW_="\033[1;37m"
  # background colors
  export __BGK_="\033[40m"
  export __BGR_="\033[41m"
  export __BGG_="\033[42m"
  export __BGY_="\033[43m"
  export __BGB_="\033[44m"
  export __BGM_="\033[45m"
  export __BGC_="\033[46m"
  export __BGW_="\033[47m"
  # styles
  export __NN_="\033[0m"  # unsets color to term's fg color
  export __EM_="\033[1m"  #bold
  export __DM_="\033[2m"  #dim
  export __UN_="\033[4m"  #underline
  export __BL_="\033[5m"  #blink
  export __RV_="\033[7m"  #reverse
  export __EMQ_="\033[21m" #END bold
  export __DMQ_="\033[22m" #END dim
  export __UNQ_="\033[24m" #END underline
  export __BLQ_="\033[25m" #END blink
  export __RVQ_="\033[27m" #END reverse
  # default user colors
  export __UC_=$__G_                         # user's color
  export __EMUC_=$__EMG_                     # user's bold color
  export __ERRUC_=$__R_                      # user's ERROR color
  export __ERREMUC_=$__EMR_                  # user's bold ERROR color
  # root colors
  [ $UID -eq "0" ] && __UC_=$__R_           # root's color
  [ $UID -eq "0" ] && __EMUC_=$__EMR_       # root's bold color
  [ $UID -eq "0" ] && __ERRUC_=$__K_        # root's ERROR color
  [ $UID -eq "0" ] && __ERREMUC_=$__EMK_    # root's bold ERROR color
}


__tartify_init_globs(){
# TARTIFY PARAMETERS : adapt to your needs




# // TIME
export TARTIFY_TIME_BUGME=TRUE                  # non empty : will color the 'time since last commit' string and
                                                #             apply the TARTIFY_STYLE_SHOULDCOMMIT style to the
                                                #             branch name
export TARTIFY_TIME_COULDCOMMIT=3600            #     nb seconds after which you COULD  commit
export TARTIFY_TIME_SHOULDCOMMIT=86400          # Max nb seconds after which you SHOULD commit
                                                # (default is 86400, 24hours)
export TARTIFY_STYLE_SHOULDCOMMIT=${__EM_}      # Style when commit is overdue     BOLD
                                                # (applied to branchname)

                                                # colors applied to the 'time elapsed since last commit' string
export TARTIFY_COLOR_TIME_APLENTY=${__G_}       #                                  GREEN
export TARTIFY_COLOR_TIME_COULDCOMMIT=${__Y_}   #                                  YELLOW
export TARTIFY_COLOR_TIME_SHOULDCOMMIT=${__R_}  #                                  RED

# //BRANCH
export TARTIFY_STRING_NOBRANCH="nobranch"       # "branch name" replacement string for empty repository
export TARTIFY_STRING_DOTGIT="<.git>"           # "branch name" replacement string for .git directory
export TARTIFY_STRING_BARE="<BARE>"             # "branch name" replacement string for bare .git directory

export TARTIFY_STYLE_UNTRACKED=${__UN_}         # Untracked Files                  UNDERLINED

export TARTIFY_COLOR_UNSTAGED=${__EMR_}         # unstaged changes (first 2 chars) BOLD RED
export TARTIFY_COLOR_STAGED=${__M_}             # staged changes                   MAGENTA
export TARTIFY_COLOR_AHEADOFREMOTE=${__Y_}      # tracked remote behind HEAD       YELLOW
export TARTIFY_COLOR_UPTODATE=${__G_}           # tracked remote == HEAD           GREEN
export TARTIFY_COLOR_NOREMTRACK=${__B_}         # no remote tracking branch        BLUE

export TARTIFY_COLOR_DOTGIT=${__C_}             # inside .git dir                  CYAN

export TARTIFY_STRING_UNMERGED="✖ "             # there are unmerged files
export TARTIFY_COLOR_UNMERGED=${__BL_}${__EMR_} # unmerged files                   BOLD RED BLINKING
                                                #                                  (yeah, obnoxious)
# // REPOSITORY
export TARTIFY_COLOR_REPONAME=${__DM_}${__K_}   # repository's "name"              DIM GREY

# // REMOTES
export TARTIFY_STRING_ORIGIN="O"                # marker for remote repo called 'origin'
export TARTIFY_STRING_UPSTREAM="U"              # marker for remote repo called 'upstream'
export TARTIFY_STRING_REMOTE="⇧"                # generic marker for remote repo

export TARTIFY_STRING_TRACKING="➝"              # marker for tracked branch
export TARTIFY_COLOR_REMOTE_ORIGIN=${__G_}      # repository's "name"              GREEN
export TARTIFY_COLOR_REMOTE_UPSTREAM=${__M_}    # repository's "name"              MAGENTA
export TARTIFY_COLOR_REMOTE_OTHER=${__Y_}       # repository's "name"              YELLOW


export TARTIFY_COLOR_REMOTE_AHEAD=${__G_}       # nb commits ahead of remote       GREEN
export TARTIFY_COLOR_REMOTE_BEHIND=${__R_}      # nb commits behind of remote      RED


# // STASH
export TARTIFY_COUNTSTASHES=TRUE                # non empty: print 1 $TARTIFY_STRING_STASH per existing stash
                                                # (WARN: this is slow process, add ~50ms computing time)
export TARTIFY_STRING_STASH="☆"                 # marker for stash
export TARTIFY_COLOR_STASH_NOCOUNT=${__Y_}       # color when not counting          YELLOW
export TARTIFY_COLOR_STASH_COUNT=${__EMY_}       # color in "count mode"            BOLD YELLOW
}


#------------------------------------------------------------------------------
#
#             HELPER FUNCTIONS
#
#------------------------------------------------------------------------------
#
__tartify_diff_count() {
#count the nb of commits between two branches of two repositorie
#   ex: __tartify_diff_count HEAD origin/master
#   ex: __tartify_diff_count upstream/dev HEAD
    echo "$(git rev-list $1..$2 2>/dev/null | awk 'END {print NR}')"
}


__tartify_find_tracked(){
  local __branchname=$1
  # find (possible) tracked remote for current branch in repository
  for remotename in $(git remote show); do
    # CURRENT BRANCH is tracked to CURRENT REMOTE ?
    if [[ $(git config --get branch.$__branchname.remote) =~ $remotename ]]; then
        echo $remotename
    fi
  done
}


__tartify_usage(){
# Display the help message
  echo -e "
  ${__UN_}Description${__UNQ_} : One-Liner condensed GIT infos (for your prompt, screen
                statusline, ...)

  ${__UN_}Usage${__UNQ_} is : ${__EM_}tartify${__EMQ_} [${__Y_}options${__NN_}]

  ${__UN_}Options${__UNQ_} is : a CASE-SENSITIVE sequence of characters.

      * The following characters are reserved tartify commands :
         ${__Y_}nbrslcovh?e${__NN_}
      * any other character will be printed "as is", including spaces. You can use
        those to format the output of the tarttify command

          ex: \`tartify [r]b - l\` will output \"[repository]master - 12m\"
              if you need multiple spaces, escape them \"\ \" :
           \`tartify [r]b -\ \ l\` will output \"[repository]master -  12m\"


      ${__Y_}[Elements]${__NN_} ${__EM_}${__NN_}

      ${__Y_}n${__NN_}       repository ${__EMY_}N${__NN_}ame
      ${__Y_}b${__NN_}       ${__EMY_}B${__NN_}ranch name
      ${__Y_}r${__NN_}       ${__EMY_}R${__NN_}emotes info
      ${__Y_}s${__NN_}       ${__EMY_}S${__NN_}tash info
      ${__Y_}l${__NN_}       ${__EMY_}L${__NN_}ast commit info

      ${__Y_}w${__NN_}       ne${__EMY_}W${__NN_}line append newline

      ${__Y_}[Modes]${__NN_} ${__EM_}mutually exclusive (only first one counts)${__NN_}

      ${__Y_}c${__NN_}       no${__EMY_}C${__NN_}olor    strip all colors (whatever the result)
      ${__Y_}o${__NN_}       ${__EMY_}O${__NN_}ldschool  __git_ps1 mode
      ${__Y_}v${__NN_}       ${__EMY_}V${__NN_}im mode   result formated for the Vim tartify plugin
                         (color info appended to result)


      ${__Y_}[Help]${__NN_} ${__EM_}all other arguments are ignored${__NN_}

      ${__Y_}h|?${__NN_}     ${__EMY_}H${__NN_}elp      display this help message
      ${__Y_}e${__NN_}       ${__EMY_}E${__NN_}nv help  list customizable environment variables

  ${__UN_}Default${__UNQ_}   tartify   : is equivalent to ${__EM_}tartify${__EMQ_} ${__Y_}nbrsl${__NN_}
            tartify w : is equivalent to ${__EM_}tartify${__EMQ_} ${__Y_}nbrslw${__NN_}
            tartify o : is equivalent to ${__EM_}tartify${__EMQ_} ${__Y_}obsr${__NN_}


"
}


__tartify_get_sec_lastcommit() {
# get the unix timestamp for the lastest commit (seconds)
# copied from https://github.com/xtrementl/dev-bash-git-ps1.git
    local now="$(date +%s)"
    local last_commit="$(git log --format='%at' -1 2>/dev/null)"
    if [ -z "$last_commit" ]; then # probably initial git init, no commits
        return
    fi
    if [ 0 -lt "$now" ] && [ 0 -lt "$last_commit" ]; then
        echo "$((now - last_commit))"
    fi
}


__tartify_reformat_timestamp(){
# prints a relative-formatted time string from unix timestamp
# arg: unix timestamp in seconds
# optional arg: true to include coloring
# copied from https://github.com/xtrementl/dev-bash-git-ps1.git
    local secs="$1"
    local yrs="$(( $secs / 31557600 ))"
    local div="$(( $secs % 31557600 ))"
    local days="$(( div / 86400 ))"
    div="$(( $secs % 86400 ))"
    local hrs="$(( $div / 3600 ))"
    div="$(( $secs % 3600 ))"
    local mins="$(( $div / 60 ))"

    # create the formatted time string
    local timestr
    [ 0 -lt "$yrs" ] && timestr="${yrs}y"
    if [ 0 -lt "$days" ]; then
        [ -n "$timestr" ] && timestr="$timestr,"
        timestr="${days}d"
    fi
    if [ 0 -lt "$hrs" ]; then
        [ -n "$timestr" ] && timestr="$timestr,"
        timestr="${timestr}${hrs}h"
    fi
    [ -n "$timestr" ] && timestr="${timestr},"
    timestr="${timestr}${mins}m"

    # add a hint of color
    if [ -n "$2" ] && [ -n "$TARTIFY_TIME_BUGME" ]; then
        local color
        if [ $TARTIFY_TIME_SHOULDCOMMIT -lt "$secs" ]; then # 30 mins
            color=$TARTIFY_COLOR_TIME_SHOULDCOMMIT
        elif [ $TARTIFY_TIME_COULDCOMMIT -lt "$secs" ]; then # 10 mins
            color=$TARTIFY_COLOR_TIME_COULDCOMMIT
        else
            color=$TARTIFY_COLOR_TIME_APLENTY
        fi
        timestr="${color}${timestr}${__NN_}"
    fi
    echo "$timestr"
}

#------------------------------------------------------------------------------
#
#             GIT PS1 commands
#
#------------------------------------------------------------------------------
__tartify_repo_name()
{
  local nocolors=$1   #TRUE for no color
  local color
  local nocolor
  #? are we inside a GIT repo
  if git rev-parse --git-dir >/dev/null 2>&1
  then
    # Print the REPO's name
    color=$TARTIFY_COLOR_REPONAME
    nocolor=$(echo `cd $(git rev-parse --git-dir); cd ../;pwd` | sed 's,.*/,,' | tr -d '\n')
    color=$color$nocolor
    color=$color"/${__NN_}"
  fi
  [ $nocolors ] &&  echo -ne $nocolor || echo -ne $color
}


__tartify_branch()
{
  # OLDSCHOOL mode
  #
  #   * unstaged
  #   + staged
  #   % untracked
  #
  # VIM mode
  #
  #   $nocolor_infos prepended to branch name
  #
  #   nocolor_infos =~ /[U]?[SAONGBE][T]?[M]?/
  #
  #       [U]nstaged modif(s)
  #
  #       [S]taged modif(s),
  #       [A]head of remote     & nothing staged
  #       [O]K (remote == HEAD) & nothing staged
  #       [N]o tracked remote   & nothing staged
  #       inside .[G]it directory (branch info irrelevant)
  #       inside  [B]are repository (branch info irrelevant)
  #       [E]mpty repository (no branch)
  #
  #       un[T]racked files,
  #       un[M]erged files
  #

  local nocolors=$1     #TRUE for no color
  local mode=$2         #either VIM or OLDSCHOOL
  local color
  local color_base      # branch name base color
  local color_unstaged  # first 2 chars of branch name in case of unstaged modifs
  local style_untracked # special style in case of untracked files
  local nocolor
  local nocolor_infos   # store color infos in an easilly parseable string

  ##? GIT repo
  if git rev-parse --git-dir >/dev/null 2>&1
  then
    local gitdir_=`git rev-parse --git-dir`
    local remotelogentries
    local branchname=$(git branch 2>/dev/null| sed -n '/^\*/s/^\* //p')
    color=${__NN_}

    #? WORKING TREE
    if `git rev-parse --is-inside-work-tree`; then

      #? EMPTY repo
      if [ $(ls $gitdir_/refs/heads/ | wc -l) == 0 ]; then
        branchname=$TARTIFY_STRING_NOBRANCH
        color_base=$TARTIFY_COLOR_NOREMTRACK
        [[ "$mode" =~ VIM ]] && nocolor_infos="E"
        #[[ "$mode" =~ OLDSCHOOL ]] && nocolor_infos="E"
      fi

      # --------- WORKING DIR STATE--------
      #? UNSTAGED modifs
      if ! git diff --quiet >/dev/null 2>&1; then
        color_unstaged=$TARTIFY_COLOR_UNSTAGED
        [[ "$mode" =~ VIM ]] && nocolor_infos=$nocolor_infos"U"
        [[ "$mode" =~ OLDSCHOOL ]] && nocolor_infos=$nocolor_infos"*"
      fi

      # ---------- INDEX STATE-------------
      #? Empty INDEX
      if [ !  $(git diff  --cached | wc -l) -gt 0  ]; then
        # ASSUME tracked remote, uptodate with HEAD
        color_base=$TARTIFY_COLOR_UPTODATE
        [[ "$mode" =~ VIM ]] && nocolor_infos=$nocolor_infos"O"

        #? TRACKED Remote
        local hastrackedremote=`__tartify_find_tracked $branchname`
        if [ $hastrackedremote != "" ]; then
          #? branch's HEAD ahead of tracked remote's
          remotelogentries=$(git log origin/$branchname.. | wc -l )
          if [ $remotelogentries  -gt 0 ]; then
            color_base=$TARTIFY_COLOR_AHEADOFREMOTE
            [[ "$mode" =~ VIM ]] && nocolor_infos=$nocolor_infos"A"
          fi
        # NO TRACKED remote
        else
          color_base=$TARTIFY_COLOR_NOREMTRACK
          [[ "$mode" =~ VIM ]] && nocolor_infos=$nocolor_infos"N"
        fi

      # NON-Empty INDEX
      else
        color_base=$TARTIFY_COLOR_STAGED
        [[ "$mode" =~ VIM ]] && nocolor_infos=$nocolor_infos"S"
        [[ "$mode" =~ OLDSCHOOL ]] && nocolor_infos=$nocolor_infos"+"
      fi


      # ---------- UNMERGED FILES -------------
      if [ $(git ls-files -u | wc -l ) -gt 0 ]
      then
        color=$TARTIFY_COLOR_UNMERGED$TARTIFY_STRING_UNMERGED$color
        nocolor=$TARTIFY_STRING_UNMERGED
        [[ "$mode" =~ VIM ]] && nocolor_infos=$nocolor_infos"M"
        #[[ "$mode" =~ OLDSCHOOL ]] && nocolor_infos=$nocolor_infos"M"
      fi



      # UNTRACKED FILES
      if [ -n "$(git ls-files --others --exclude-standard)" ]; then
        style_untracked=$TARTIFY_STYLE_UNTRACKED
        [[ "$mode" =~ VIM ]] && nocolor_infos=$nocolor_infos"T"
        [[ "$mode" =~ OLDSCHOOL ]] && nocolor_infos=$nocolor_infos"%"
      fi


    # SPECIAL_CASE: we're inside the .git dir
    else
			# BARE repo
			if [ "true" = "$(git rev-parse --is-bare-repository 2>/dev/null)" ]; then
        branchname=$TARTIFY_STRING_BARE
        [[ "$mode" =~ VIM ]] && nocolor_infos="B"
      # Non-BARE repo
      else
        branchname=$TARTIFY_STRING_DOTGIT
        [[ "$mode" =~ VIM ]] && nocolor_infos="G"
      fi
      color_base=$TARTIFY_COLOR_DOTGIT
    fi

    # Highlight the first two characters of branch name with $color_unstaged
    # (if nonempty)
    [[ $color_unstaged == "" ]] && color_unstaged=$color_base
    local __first2=$color_unstaged$style_untracked${branchname:0:2}
    local __remain=$color_base$style_untracked${branchname:2:${#branchname}}
    color=$color$__first2$__remain$__NN_
    #color=$color$color_base$style_untracked$branchname$__NN_
    nocolor=$nocolor$branchname

  else
    return 0
  fi

  [ $nocolors ] &&  {
    if [[ "$mode" =~ VIM ]]; then
      echo -ne $nocolor_infos"|"$nocolor
    elif [[ "$mode" =~ OLDSCHOOL ]]; then
      echo -ne $nocolor$nocolor_infos
    else
      echo -ne $nocolor
    fi
  } || {
    echo -e $color
    #echo ${argstr:0:2}; echo ${argstr:2:${#argstr}}

  }
}


__tartify_remote()
{
  # OLDSCHOOL :
  #
  #    #:no upstream

  local nocolors=$1   #TRUE for no color
  local color
  local nocolor
  #? are we inside a GIT repo
  if git rev-parse --git-dir >/dev/null 2>&1
  then
    local gitdir_=`git rev-parse --git-dir`
    local branchname=$(git branch 2>/dev/null| sed -n '/^\*/s/^\* //p')
    color="  "$__NN_

    # NON-EMPTY GIT REPO
    # VERIFY that .git/refs/heads/ directory is not empty
    if [ $(ls $gitdir_/refs/heads/ | wc -l) -gt 0 ]
    then

      # ------- REMOTES INFO ( + BRANCH TRACKED ) --------
      local marker
      local marker_color
      local before_traked
      local after_tracked
      local before_untraked
      local after_untracked

      # loop through remotes
      for remotename in $(git remote show); do

        # special markers for origin and upstream
        # nb: a tracked remote is preceded by a little ➝ symbol
        case $remotename in
            origin)   marker="O"; marker_color=$TARTIFY_COLOR_REMOTE_ORIGIN   ;;
          upstream)   marker="U"; marker_color=$TARTIFY_COLOR_REMOTE_UPSTREAM ;;
                 *)   marker="⇧"; marker_color=$TARTIFY_COLOR_REMOTE_OTHER    ;;
        esac

        # CURRENT BRANCH is tracked to CURRENT REMOTE ?
        if [[ $(git config --get branch.$branchname.remote) =~ $remotename ]]
        then
          [ $nocolors ]  &&  { before_traked=" ➝ "; after_tracked="";
                                before_untraked=" "; after_untracked=""; } ||
                              { before_traked=" ➝${__EM_} "; after_tracked="${_EMQ_}";
                                before_untraked=" "; after_untracked=""; }
        else
          before_traked=""; after_tracked="";before_traked=" "; after_tracked="";
        fi


        # nb of commits AHEAD/BEHIND
        local ahead_count="$(__tartify_diff_count $remotename/$branchname HEAD)"
        local behind_count="$(__tartify_diff_count HEAD $remotename/$branchname)"
        local diffcount=""
        local diffcountnocol=""
        if [ 0 -lt "$ahead_count" ]; then
            diffcount="${TARTIFY_COLOR_REMOTE_AHEAD}${ahead_count}"
            diffcountnocol="+${ahead_count}"
        fi

        if [ 0 -lt "$behind_count" ]; then
            [ -n "$diffcount" ] && {
                    diffcount="${diffcount}${marker_color}/"
                    diffcountnocol="${diffcountnocol}/"
                  }
            diffcount="${diffcount}${TARTIFY_COLOR_REMOTE_BEHIND}${behind_count}"
            diffcountnocol="${diffcountnocol}-${behind_count}"
        fi

        [ -n "$diffcount" ] && diffcount=" ${marker_color}($diffcount${marker_color}) "
        [ -n "$diffcountnocol" ] && diffcountnocol=" ($diffcountnocol) "
        #echo "$diffcount"


        color=$color"${marker_color}${before_traked}${marker}${after_tracked}${diffcount}${__NN_}"
        nocolor=$nocolor"${before_traked}${marker}${after_tracked}${diffcountnocol}"

      done
    fi
  else
    return 0
  fi
  [ $nocolors ] &&  echo -ne $nocolor || echo -e $color
}


#optimized
__tartify_stash()
{
  local nocolors=$1   #TRUE for no color
  local color
  local nocolor
  #? are we inside a GIT repo
  if git rev-parse --git-dir >/dev/null 2>&1; then
    #? are we inside a GIT repo's working tree
    if `git rev-parse --is-inside-work-tree`; then

      git rev-parse --verify refs/stash >/dev/null 2>&1 && {
        if [ -n "$TARTIFY_COUNTSTASHES" ]; then
          # One star per stash
          color=$TARTIFY_COLOR_STASH_COUNT
          nocolor="  "
          #! `git stash list | wc -l` adds about 50ms
          for (( i=0; i< $(git stash list | wc -l); i++ ))
          do
            nocolor=$nocolor$TARTIFY_STRING_STASH" "
          done
          nocolor=$nocolor" "
        else
          color=$TARTIFY_COLOR_STASH_NOCOUNT
          nocolor=$TARTIFY_STRING_STASH
        fi
        color=$color$nocolor${__NN_}

        [[ "$mode" =~ OLDSCHOOL ]] && nocolor="$"
      }
    fi
  fi
  [ $nocolors ] &&  echo -ne $nocolor || echo -e $color
}


__tartify_timelastcommit(){
  # calc relative time diff of last commit
  local secs="$(__tartify_get_sec_lastcommit)"
  [ -n "$secs" ] && echo -e "$(__tartify_reformat_timestamp $secs true)"
}

#------------------------------------------------------------------------------
#
#             TARTIFY
#
#------------------------------------------------------------------------------

tartify()
{
  #DEPRECATED : we are case sensitive now
  ## To Lower Case
  #local argstr=`echo $1 | tr '[A-Z]' '[a-z]'`

  local argstr=$1

  # Help
  [[ "$argstr" =~ ? || "$argstr" =~ h ]] && { __tartify_usage; return 0; }
  [[ "$argstr" =~ e ]] && {
    echo -ne "\nTartify's ENVIRONMENT variables are currently set to :"
    __TART_env=`env | grep "^TARTIFY_" |   sed 's/\(\\033\[\([0-9];\)*[0-9]*m\)\{1,2\}/&##########\\\\033\[0m/g' | sed 's/$/\\\\n/g' | sort -df `
    echo -ne "\n\n "$__TART_env | awk -F"=" '{printf("%-'35s' %'0s'\n", $1,$2)}'
    return 0
  }
  # Empty arg (default)
  [ ${#argstr} == 0 ] && argstr="nbrsl"

  [[ "${argstr}" == "w" ]] && argstr="nbrslw"
  [ ${#argstr} == 0 ] && argstr="nbrsl"

  local separator=" "
  local nocolor
  local mode
  # No Colors MODE : strip all color info, whatever the result
  [[ "$argstr" =~ v ]] && {
      nocolor=TRUE
  }
  # Vim MODE : no color, prepend color infos for 'branch', use '#' as separator
  [[ "$argstr" =~ v ]] && {
      separator="#"
      nocolor=TRUE
      mode="VIM"
  }
  # OldSchool MODE : no color, branch results with $*+, stash results with %
  [[ "$argstr" =~ o ]] && {
      # tartify o == tartify bsr
      [ ${#argstr} == 1 ] && argstr="bsr"

      separator=" "
      nocolor=TRUE
      mode="OLDSCHOOL"
  }

  local tartAnswer=""
  local i
  for ((i=0;i<${#argstr};i++))
  do
    local ch=${argstr:$i:1}
    case $ch in
      n) tartAnswer=$tartAnswer$separator$(__tartify_repo_name $nocolor);;
      b) tartAnswer=$tartAnswer$separator$(__tartify_branch $nocolor $mode);;
      r) tartAnswer=$tartAnswer$separator$(__tartify_remote $nocolor);;
      s) tartAnswer=$tartAnswer$separator$(__tartify_stash $nocolor);;
      l) tartAnswer=$tartAnswer$separator$(__tartify_timelastcommit $nocolor);;
      c) ;;
      o) ;;
      v) ;;
      w) ;;
      *) echo "Unknown option \"$ch\""; __tartify_usage; return 1 ;;
    esac
  done

  #echo -e "$(__tartify_repo_name)$(__tartify_branch)  $(__tartify_remote) $(__tartify_stash)"

  #newline (for use in PS1)
  #[[ "$argstr" =~ w ]] && echo -ne $tartAnswer"\\n" || echo -ne $tartAnswer
  [[ "$argstr" =~ w ]] && printf "%s\n" $tartAnswer || printf "%s" $tartAnswer

}

# enable whitespace, any non command character is a separator
#tartify2()
#{
#}

#------------------------------------------------------------------------------
#
#             EXPORTING (for use in other things : Vim,...)
#
#------------------------------------------------------------------------------
__tartify_define_colors
__tartify_init_globs

export -f __tartify_diff_count
export -f __tartify_find_tracked
export -f __tartify_usage
export -f __tartify_get_sec_lastcommit
export -f __tartify_reformat_timestamp

export -f __tartify_repo_name
export -f __tartify_branch
export -f __tartify_remote
export -f __tartify_stash
export -f __tartify_timelastcommit

export -f tartify
export __tartify_shell_loaded=1








#!/bin/bash
##################################################################################
#
#       Filename:  tartify
#
#    Description:  BASH PS1 with GIT support
#
#                  Colored command prompt adapted to GIT repository. VERY
#                  colorfull, not for the faint hearted
#
#  Configuration:  place this file somewhere in your PATH and source it in your
#                  .bashrc
#
#                     source /path/to/bashps1
#
#   Dependencies:  Depends on GIT, might work on windows with Cygwin
#
#   GVIM Version:  1.7+ (?)
#
#         Author:  Pierre Lhoste
#        Twitter:  http://twitter.com/peterhost
#
#        Version:  0.1
#        Created:  01.05.2011
#        License:  WTFPL V2
#
# DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE Version 2, December 2004
#
# Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>
#
# Everyone is permitted to copy and distribute verbatim or modified
# copies of this license document, and changing it is allowed as long as
# the name is changed.
#
#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE TERMS AND
#            CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
#
#  0. You just DO WHAT THE FUCK YOU WANT TO.
#
#------------------------------------------------------------------------------
#

# USAGE : Just call the tartify() function from the command line
#
#         PROMPT integration : call tartify() inside your $PS1. Examples:
#
#           PS1="\$(tartify) [\u@\h]\$ "
#           PS1="\$(tartify)\n[\u@\h]\$ "
#           ...
#
#         You can also pass arguments to tartify() to make it display only
#         certain informations
#
#           tartify -h
#
#

#PS1="${__PS1NN_}${__PS1EMK_}[${__PS1UC_}\u${__PS1EMK_}@${__PS1EMUC_}\h ${__PS1C_}\${NEW_PWD}${__PS1EMK_}] \$"
#PROMPT_COMMAND=tartify
#
#
#
#------------------------------------------------------------------------------
#
# ISSUE :
#
#   * no support for SVN upstream (as I don't use SVN), feel free to augment
#     this script
#
#

#   * conditionnal newline : there is no such thing in a prompt. Either a
#   newline is hardcoded in the prompt, or it's not. All linebreak(s) inserted
#   by an external command called in the PS1 variable via "$(command)" are
#   stripped out when $PS1 is evaluated.
#
#   Solution: if you need a multiline prompt, with the 'tartify' line only
#   inserted if you're being in a 'git' repository, consider using a
#   PROMPT_COMMAND like this :
#
#     prompt_command(){
#       ...
#       tartify w
#     }
#     PROMPT_COMMAND=prompt_command
#
#   The 'w' option to tartify issues a newline if the contents of \`tartify\`
#   is not an empty string.
#
#   * Line Wrapping Calculation
#
#     The one thing (that I know of) which confuse line wrapping (when browsing
#     command history with long lines, for ex) is non-printable characters
#     (such as ansi escape color codes, cursor movement,...). So:
#
#       1 - non-printable characters in the PS1 variable have to be "escaped"
#       by enclosing them between a pair of escaped brackets :
#
#           \[\033[0;30m\]   instead of  \033[0;30m
#
#       And this has to be done at PS1 definition-time, as PS1 is only assigned
#       ONCE but evaluated at EACH PROMPT.
#
#       2 - function calls inside the PS1 variable that issue non-printable
#       characters will confuse the prompt, naturally, if the said n-p-chars
#       are not escaped IN the PS1 variable itself at assignement time. Example :
#
#               PS1=">"
#               > pwd
#               /some/dir
#               > myfunc(){ echo  "\[\033[0;30m\]\$(pwd) > \[\033[0m\]"; }
#               > myfunc
#               \[\033[0;30m\]$(pwd) > \[\033[0m\]
#
#           this will work
#               > PS1=$(myfunc)
#               /some/dir > echo $PS1
#               \[\033[0;30m\]$(pwd) > \[\033[0m\]
#               /some/dir > cd tmp
#               /some/dir/tmp >
#
#            this won't:
#               /some/dir/tmp > PS1='$(myfunc)'
#               \[\]stevejobs~ echo $PS1
#               $(myfunc)

#            As you can see in the latter, there are no escaped ansi codes
#            whatsoever, just a function call.  the prompt will print
#            litterally '\[\033[0;30m\]' each time, as this escaped substring
#            was not hardcoded in the PS1 variable at the time when it was
#            assigned, but generated by a function call evaluated for each
#            prompt, INSIDE the PS1 variable

#       MORE: on the subject
#       http://www.issociate.de/board/post/481503/bash_command_substitution,_functions_and_quoting_:_need_help.html
#
#     Problem is : if a function used in the PS1 variable is to adapt it's colored
#                  output according to context, there is no way to hardcode that
#                  directly in $PS1 with the '\[' escapes.
#
#       -> better use `printf` rather than `echo` (which somewhat sucks and which
#       behaviour is inconsistant across shells and OSes)
#
#       OR...
#       -> need to be issued on a line prior to the last line of the prompt, with :
#           * either \n insertion,
#
#               PS1="\$(tartify)\n$ "
#
#           * or use of the PROMPT_COMMAND environment variable
#
#               __somefunc() {
#                 ...
#                 tartify
#                 ...
#               }
#               export PROMPT_COMMAND=__somefunc
#               PS1=...
#
#       otherwise they will confuse wrapping too. Hence, your PS1 better look
#       something like :
#
#
#
#       (SEE:http://hintsforums.macworld.com/archive/index.php/t-17068.html)
#
#    * Quick n dirty benchmark
#      loop over 1000 executions of `tartify` on a 3.06GHz Intel Core 2 Duo Imac
#      without any further methodology
#
#       **execution-time (ms)**
#       _____________________________________________________________
#      |    REPO   | TINY       | SMALL     | MEDIUM    | LARGE      |
#      |           | ms   %     | ms   %    | ms   %    | ms   %     |
#      |___________|____________|___________|___________|____________|
#      |    remote | 48   25%   | 59   29%  | 92   27%  | 93  23%    |
#      |   1 stash | 56   30%   | 56   28%  | 179  52%  | 202 50%    |
#      |    branch | 60   32%   | 63   31%  | 46   13%  | 81  20%    |
#      |      repo | 14    7%   | 13    6%  | 13    4%  | 14   3%    |
#      |  timelast | 11    6%   | 11    5%  | 12    3%  | 12   3%    |
#      |           |            |           |           |            |
#      |     total | 189        | 202       | 342       | 402        |
#      |           |            |           |           |            |
#      | __git_ps1 |            |           |           | 63         |
#      | __git_ps1 |            |           |           |            |
#      |shwupstream|            |           | 21        | 26         |
#      |___________|____________|___________|___________|____________|
#
#
#------------------------------------------------------------------------------
#
# NOTA :
#          Special Character Codes
#          \a – an ASCII bell character (07)
#          \d – the date in “Weekday Month Date” format (e.g., “Tue May 26″)
#          \D{format} – the format is passed to strftime(3) and the result is inserted into the prompt string; an empty format results in a locale-specific time representation. The braces are required
#          \e – an ASCII escape character (033)  (hence : \e and \033 are equivalent)
#          \h – the hostname up to the first `.’
#          \H – the hostname
#          \j – the number of jobs currently managed by the shell
#          \l – the basename of the shell’s terminal device name
#          \n – newline
#          \r – carriage return
#          \s – the name of the shell, the basename of $0 (the portion following the final slash)
#          \t – the current time in 24-hour HH:MM:SS format
#          \T – the current time in 12-hour HH:MM:SS format
#          \@ – the current time in 12-hour am/pm format
#          \A – the current time in 24-hour HH:MM format
#          \u – the username of the current user
#          \v – the version of bash (e.g., 2.00)
#          \V – the release of bash, version + patchelvel (e.g., 2.00.0)
#          \w – the current working directory
#          \W – the basename of the current working directory
#          \! – the history number of this command
#          \# – the command number of this command
#          \$ – if the effective UID is 0, a #, otherwise a $
#          \nnn – the character corresponding to the octal number nnn
#          \\ – a backslash
#          \[ - begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt
#          \] – end a sequence of non-printing characters
#
#          (http://www.wiredrevolution.com/bash-programming/customize-the-bash-ps1-command-prompt)



#------------------------------------------------------------------------------
#
#             PRELIMINARY CHECKS
#
#------------------------------------------------------------------------------
# store command line params
__tartify_args="$*"

# Are we being sourced or executed ?
Prog="tartify"
__tartify_whocalled=
if [ "$(basename $0 2>/dev/null )" = "$Prog" ]; then
  __tartify_whocalled="exec"
else
  __tartify_whocalled="source"
fi



#------------------------------------------------------------------------------
#
#             SHELL DETECTION
#
#------------------------------------------------------------------------------

## SHELL detection
## SHELL      DARWIN      LINUX
## sh         path/to/sh  sh
## csh        -sh         -sh
## tcsh       -csh        -csh
## ksh        ksh         ksh
## bash       -bash       bash
## zsh        zsh         zsh

#__thisShell=`ps $$ | grep $$ | awk '{ print $5 }' | sed 's/\-/\\\-/g'`
#echo $__thisShell
#__thisShell=$(basename $__thisShell)
#echo $__thisShell
## Darwin detection
#if uname -s | grep "Darwin" >/dev/null 2>&1
#then
#  __OSflavor="Darwin" # macos
#fi

## BAIL if using SH on OSX, (scrambles "echo -ne" commands)
#[ "$__OSflavor" = "Darwin" ] && [ "$__thisShell" = "sh" ] && { echo " SH detected, exit";  exit 1; }

#------------------------------------------------------------------------------
#
#             MISC GLOBAL VARIABLES
#
#------------------------------------------------------------------------------


__tartify_define_colors_TPUT() {
# COLOR VARS :  * declare those color codes ONCE and for ALL.
#                 This somewhat pollutes the GLOBAL SCOPE but the variable names
#                 are (thought to be) unique enough so that won't cause problems
#
#               * do that like a grownup (tput, not ANSI escapes)
#

                                                              #   ANSI equivalent
                                                              #  <attr> <fg>  <bg>
  # ALL
   __NN_=$( tput sgr0   || : 2>/dev/null )                    # [ 0m                RESET ALL attributes

  # STYLES
  # <BEGIN>
   __EM_=$( tput bold    || : 2>/dev/null )                   # [ 1m                BEGIN DOUBLE INTENSITY (bold) mode
   __DM_=$( tput dim     || : 2>/dev/null )                   # [ 2m                BEGIN HALF INTENSITY    (dim) mode
   __UN_=$( tput smul    || : 2>/dev/null )                   # [ 4m                BEGIN UNDESCORE  (underlined) mode
   __BL_=$( tput blink   || : 2>/dev/null )                   # [ 5m                BEGIN BLINKING                mode
   __RV_=$( tput rev     || : 2>/dev/null )                   # [ 7m                BEGIN REVERSE VIDEO (reverse) mode
   __SO_=$( tput smso    || : 2>/dev/null )                   #?[ 7m                BEGIN STANDOUT      (reverse) mode
  # <END>
  __SOQ_=$( tput rmso    || : 2>/dev/null )                   #?[ 27m               END   STANDOUT      (reverse) mode
  __UNQ_=$( tput rmul    || : 2>/dev/null )                   # [ 24m               END   UNDESCORE  (underlined) mode
  # for all other END style, use `tput sgr0` ($__NN_)

  # COLORS
  # <Foreground>
    __K_=$( tput setf 0 || tput setaf 0 || : 2>/dev/null )    # [       0m          SET   FG color to BLACK
    __R_=$( tput setf 4 || tput setaf 1 || : 2>/dev/null )    # [       1m          SET   FG color to RED
    __G_=$( tput setf 2 || tput setaf 2 || : 2>/dev/null )    # [       2m          SET   FG color to GREEN
    __Y_=$( tput setf 6 || tput setaf 3 || : 2>/dev/null )    # [       3m          SET   FG color to YELLOW
    __B_=$( tput setf 1 || tput setaf 4 || : 2>/dev/null )    # [       4m          SET   FG color to BLUE
    __M_=$( tput setf 5 || tput setaf 5 || : 2>/dev/null )    # [       5m          SET   FG color to MAGENTA
    __C_=$( tput setf 3 || tput setaf 6 || : 2>/dev/null )    # [       6m          SET   FG color to CYAN
    __W_=$( tput setf 7 || tput setaf 7 || : 2>/dev/null )    # [       7m          SET   FG color to WHITE
  # <Background>
  __BGK_=$( tput setb 0 || tput setab 0 || : 2>/dev/null )    # [       0m          SET   BG color to BLACK
  __BGR_=$( tput setb 4 || tput setab 1 || : 2>/dev/null )    # [       1m          SET   BG color to RED
  __BGG_=$( tput setb 2 || tput setab 2 || : 2>/dev/null )    # [       2m          SET   BG color to GREEN
  __BGY_=$( tput setb 6 || tput setab 3 || : 2>/dev/null )    # [       3m          SET   BG color to YELLOW
  __BGB_=$( tput setb 1 || tput setab 4 || : 2>/dev/null )    # [       4m          SET   BG color to BLUE
  __BGM_=$( tput setb 5 || tput setab 5 || : 2>/dev/null )    # [       5m          SET   BG color to MAGENTA
  __BGC_=$( tput setb 3 || tput setab 6 || : 2>/dev/null )    # [       6m          SET   BG color to CYAN
  __BGW_=$( tput setb 7 || tput setab 7 || : 2>/dev/null )    # [       7m          SET   BG color to WHITE
  # <reset>
   __NF_=$( tput setf 9 || tput setaf 9 || : 2>/dev/null )    # [       39m         RESET FG color to term's default
   __NG_=$( tput setb 9 || tput setab 9 || : 2>/dev/null )    # [             49m   RESET BG color to term's default
  __NFG_=$__NF_$__NB_                                         # [       39;   49m   RESET FG & BG color to term's default
  # <pseudo Foreground-bold>
  __EMK_=$__EM_$__K_                                          # [ 1;    20m         SET   FG color to BOLD BLACK
  __EMR_=$__EM_$__R_                                          # [ 1;    21m         SET   FG color to BOLD RED
  __EMG_=$__EM_$__G_                                          # [ 1;    22m         SET   FG color to BOLD GREEN
  __EMY_=$__EM_$__Y_                                          # [ 1;    23m         SET   FG color to BOLD YELLOW
  __EMB_=$__EM_$__B_                                          # [ 1;    24m         SET   FG color to BOLD BLUE
  __EMM_=$__EM_$__M_                                          # [ 1;    25m         SET   FG color to BOLD MAGENTA
  __EMC_=$__EM_$__C_                                          # [ 1;    26m         SET   FG color to BOLD CYAN
  __EMW_=$__EM_$__W_                                          # [ 1;    27m         SET   FG color to BOLD RED
}

__tartify_init_globs(){
# TARTIFY PARAMETERS : adapt to your needs


# // OVERWRITE
#TODO: TARTIFY_IGNORE_GITPS1_VARS

export TARTIFY_FORCE=""                          # a string containing tartify command-line params. If non empty, will
                                                 # overwrite any arguments the tartify command receives

export TARTIFY_SVN_SUPPORT=""                    # non-empty to have support for git-svn remotes

# // TIME
export TARTIFY_TIME_BUGME=TRUE                   # non empty : will color and style the 'time since last commit' string
export TARTIFY_TIME_DISPLAY=LONG                 # LONG (min, hours, days) SHORT (mine | hours | days) CHAR (cf. next var)
export TARTIFY_STRING_TIME_DISPLAY="⟳ "               # string to display in case prec. var == CHAR

                                                 # Uncommited changes (staged, unstaged)
export TARTIFY_TIME_COULDCOMMIT=3600             #     *     nb seconds after which you COULD  commit
export TARTIFY_TIME_SHOULDCOMMIT=86400           #     * Max nb seconds after which you SHOULD commit
                                                 # (default is 86400, 24hours)


                                                 # colors applied to the 'time elapsed since last commit'
                                                 # string, in case of uncommited changes
export TARTIFY_STYLE_TIME_COULDCOMMIT=${__UN_}   #                                  UNDERLINED
export TARTIFY_STYLE_TIME_SHOULDCOMMIT=${__EM_}${__UN_} #                           BOLD UNDERLINED

                                                 # styles applied to the 'time elapsed since last commit'
                                                 # string in case of no uncommited changes
export TARTIFY_COLOR_TIME_ACTIVITY_HIGH=${__G_}  #                                  GREEN
export TARTIFY_COLOR_TIME_ACTIVITY_LOW=${__Y_}   #                                  YELLOW
export TARTIFY_COLOR_TIME_ACTIVITY_NON=${__R_}   #                                  RED

# //BRANCH
#DEPREC:
#export TARTIFY_STRING_NOBRANCH="nobranch"        # "branch name" replacement string for empty repository
export TARTIFY_STRING_DOTGIT="GIT_DIR!"          # "branch name" replacement string for .git directory
export TARTIFY_STRING_BARE="<BARE>"              # "branch name" replacement string for bare .git directory

export TARTIFY_STYLE_UNTRACKED=${__UN_}          # Untracked Files                  UNDERLINED

export TARTIFY_COLOR_UNSTAGED=${__EMR_}          # unstaged changes (first 2 chars) BOLD RED
export TARTIFY_COLOR_STAGED=${__M_}              # staged changes                   MAGENTA
export TARTIFY_COLOR_AHEADOFREMOTE=${__Y_}       # tracked remote behind HEAD       YELLOW
export TARTIFY_COLOR_UPTODATE=${__G_}            # tracked remote == HEAD           GREEN
export TARTIFY_COLOR_NOREMTRACK=${__B_}          # no remote tracking branch        BLUE
export TARTIFY_COLOR_NOCOMMITYET=${__EMK_}       # empty repo, no commit yet        BOLD DIM GREY

export TARTIFY_COLOR_GITDIR=${__C_}              # inside .git dir                  CYAN
export TARTIFY_COLOR_EMPTY=${__C_}               # empty repo (no commit yet)       CYAN
export TARTIFY_COLOR_MERGE_REBASE_CHERRY_BISECT=${__EMR_}  # color for the merge/rebase/cherry-pick/bisect status of current branch (if any)
                                                 #                                  BOLD RED

                                                 #                                  (yeah, obnoxious)
# // REPOSITORY
export TARTIFY_COLOR_REPONAME=${__K_}    # repository's "name"              DIM GREY

# // REMOTES
export TARTIFY_STRING_ORIGIN="O"                 # marker for remote repo called 'origin'
export TARTIFY_STRING_UPSTREAM="U"               # marker for remote repo called 'upstream'
export TARTIFY_STRING_REMOTE="⇧ "                # generic marker for remote repo
export TARTIFY_STRING_DIVERGE_SEP="/"            # separator for ahead/behind count

export TARTIFY_STRING_TRACKING="➝ "              # marker for tracked branch
export TARTIFY_COLOR_REMOTE_ORIGIN=${__G_}       # repository's "name"              GREEN
export TARTIFY_COLOR_REMOTE_UPSTREAM=${__M_}     # repository's "name"              MAGENTA
export TARTIFY_COLOR_REMOTE_OTHER=${__Y_}        # repository's "name"              YELLOW


export TARTIFY_COLOR_REMOTE_AHEAD=${__G_}        # nb commits ahead of remote       GREEN
export TARTIFY_COLOR_REMOTE_BEHIND=${__R_}       # nb commits behind of remote      RED


# // STASH
export TARTIFY_COUNTSTASHES=TRUE                 # non empty: print 1 $TARTIFY_STRING_STASH per existing stash
                                                 # (WARN: this is slow process, add ~50ms computing time)
export TARTIFY_STRING_STASH="☆ "                 # marker for stash
export TARTIFY_STRING_STASH="•"                 # marker for stash
export TARTIFY_COLOR_STASH_NOCOUNT=${__Y_}       # color when not counting          YELLOW
export TARTIFY_COLOR_STASH_COUNT=${__EMY_}       # color in "count mode"            BOLD YELLOW

# // UNPARSED CHARS
export TARTIFY_COLOR_DELIMITER=${__K_}   # color for (unparsed) delimiters  DIM GREY


# TODO: (restrict that to OLDSCHOOL)
# The usual environment variables from git-completion.bash still apply
# in "OLDSCHOOL" mode
#
#     GIT_PS1_SHOWDIRTYSTATE
#     GIT_PS1_SHOWSTASHSTATE
#     GIT_PS1_SHOWUNTRACKEDFILES
#     GIT_PS1_SHOWUPSTREAM
}


#------------------------------------------------------------------------------
#
#             __git_ps1 FUNCTIONS (tuned to tartify)
#
#------------------------------------------------------------------------------
#
# following functions are copy/paste of the original functions from
# bash-completion.sh, slightly tuned for tartify. No need to rewrite
# them, they are the most optimized way of doing it.
#
# Modifications :
#
# * local declarations removed ( the tartify() function is the root of our
#   local scope)
#
#


__tartify_git_ps1(){
	#local g="$(__gitdir)"
	if [ -n "$g" ]; then
		#local r=""
		#local b=""
		if [ -f "$g/rebase-merge/interactive" ]; then
			r="|REBASE-i"
			b="$(cat "$g/rebase-merge/head-name")"
		elif [ -d "$g/rebase-merge" ]; then
			r="|REBASE-m"
			b="$(cat "$g/rebase-merge/head-name")"
		else
			if [ -d "$g/rebase-apply" ]; then
				if [ -f "$g/rebase-apply/rebasing" ]; then
					r="|REBASE"
				elif [ -f "$g/rebase-apply/applying" ]; then
					r="|AM"
				else
					r="|AM/REBASE"
				fi
			elif [ -f "$g/MERGE_HEAD" ]; then
				r="|MERGING"
			elif [ -f "$g/CHERRY_PICK_HEAD" ]; then
				r="|CHERRY-PICKING"
			elif [ -f "$g/BISECT_LOG" ]; then
				r="|BISECTING"
			fi

			b="$(git symbolic-ref HEAD 2>/dev/null)" || {

				b="$(
				case "${GIT_PS1_DESCRIBE_STYLE-}" in
				(contains)
					git describe --contains HEAD ;;
				(branch)
					git describe --contains --all HEAD ;;
				(describe)
					git describe HEAD ;;
				(* | default)
					git describe --tags --exact-match HEAD ;;
				esac 2>/dev/null)" ||

				b="$(cut -c1-7 "$g/HEAD" 2>/dev/null)..." ||
				b="unknown"
				b="($b)"
			}
		fi

		#local w=""
		#local i=""
		#local s=""
		#local u=""
		#local c=""
		#local p=""

		if [ "true" = "$(git rev-parse --is-inside-git-dir 2>/dev/null)" ]; then
			if [ "true" = "$(git rev-parse --is-bare-repository 2>/dev/null)" ]; then
				c="BARE:"
			else
				b="GIT_DIR!"
			fi
		elif [ "true" = "$(git rev-parse --is-inside-work-tree 2>/dev/null)" ]; then
			if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] && [ "OLDSCHOOL" = "$mode" ]; then
				if [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
					git diff --no-ext-diff --quiet --exit-code || w="*"
					if git rev-parse --quiet --verify HEAD >/dev/null; then
						git diff-index --cached --quiet HEAD -- || i="+"
					else
						i="#"
					fi
				fi
			fi
			if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ] && [ "OLDSCHOOL" = "$mode" ]; then
			        git rev-parse --verify refs/stash >/dev/null 2>&1 && s="$"
			fi

			if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] && [ "OLDSCHOOL" = "$mode" ]; then
			   if [ -n "$(git ls-files --others --exclude-standard)" ]; then
			      u="%"
			   fi
			fi

			if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ] && [ "OLDSCHOOL" = "$mode" ]; then
				__tartify__git_ps1_show_upstream
			fi
			if [ "OLDSCHOOL" != $mode ] && [ "true" = "$processupstream" ]; then
				__tartify__git_ps1_show_upstream
			fi
		fi

		f="$w$i$s$u"
		#local f="$w$i$s$u"
		#printf "${1:- (%s)}" "$c${b##refs/heads/}${f:+ $f}$r$p"
	fi

}


__tartify__git_ps1_show_upstream ()
{
#GIT_PS1_SHOWDIRTYSTATE GIT_PS1_SHOWSTASHSTATE GIT_PS1_SHOWUNTRACKEDFILES GIT_PS1_SHOWUPSTREAM
	local key value
	local svn_remote=() svn_url_pattern count n
	local upstream=git legacy="" verbose=""

	# get some config options from git-config
	while read key value; do
		case "$key" in
		bash.showupstream)
			GIT_PS1_SHOWUPSTREAM="$value"
			if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]]; then
				p=""
				return
			fi
			;;
		svn-remote.*.url)
			svn_remote[ $((${#svn_remote[@]} + 1)) ]="$value"
			svn_url_pattern+="\\|$value"
			upstream=svn+git # default upstream is SVN if available, else git
			;;
		esac
	done < <(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')

	# parse configuration values
	for option in ${GIT_PS1_SHOWUPSTREAM}; do
		case "$option" in
		git|svn) upstream="$option" ;;
		verbose) verbose=1 ;;
		legacy)  legacy=1  ;;
		esac
	done

	# Find our upstream
	case "$upstream" in
	git)    upstream="@{upstream}" ;;
	svn*)
		# get the upstream from the "git-svn-id: ..." in a commit message
		# (git-svn uses essentially the same procedure internally)
		local svn_upstream=($(git log --first-parent -1 \
					--grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null))
		if [[ 0 -ne ${#svn_upstream[@]} ]]; then
			svn_upstream=${svn_upstream[ ${#svn_upstream[@]} - 2 ]}
			svn_upstream=${svn_upstream%@*}
			local n_stop="${#svn_remote[@]}"
			for ((n=1; n <= n_stop; ++n)); do
				svn_upstream=${svn_upstream#${svn_remote[$n]}}
			done

			if [[ -z "$svn_upstream" ]]; then
				# default branch name for checkouts with no layout:
				upstream=${GIT_SVN_ID:-git-svn}
			else
				upstream=${svn_upstream#/}
			fi
		elif [[ "svn+git" = "$upstream" ]]; then
			upstream="@{upstream}"
		fi
		;;
	esac


}

__tartify_git_ps1_count_upstream () {
	# Find how many commits we are ahead/behind our upstream
	if [[ -z "$legacy" ]]; then
		count="$(git rev-list --count --left-right \
				"$upstream"...HEAD 2>/dev/null)"
	else
		# produce equivalent output to --count for older versions of git
		local commits
		if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"
		then
			local commit behind=0 ahead=0
			for commit in $commits
			do
				case "$commit" in
				"<"*) let ++behind
					;;
				*)    let ++ahead
					;;
				esac
			done
			count="$behind	$ahead"
		else
			count=""
		fi
	fi

	# calculate the result
	if [[ -z "$verbose" ]]; then
		case "$count" in
		"") # no upstream
			p="" ;;
		"0	0") # equal to upstream
			p="=" ;;
		"0	"*) # ahead of upstream
			p=">" ;;
		*"	0") # behind upstream
			p="<" ;;
		*)	    # diverged from upstream
			p="<>" ;;
		esac
	else
		case "$count" in
		"") # no upstream
			p="" ;;
		"0	0") # equal to upstream
			p=" u=" ;;
		"0	"*) # ahead of upstream
			p=" u+${count#0	}" ;;
		*"	0") # behind upstream
			p=" u-${count%	0}" ;;
		*)	    # diverged from upstream
			p=" u+${count#*	}-${count%	*}" ;;
		esac
	fi

}

#------------------------------------------------------------------------------
#
#             HELPER FUNCTIONS
#
#------------------------------------------------------------------------------
#
__tartify_diff_count() {
#count the nb of commits between two branches of two repositorie
#   ex: __tartify_diff_count HEAD origin/master
#   ex: __tartify_diff_count upstream/dev HEAD
    echo "$(git rev-list $1..$2 2>/dev/null | awk 'END {print NR}')"
}


__tartify_usage(){
# Display the help message
  echo -e "
  ${__UN_}Description${__UNQ_} : One-Liner condensed GIT infos (for your prompt, screen
                statusline, ...)

  ${__UN_}Usage${__UNQ_} is : ${__EM_}tartify${__EMQ_} [${__Y_}options${__NN_}]

  ${__UN_}Options${__UNQ_} is : a CASE-SENSITIVE sequence of characters.

      * The following characters are reserved tartify commands :
         ${__Y_}abBcehilLnNopqrRsSuUvwW${__NN_} (and maybe more letters in the future)

      * any other character will be printed "as is", including spaces. You can use
      those to format the output of the tarttify command (as delimiters,...)
              \`tartify [r]b - l\` will output \"[repository]master - 12m\"

      * if you need multiple spaces, escape them \"\ \" :
              \`tartify [r]b -\ \ l\` will output \"[repository]master -  12m\"

      * following characters need to be escaped  ${__Y_}\(\)<>;*\"\'\`\#&|~${__NN_}


      ${__Y_}[Elements]${__NN_} ${__EM_}${__NN_}

      ${__Y_}n${__NN_}       repository ${__EMY_}n${__NN_}ame       ${__Y_}N${__NN_}   same without colors
      ${__Y_}b${__NN_}       ${__EMY_}b${__NN_}ranch name           ${__Y_}B${__NN_}          \` \`
      ${__Y_}r${__NN_}       (all)  ${__EMY_}r${__NN_}emotes  info  ${__Y_}R${__NN_}          \` \`
      ${__Y_}u${__NN_}       (only) ${__EMY_}u${__NN_}pstream info  ${__Y_}U${__NN_}          \` \`
      ${__Y_}s${__NN_}       ${__EMY_}s${__NN_}tash info            ${__Y_}S${__NN_}          \` \`
      ${__Y_}l${__NN_}       ${__EMY_}l${__NN_}ast commit info      ${__Y_}L${__NN_}          \` \`

      ${__Y_}w${__NN_}       ne${__EMY_}w${__NN_}line     insert newline (positionnal)
      ${__Y_}W${__NN_}       ne${__EMY_}W${__NN_}line     prepend newline at beginning (non-positionnal)

      ${__Y_}[Modifiers]${__NN_} ${__EM_}                 ${__NN_}

      ${__Y_}c${__NN_}       no${__EMY_}c${__NN_}olor    strip all colors

      ${__Y_}[Modes]${__NN_} ${__EM_}mutually exclusive (only first one counts)${__NN_}

      ${__Y_}i${__NN_}       succ${__EMY_}i${__NN_}nt    even shorter version
      ${__Y_}a${__NN_}       ch${__EMY_}a${__NN_}tterbox looong version
      ${__Y_}q${__NN_}       ${__EMY_}q${__NN_}uiet      only update variables, no output
      ${__Y_}o${__NN_}       ${__EMY_}o${__NN_}ldschool  __git_ps1 mode
      ${__Y_}p${__NN_}       ${__EMY_}p${__NN_}s1 mode   string with escaped (\[...\])ansi escape codes
      ${__Y_}v${__NN_}       ${__EMY_}v${__NN_}im mode   result formated for the Vim tartify plugin
                         (color info appended to result)


      ${__Y_}[Help]${__NN_} ${__EM_}all other arguments are ignored${__NN_}

      ${__Y_}h${__NN_}     ${__EMY_}h${__NN_}elp      display this help message
      ${__Y_}e${__NN_}     ${__EMY_}e${__NN_}nv help  list customizable environment variables

  ${__UN_}Default${__UNQ_}   tartify   : is equivalent to ${__EM_}tartify${__EMQ_} ${__Y_}nbrsl${__NN_}
            tartify w : is equivalent to ${__EM_}tartify${__EMQ_} ${__Y_}nbrslw${__NN_}
            tartify o : is equivalent to ${__EM_}tartify${__EMQ_} ${__Y_}obsr${__NN_}

  ${__UN_}More${__UNQ_}      see the ${__Y_}ctartify${__NN_} command to easily change tartify's colors from
            the command line and experiment

"
}


__tartify_reformat_timestamp(){
# prints a relative-formatted time string from unix timestamp
# arg: unix timestamp in seconds
# optional arg: true to include coloring
# copied from https://github.com/xtrementl/dev-bash-git-ps1.git
    local secs="$1"
    local yrs="$(( $secs / 31557600 ))"
    local div="$(( $secs % 31557600 ))"
    local days="$(( div / 86400 ))"
    div="$(( $secs % 86400 ))"
    local hrs="$(( $div / 3600 ))"
    div="$(( $secs % 3600 ))"
    local mins="$(( $div / 60 ))"

    # create the formatted time string
    local timestr
    [ 0 -lt "$yrs" ] && timestr="${yrs}y"
    if [ 0 -lt "$days" ]; then
        [ -n "$timestr" ] && timestr="$timestr,"
        timestr="${days}d"
    fi
    if [ 0 -lt "$hrs" ]; then
        [ -n "$timestr" ] && timestr="$timestr,"
        timestr="${timestr}${hrs}h"
    fi
    [ -n "$timestr" ] && timestr="${timestr},"
    timestr="${timestr}${mins}m"

    # TODO:
    # TARTIFY_STYLE_TIME_COULDCOMMIT
    # TARTIFY_STYLE_TIME_SHOULDCOMMIT
    # TARTIFY_TIME_DISPLAY
    # TARTIFY_STRING_TIME_DISPLAY

    # add a hint of color
    if [ "$2" = "false" ] && [ -n "$TARTIFY_TIME_BUGME" ]; then
    #if [ -n "$2" ] && [ -n "$TARTIFY_TIME_BUGME" ]; then
        local color
        if [ $TARTIFY_TIME_SHOULDCOMMIT -lt "$secs" ]; then # 30 mins
            color=$TARTIFY_COLOR_TIME_ACTIVITY_NON
        elif [ $TARTIFY_TIME_COULDCOMMIT -lt "$secs" ]; then # 10 mins
            color=$TARTIFY_COLOR_TIME_ACTIVITY_LOW
        else
            color=$TARTIFY_COLOR_TIME_ACTIVITY_HIGH
        fi
        timestr="${color}${timestr}${__NN_}"
    fi
    echo "$timestr"
}




#------------------------------------------------------------------------------
#
#             TARTIFY commands
#
# All the following functions are intended for use from the tartify command and
# assume we are inside a GIT repository.
#
#------------------------------------------------------------------------------
__tartify_repo_name()
{
  local _gitdir=$1
  local updir=""; [ $2 == "false" ] && updir="/.." #don't go 1 level up for bare repo
  local _nocolors=$3   #TRUE for no color
  local color

  # Print the REPO's name
  color=$TARTIFY_COLOR_REPONAME
  nocolor=$(echo `cd $_gitdir$updir; pwd` | sed 's,.*/,,' | tr -d '\n')
  color=$color$nocolor
  color=$color"${__NN_}"

  [ "true" = $_nocolors ] &&  echo -ne $nocolor || echo -ne $color
}


__tartify_branch() {

  # ARGUMENTS : $nocolor : FALSE|TRUE                (optionnal)
  #             $_mode    : OLDSCHOOL|VIM|QUIET|PS1   (optionnal)
  #
  # OLDSCHOOL _mode : output the same exact string __git_ps1 would
  #                  (except upstream, which is handled by __tartify_remote)
  #
  # VIM _mode
  #
  #   Return value:
  #
  #       $nci\|$branchname\|$merge_status
  #
  #     nci =~ /[U]?[SAONGBE][T]?/    (nci : no colors info)
  #
  #        [U]nstaged modif(s)
  #
  #        [S]taged modif(s),
  #        [A]head of remote     & nothing staged
  #        [O]K (remote == HEAD) & nothing staged
  #        [N]o tracked remote   & nothing staged
  #        inside .[G]it directory (branch info irrelevant)
  #        inside  [B]are repository (branch info irrelevant)
  #        [E]mpty repository (no branch)
  #
  #        un[T]racked files,
  #
  #     merge_infos : either one of these values, or "" :
  #
  #        REBASE-i, REBASE-m, REBASE, AM, AM/REBASE, MERGING, CHERRY-PICKING,
  #        BISECTING
  #
  # QUIET _mode
  #
  # PS1 _mode
  #
  #   will use on-the-fly variable-NAMES creation
  #
  #     TOTO=2
  #     TATA=TO
  #     TITI=$(eval "printf "%s" "\$${TATA}TO"")

  local _gitdir=$1
  local _isbare=$2             #TRUE for BARE repository
  local _hasstash=$3
  local _isinsideworktree=$4   #TRUE if inside working dir
  local _mode=$5               #either VIM | OLDSCHOOL | QUIET | PS1
  local _nocolors=$6           #TRUE for no color
  local color
  local color_base      # branch name base color
  local color_unstaged  # first 2 chars of branch name in case of unstaged modifs
  local style_untracked # special style in case of untracked files
  local nocolor
  local nci           # (VIM mode) store color infos
  local saongbe       # (VIM mode) branch status - store either one of these letters (SAONGBE)



  #DEPENDS : __gitdir
  #   local g=""    GITDIR
  #   local r=""    REBASE/MERGE/... info
  #   local b=""    BRANCH
  #   local w=""    UNSTAGED indicator "*"
  #   local i=""    STAGED indicator "+"  or NO COMMIT YET in HEAD "#"
  #   local s=""    STASH state $
  #   local u=""    UNTRACKED files %
  #   local f=""    "$w$i$s$u"  UNSTAGED STAGED STASH UNTRACKED
  #   local c=""    BARE: prefix to $b (BRANCH)
  #
  #   local p=""    UPSTREAM info || empty string

  # __git_ps1 accepts 0 or 1 arguments (i.e., format string)
  # returns text to add to bash PS1 prompt (includes branch name)

  #----------------------------------------------------------------------------
  #
  # <<BEGIN
  #
  # chunk of original __git_ps1 (from bash_completion) tuned for tartify
  #----------------------------------------------------------------------------
  if [ -n "$_gitdir" ]; then
    local r=""
    local b=""
    if [ -f "$_gitdir/rebase-merge/interactive" ]; then
      r="|REBASE-i"
      b="$(cat "$_gitdir/rebase-merge/head-name")"
    elif [ -d "$_gitdir/rebase-merge" ]; then
      r="|REBASE-m"
      b="$(cat "$_gitdir/rebase-merge/head-name")"
    else
      if [ -d "$_gitdir/rebase-apply" ]; then
        if [ -f "$_gitdir/rebase-apply/rebasing" ]; then
          r="|REBASE"
        elif [ -f "$_gitdir/rebase-apply/applying" ]; then
          r="|AM"
        else
          r="|AM/REBASE"
        fi
      elif [ -f "$_gitdir/MERGE_HEAD" ]; then
        r="|MERGING"
      elif [ -f "$_gitdir/CHERRY_PICK_HEAD" ]; then
        r="|CHERRY-PICKING"
      elif [ -f "$_gitdir/BISECT_LOG" ]; then
        r="|BISECTING"
      fi

      b="$(git symbolic-ref HEAD 2>/dev/null)" || {

        b="$(
        case "${GIT_PS1_DESCRIBE_STYLE-}" in
        (contains)
          git describe --contains HEAD ;;
        (branch)
          git describe --contains --all HEAD ;;
        (describe)
          git describe HEAD ;;
        (* | default)
          git describe --tags --exact-match HEAD ;;
        esac 2>/dev/null)" ||

        b="$(cut -c1-7 "$_gitdir/HEAD" 2>/dev/null)..." ||
        b="unknown"
        b="($b)"
      }
    fi

    local w=""
    local i=""
    local s=""
    local u=""
    local c=""
    local p=""

    if [ "true" = "$(git rev-parse --is-inside-git-dir 2>/dev/null)" ]; then
      if [ "true" = "$_isbare" ]; then
        c="BARE:"
        saongbe="B"
      else
        b=$TARTIFY_STRING_DOTGIT
        saongbe="G"
      fi
    elif [ "true" = "$_isinsideworktree" ]; then
      if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ]; then
        if [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
          git diff --no-ext-diff --quiet --exit-code || w="*"
          if git rev-parse --quiet --verify HEAD >/dev/null; then
            git diff-index --cached --quiet HEAD -- || i="+"
            saongbe="S"
          else
            i="#"
            saongbe="E"
          fi
        fi
      fi
      if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ]; then
        [ "true" = "$_hasstash" ] && s="$"
      fi

      if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ]; then
         if [ -n "$(git ls-files --others --exclude-standard)" ]; then
            u="%"
         fi
      fi

    fi
  #----------------------------------------------------------------------------
  #
  # <<END
  #
  # chunk of original __git_ps1 (from bash_completion) tuned for tartify
  #----------------------------------------------------------------------------



    # ___________________
    #
    # Now for some OUTPUT
    # ___________________

    [ "$_mode" = "OLDSCHOOL" ] && {
      local f="$w$i$s$u"
      printf "%s" "$c${b##refs/heads/}${f:+ $f}$r$p"

      #printf "%s" "$c   ${b##refs/heads/}${f:+ $f}$r$p"
      #             $c   $b               $w       $i     $s    $u        $r           $p
      #             BARE:master           unstaged staged stash untracked rebase/merge empty
      #
      #             [ branch name ]       [red]    [**]   [OLDSC] [underl] [??]
    }


    [ "$_mode" = "VIM" ] && {
      [ -n "$w" ]     && nci=$nci"U"  #unstaged

      #SAONGBE : SGBE already taken care of
      #          Determine AON (tracking branch info)
      [ -n "$w" ] && saongbe="A"
      [ -n "$w" ] && saongbe="O"
      [ -n "$w" ] && saongbe="N"

      [ -n "$u" ] && nci=$nci"T"  #untracked
      printf "%s" $nci"|"${b##refs/heads/}$r #$r already includes the "|" separator
    }

    [ "$_mode" == "QUIET" ] && {
      :;
    }

    [ "$_mode" == "PS1" ] && {
      :;
    }

    [ "$_mode" == "NONE" ] && {
      printf "%s" "$c${b##refs/heads/}$r$p"
    }


  fi


}


__tartify_remote()
{
  # OLDSCHOOL :
  #
  #    #:no upstream

  local _gitdir=$1
  local _nocolors=$2   #TRUE for no color
  local color
  local nocolor

  local branchname=$(git branch 2>/dev/null| sed -n '/^\*/s/^\* //p')
  color="  "$__NN_

  # NON-EMPTY GIT REPO
  # VERIFY that .git/refs/heads/ directory is not empty
  if [ $(ls $_gitdir/refs/heads/ | wc -l) -gt 0 ]
  then

    # ------- REMOTES INFO ( + BRANCH TRACKED ) --------
    local marker
    local marker_color
    local before_traked
    local after_tracked
    local before_untraked
    local after_untracked

    # loop through remotes
    for remotename in $(git remote show); do

      # special markers for origin and upstream
      # nb: a tracked remote is preceded by a little ➝ symbol
      case $remotename in
          origin)   marker="O"; marker_color=$TARTIFY_COLOR_REMOTE_ORIGIN   ;;
        upstream)   marker="U"; marker_color=$TARTIFY_COLOR_REMOTE_UPSTREAM ;;
                *)   marker="⇧"; marker_color=$TARTIFY_COLOR_REMOTE_OTHER    ;;
      esac

      # CURRENT BRANCH is tracked to CURRENT REMOTE ?
      if [[ $(git config --get branch.$branchname.remote) =~ $remotename ]]
      then
        [ "true" = $_nocolors ]  &&  {
                              before_traked=" ➝ "; after_tracked="";
                              before_untraked=" "; after_untracked=""; 
                            } || {
                              before_traked=" ➝${__EM_} "; after_tracked="${_EMQ_}";
                              before_untraked=" "; after_untracked="";
                            }
      else
        before_traked=""; after_tracked="";before_traked=" "; after_tracked="";
      fi


      # nb of commits AHEAD/BEHIND
      local ahead_count="$(__tartify_diff_count $remotename/$branchname HEAD)"
      local behind_count="$(__tartify_diff_count HEAD $remotename/$branchname)"
      local diffcount=""
      local diffcountnocol=""
      if [ 0 -lt "$ahead_count" ]; then
          diffcount="${TARTIFY_COLOR_REMOTE_AHEAD}${ahead_count}"
          diffcountnocol="+${ahead_count}"
      fi

      if [ 0 -lt "$behind_count" ]; then
          [ -n "$diffcount" ] && {
                  diffcount=${diffcount}${marker_color}$TARTIFY_STRING_DIVERGE_SEP
                  diffcountnocol=${diffcountnocol}$TARTIFY_STRING_DIVERGE_SEP
                }
          diffcount="${diffcount}${TARTIFY_COLOR_REMOTE_BEHIND}${behind_count}"
          diffcountnocol="${diffcountnocol}-${behind_count}"
      fi

      [ -n "$diffcount" ] && diffcount=" ${marker_color}($diffcount${marker_color}) "
      [ -n "$diffcountnocol" ] && diffcountnocol=" ($diffcountnocol) "
      #echo "$diffcount"


      color=$color"${marker_color}${before_traked}${marker}${after_tracked}${diffcount}${__NN_}"
      nocolor=$nocolor"${before_traked}${marker}${after_tracked}${diffcountnocol}"

    done
  fi

  [ "true" = $_nocolors ] &&  echo -ne $nocolor || echo -e $color

  #TODO: oldschool 
      #if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
      #  __git_ps1_show_upstream
      #fi

}


#optimized
__tartify_stash()
{
  local _hasstash=$1
  local _isinsideworktree=$2   #TRUE if inside working dir
  local _mode=$3
  local _nocolors=$4           #TRUE for no color
  local color
  local nocolor
  #? are we inside a GIT repo's working tree
  #TODO: redundant test
  if [ "true" = "$_isinsideworktree" ]; then
    if [ "true" = "$_hasstash" ]; then
      if [ -n "$TARTIFY_COUNTSTASHES" ]; then
        # One star per stash
        color=$TARTIFY_COLOR_STASH_COUNT
        nocolor="  "
        #! `git stash list | wc -l` adds about 50ms
        for (( i=0; i< $(git stash list | wc -l); i++ ))
        do
          nocolor=$nocolor$TARTIFY_STRING_STASH
        done
        nocolor=$nocolor" "
      else
        color=$TARTIFY_COLOR_STASH_NOCOUNT
        nocolor=$TARTIFY_STRING_STASH
      fi
      color=$color$nocolor${__NN_}

      [[ "$_mode" =~ OLDSCHOOL ]] && nocolor="$"
    fi

    [ "true" = $_nocolors ] &&  echo -ne $nocolor || echo -e $color
  fi
}


__tartify_timelastcommit(){
  #TODO: COLORS !!!!!!!
  local _nocolors=$1           #TRUE for no color
  local color
  local nocolor

  #? are we inside a GIT repo
  if git rev-parse --git-dir >/dev/null 2>&1; then
    # calc relative time diff of last commit
    local secs="$(
      # get the unix timestamp for the lastest commit (seconds)
      # copied from https://github.com/xtrementl/dev-bash-git-ps1.git
          local now="$(date +%s)"
          local last_commit="$(git log --format='%at' -1 2>/dev/null)"
          if [ -z "$last_commit" ]; then # probably initial git init, no commits
              return
          fi
          if [ 0 -lt "$now" ] && [ 0 -lt "$last_commit" ]; then
              echo "$((now - last_commit))"
          fi
    )"
    #TODO: include $_nocolors
    [ -n "$secs" ] && echo -e "$(__tartify_reformat_timestamp $secs $_nocolors)"
  fi
}

#------------------------------------------------------------------------------
#
#             TARTIFY
#
#------------------------------------------------------------------------------

tartify()
{
  local argstr="$*"

  # -- PARSE help options and exit --
  # do that first to enable testing if 'tartify' is present with exit value of zero

  # Help
  [[ "$argstr" =~ h ]] && { __tartify_usage; return 0; }
  # pretty print TARTIFY environment
  [[ "$argstr" =~ e ]] && {
    echo;echo
    echo "   Tartify's ENVIRONMENT variables are currently"
    echo "   set to :"
    echo
    echo "    "$__UN_"                                               "$__NN_
    echo       "   |$__UN_$__BGK_                  PARAMS                       $__NN_|"
    env | grep "^TARTIFY_" | grep -v "^TARTIFY_COLOR\|TARTIFY_STYLE" | sort -df \
        | awk -F"=" '{printf("%'11s'%-'15s'%-'29s'%'0s'\n", "\033[0m|   ",$2,$1,"|")}'
    echo "   |"$__UN_"                                               "$__NN_"|"
    echo       "   |$__UN_$__BGK_                  STYLES                       $__NN_|"
    echo       "   |                                               |"
    env | grep "^TARTIFY_STYLE" | sort -df \
        | awk -F"=" '{printf("%'11s'%'0s'%-'48s'%'0s'\n", "\033[0m|   ",$2,($1 "\033[0m"),"|")}'
    echo "   |"$__UN_"                                               "$__NN_"|"
    echo       "   |$__UN_$__BGK_                  COLORS                       $__NN_|"
    echo       "   |                                               |"
    env | grep "^TARTIFY_COLOR" | sort -df \
        | awk -F"=" '{printf("%'11s'%'0s'%-'48s'%'0s'\n", "\033[0m|   ",$2,($1 "\033[0m"),"|")}'
    echo       "   |                                               |"
    echo "   |"$__UN_"                                               "$__NN_"|"
    echo
    echo $__NN_"   \`tartify help\` for more";
    echo $__NN_"   \`ctartify help\` for more";
    return 0
  }


  # Override args with $TARTIFY_FORCE if non empty
  [ -n "$TARTIFY_FORCE" ] && argstr=$TARTIFY_FORCE


  # -- INIT tartify local vars --
  # any one of these HAS to be non-empty (passed as positional parameters
  # to other functions)
  local isbare="false"
  local isinsideworktree="false"
  local hasstash="false"
  local hasupstream="false"
  local nocolors="false"
  local mode="NONE"

  local processremotes="false"
  local processupstream="false"

  # -- INIT __git_ps1 locals --
  local g=""   #GITDIR
  local r=""   #REBASE/MERGE/... info
  local b=""   #BRANCH
  local w=""   #UNSTAGED indicator "*"
  local i=""   #STAGED indicator "+"  or NO COMMIT YET in HEAD "#"
  local s=""   #STASH state $
  local u=""   #UNTRACKED files %
  local f=""   #"$w$i$s$u"  UNSTAGED STAGED STASH UNTRACKED
  local c=""   #BARE: prefix to $b (BRANCH)
  local p=""   #UPSTREAM info || empty string


  # -- BAIL if not INSIDE a GIT REPO --
  g=`git rev-parse --git-dir 2>/dev/null`
  [ $? == 0  ] && {

    #Perform all cheap 'git' tests (used in more than one '__tartify_*' function)

    isbare=$( git rev-parse --is-bare-repository 2>/dev/null )
    isinsideworktree=$(git rev-parse --is-inside-work-tree 2>/dev/null)
    if [ "true" = "$isinsideworktree" ]; then
      git rev-parse --verify refs/stash >/dev/null 2>&1 && hasstash="true"
    fi
    git rev-list  @{upstream}...HEAD >/dev/null 2>&1                  # 8ms
    [ $? == 0 ] && hasupstream="true" || hasupstream="false"


    __tartify_git_ps1

    #TODO:
    count="$(git rev-list --count --left-right "$upstream"...HEAD 2>/dev/null)"



    # (optionnal) argument expansion
    #TODO: these tests suck
    [ "$argstr"  = "w" ] && argstr="nbrslw"                           #newline after
    [ "$argstr"  = "W" ] && argstr="nbrslW"                           #newline before
    [ "$argstr" = "Ww" ] || [ "$argstr" = "wW" ] && argstr="nbrslwW"  #newline BOTH
    [ "$argstr"  = "o" ] && argstr="obsr"                             #oldschool
    [ "$argstr"  = "v" ] && argstr="vnbrsl"                           #vim
    [ ${#argstr} == 0 ] && argstr="nbrsl"                             #no args

    local separator


    # REGEX TESTS
    #POSIX WAY (2ms   average) : expr $argstr : '.*c'  >/dev/null 2>&1 && {
    #BASH  WAY (0.4ms average) : [[ "$argstr" =~ c ]] && {


    local i
    #
    # PRE-PARSING (modes)
    #
    for ((i=0;i<${#argstr};i++))
    do
      local ch=${argstr:$i:1}
      case $ch in

        # -- MODES --

        # No Colors MODE : strip all color info, whatever the result
        c)  nocolors="true"         ;;
        # Vim MODE : no color, prepend color infos for 'branch', use '#' as separator
        v)
          nocolors="true"
          mode="VIM"
          # don't fucking change that:
          separator="vimsplitsep"
                                    ;;
        # OldSchool MODE : no color, branch results with $*+, stash results with %
        o)
          #separator=" "
          nocolors="true"
          mode="OLDSCHOOL"
                                    ;;
        # Quiet mode (only update the __TART4PS1* variables)
        q) mode="QUIET"             ;;
        # PS1 mode (ansi color codes escaped with '\[' and '\]' for PS1
        p) mode="PS1"               ;;
        # SUCCINT (SHORT) mode
        i) mode="SHORT"             ;;
        # CHATTERBOX (LOOONG) mode
        a) mode="LONG"              ;;

        # -- MODAL ARGS --

        u|U) processupstream="true" ;;
        r|R) processremotes="true"  ;;

      esac
    done
    #
    # ARGUMENTS
    #
    local tartAnswer=""
    for ((i=0;i<${#argstr};i++))
    do
      local ch=${argstr:$i:1}
      case $ch in
        n) tartAnswer=$tartAnswer$separator$( __tartify_repo_name $g $isbare                                   $nocolors);;
        b) tartAnswer=$tartAnswer$separator$( __tartify_branch    $g $isbare $hasstash $isinsideworktree $mode $nocolors);;
        r) tartAnswer=$tartAnswer$separator$( __tartify_remote    $g                                           $nocolors);;
        #TODO:
        u) tartAnswer=$tartAnswer$separator$( __tartify_remote    $g                                           $nocolors);;

        s) tartAnswer=$tartAnswer$separator$( __tartify_stash                     $hasstash $isinsideworktree $mode $nocolors);;
        l) tartAnswer=$tartAnswer$separator$( __tartify_timelastcommit                                              $nocolors);;
        c) ;;
        o) ;;
        p) ;;
        i) ;;
        a) ;;
        q) ;;
        v) ;;
        w) ;;
        W) ;;
        #TODO: make that issue ansi escapes (PS1 and standard mode)
        \\) tartAnswer=$tartAnswer$TARTIFY_COLOR_DELIMITER$ch$__NN_;;
        #TODO: make that work with PS1 and NOCOLORS
        *) tartAnswer=$tartAnswer$TARTIFY_COLOR_DELIMITER$ch$__NN_;;
      esac
    done

    # Post Process
    # VIM mode : remove first occurence of $separator
    [ "$mode" = "VIM" ] && tartAnswer=${tartAnswer/#vimsplitsep/}

    # -- OUTPUT --
    # TODO: this test sucks (time lost in subshell)
    # remove ansi escapes
    local testforblank=$(echo  $tartAnswer | sed -E "s/\\\\033\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g")
    testforblank=${testforblank/ //}

    #TODO: 'w' newline insertion can happen anywhere, 'W' only at BOL
    # only do something if answer is not empty
    [ ${#testforblank} != 0 ] && {
      [[ "$argstr" =~ W ]] && echo -ne "\n" # linebreak before
      echo -ne $tartAnswer
      [[ "$argstr" =~ w ]] && echo -ne "\n" # linebreak after
    }
  }
  return 0
}


#------------------------------------------------------------------------------
#
#             TARTIFY ADDONS
#
#------------------------------------------------------------------------------


ctartify(){
  # Quick tuner for tartify's COLOR-RELATED environment variables
  # (with completion)

  local myargs=$(echo "$*" | tr '[A-Z]' '[a-z]' | tr '-' ' ' | sed 's/tartify_//g')
  [ -z "$myargs" ] && { tartify e; return 0; }
  local myansw
  local mytest
  local myarg
  local myenv
#echo "myargs=$myargs"
  for myarg in $myargs; do
    case $myarg in

      # ENV VARS
      style_*|color_*) myenv=$myenv$myarg" "
#echo "myarg=$myarg"
                                      ;;

      # STYLES
      bold|emphasized)   myansw=$myansw$__EM_ ;;  underlined)        myansw=$myansw$__UN_ ;;
      i*)        myansw=$myansw$__RV_ ;;

      # COLORS
      black)     myansw=$myansw$__K_  ;;  red)        myansw=$myansw$__R_  ;;
      green)     myansw=$myansw$__G_  ;;  yellow)     myansw=$myansw$__Y_  ;;
      blue)      myansw=$myansw$__B_  ;;  magenta)    myansw=$myansw$__M_  ;;
      cyan)      myansw=$myansw$__C_  ;;  white)      myansw=$myansw$__W_  ;;

      # BACKGROUND COLORS
      bgblack)   myansw=$myansw$__BGK_ ;;  bgred)      myansw=$myansw$__BGR_;;
      bggreen)   myansw=$myansw$__BGG_ ;;  bgyellow)   myansw=$myansw$__BGY_;;
      bgblue)    myansw=$myansw$__BGB_ ;;  bgmagenta)  myansw=$myansw$__BGM_;;
      bgcyan)    myansw=$myansw$__BGC_ ;;  bgwhite)    myansw=$myansw$__BGW_;;

      # MISC
      test)      mytest="t"          ;;
      export)    mytest="t"          ;;

      # HELP
      h|help|?) cat <<HELPMSG

${__EMR_}NAME
     ctartify${__NN_} -- Quick color changer for ${__EM_}tartify${__NN_}

${__EMR_}SYNOPSIS${__NN_}
     ${__EMR_}ctartify${__NN_} [${__EMR_}-SHORTNAME${__NN_}][${__EMG_}TARTIFY_* ...${__NN_}][${__EMG_}compound${__NN_}]

${__EMR_}DESCRIPTION${__NN_}
     The order of command line arguments doesn't matter. When used
     without arguments, ${__EMR_}ctartify${__NN_} pretty prints a list of
     ALL tartify environment variables with their current value
     (same as \`tartify e\`)

     The options have the following meaning:

     ${__EMG_}TARTIFY_*${__NN_}
           any sequence of TARTIFY_COLOR_... or TARTIFY_STYLE_...
           environment variables, by full name (eg: TARTIFY_COLOR_STAGED)
                -> case insensitive
                -> run ${__EMR_}ctartify${__NN_} without any argument to get a complete
                   list of ALL tartify environment variables with their
                   current value)
                -> use ${__EMG_}T+completion${__NN_} to loop through ${__EM_}full${__NN_} names

     ${__EMR_}-SHORTNAME${__NN_}
           any sequence of TARTIFY_COLOR or TARTIFY_STYLE
           environment variables, by short name (eg: -COLOR_STAGED),
           prefixed with a ${__Y_}single-dash${__NN_}

            -> case insensitive
            -> use ${__EMG_}dash+completion${__NN_} to loop through ${__Y_}short${__NN_} names

           If no environement variable is specified, ${__EMR_}ctartify${__NN_}
           will print the compound color corresponding to ${__EMG_}compound${__NN_}
           to STDOUT

     ${__EMG_}compound${__NN_}  a list of any of the following words (case insensitive,
           use completion to loop through)

        ${__EMG_}*${__NN_} ${__G_}colors & styles${__NN_}
           ${__EM_}bold${__NN_}    ${__EM_}emphasized${__NN_} ${__UN_}underlined${__NN_} ${__RV_}inverse${__NN_}

           ${__K_}black${__NN_}   ${__R_}red${__NN_}        ${__G_}green${__NN_}     ${__Y_}yellow${__NN_}
           ${__B_}blue${__NN_}    ${__M_}magenta${__NN_}    ${__C_}cyan${__NN_}      ${__W_}white${__NN_}

           ${__BGK_}BGblack${__NN_} ${__BGR_}BGred${__NN_}      ${__K_}${__BGG_}BGgreen${__NN_}   ${__K_}${__BGY_}BGyellow${__NN_}
           ${__K_}${__BGB_}BGblue${__NN_}  ${__K_}${__BGM_}BGmagenta${__NN_}  ${__K_}${__BGC_}BGcyan${__NN_}    ${__K_}${__BGW_}BGwhite${__NN_}

        ${__EMG_}*${__NN_} ${__G_}Other${__NN_} ${__EM_}${__NN_}
           test      doesn't modify any environment variable, just simulates.
           export    print out the current TARTIFY environment in a form
                     that can be reused for initializing tartify (only the
                     diff with the default environmen is output)

${__EMR_}EXAMPLES${__NN_}

      ${__K_}\$ ctartify TARTIFY_COLOR_STAGED bold magenta${__NN_}
      ${__K_}\$ ctartify -COLOR_STAGED bold blue underline verbose${__NN_}
      TARTIFY_COLOR_STAGED (${__EMM_}was${__NN_}) (${__EMB_}${__UN_}now is${__NN_})
      ${__K_}\$ ctartify -COLOR_STAGED -COLOR-UPTODATE r i test${__NN_}
      TARTIFY_COLOR_STAGED (${__EMB_}${__UN_}was${__NN_}) (${__EMR_}${__RV_}*TEST*${__NN_})
      TARTIFY_COLOR_UPTODATE (${__EMG_}was${__NN_}) (${__EMR_}${__RV_}*TEST*${__NN_})
      ${__K_}\$ ctartify test bold cyan${__NN_}
      ${__EMC_}*TEST*${__NN_}
      ${__K_}\$ ctartify un yellow; echo \"colored string\"${__NN_}
      ${__Y_}${__UN_}colored string${__NN_}
      ${__K_}\$ MYENVVAR=\$(ctartify bo r); echo \$MYENVVAR\"colored string\"${__NN_}
      ${__EMR_}colored string${__NN_}

HELPMSG
        return 0                      ;;

     *) echo "Unknown argument $myarg"
        return 1
                                      ;;
    esac
  done;


  # OUTPUT
  [ -n "$myenv" ] && {
        # WITH ENV
        local thisenv
        for thisenv in $myenv; do
            thisenvUP="TARTIFY_"$(echo $thisenv | tr '[a-z]' '[A-Z]')
            [ -n "$myansw" ] && {
                printf "\n%s" "$thisenvUP ($(eval printf "%s" "\$$thisenvUP")was$__NN_)"
                [ "t" = "$mytest" ] && printf " %s\n" " (${myansw}*TEST*$__NN_)"|| {
                    printf " %s\n" " (${myansw}now is$__NN_)"
                    #ASSIGN env variable
                    eval "$thisenvUP=$myansw"
                }
            } || {
                printf "\n%s\n" "no option set."
                printf "%s\n" "$thisenvUP ($(eval printf "%s" "\$$thisenvUP")is$__NN_)"
            }
        done
        echo
  } || {
      # NO ENV
      [ "t" = "$mytest" ] && printf "%s\n" "${myansw}*TEST*$__NN_" || printf "%s" "${myansw}"
  }

}


__ctartify_completion()
{
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    optsVAR=$(env | grep "^TARTIFY_COLOR\|^TARTIFY_STYLE" | awk -F"=" '{printf("-%s ", $1)}' | sed 's/TARTIFY_//g')
    optsVARLONG=$(env | grep "^TARTIFY_COLOR\|^TARTIFY_STYLE" | awk -F"=" '{printf("%s ", $1)}')

    optsARG="bold emphasized underlined inverse black red green yellow
    blue magenta cyan white bgblack bgred bggreen bgyellow bgblue
    bgmagenta bgcyan bgwhite test help "

    #if [[ ${cur} == T* ]] ; then
    if [[ ${cur} == -* ]] ; then
        COMPREPLY=( $(compgen -W "${optsVAR}" -- ${cur}) )
        return 0
    elif [[ ${cur} == T* ]] ; then
        COMPREPLY=( $(compgen -W "${optsVARLONG}" -- ${cur}) )
        return 0
    else
        COMPREPLY=( $(compgen -W "${optsARG}" -- ${cur}) )
        return 0
    fi
}




#------------------------------------------------------------------------------
#
#             MAIN
#
#------------------------------------------------------------------------------

__tartify_define_colors_TPUT
__tartify_init_globs

# ADDONS

##TODO: ZSH compatibility
#if [[ -n ${ZSH_VERSION-} ]]; then
#  autoload -U compinit
#  autoload -U +X bashcompinit && bashcompinit
#fi

#if [[ -n ${ZSH_VERSION-} ]]; then
#  emulate -L bash
#  setopt KSH_TYPESET

#  # workaround zsh's bug that leaves 'words' as a special
#  # variable in versions < 4.3.12
#  typeset -h words
#fi

complete -F __ctartify_completion ctartify

#DEPREC:
#export __tartify_shell_loaded=1

# script is being executed, run the main command
# script is being sourced, exit with 0
[ "$__tartify_whocalled" = "exec" ] && tartify $__tartify_args || return 0


# REMOVE ANSI ESCAPE from string
# MACOS
# echo  $TOTO | sed -E "s/\\\\033\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
# LINUX
#               sed -r


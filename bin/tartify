#!/bin/bash
##################################################################################
#
#       Filename:  tartify
#
#    Description:  BASH PS1 with GIT support
#
#                  Colored command prompt adapted to GIT repository. VERY
#                  colorfull, not for the faint hearted
#
#  Configuration:  place this file somewhere in your PATH and source it in your
#                  .bashrc
#
#                     source /path/to/bashps1
#
#   Dependencies:  Depends on GIT, might work on windows with Cygwin
#
#   GVIM Version:  1.7+ (?)
#
#         Author:  Pierre Lhoste
#        Twitter:  http://twitter.com/peterhost
#
#        Version:  0.1
#        Created:  01.05.2011
#        License:  WTFPL V2
#
# DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE Version 2, December 2004
#
# Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>
#
# Everyone is permitted to copy and distribute verbatim or modified
# copies of this license document, and changing it is allowed as long as
# the name is changed.
#
#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE TERMS AND
#            CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
#
#  0. You just DO WHAT THE FUCK YOU WANT TO.
#
#------------------------------------------------------------------------------
#

# USAGE : Just call the tartify() function from the command line
#
#         PROMPT integration : call tartify() inside your $PS1. Examples:
#
#           PS1="\$(tartify) [\u@\h]\$ "
#           PS1="\$(tartify)\n[\u@\h]\$ "
#           ...
#
#         You can also pass arguments to tartify() to make it display only
#         certain informations
#
#           tartify -h
#
#

#PS1="${__PS1NN_}${__PS1EMK_}[${__PS1UC_}\u${__PS1EMK_}@${__PS1EMUC_}\h ${__PS1C_}\${NEW_PWD}${__PS1EMK_}] \$"
#PROMPT_COMMAND=tartify
#
#
#
#------------------------------------------------------------------------------
#
# ISSUE :
#
#   * no support for SVN upstream (as I don't use SVN), feel free to augment
#     this script
#
#

#   * conditionnal newline : there is no such thing in a prompt. Either a
#   newline is hardcoded in the prompt, or it's not. All linebreak(s) inserted
#   by an external command called in the PS1 variable via "$(command)" are
#   stripped out when $PS1 is evaluated. With the exception of a newline
#   followed by something (see ISSUE below)
#
#   Solution: if you need a multiline prompt, with the 'tartify' line only
#   inserted if you're being in a 'git' repository, consider using a
#   PROMPT_COMMAND like this :
#
#     prompt_command(){
#       ...
#       tartify w
#     }
#     PROMPT_COMMAND=prompt_command
#
#   The 'w' option to tartify issues a newline if the contents of \`tartify\`
#   is not an empty string.
#
#   ISSUE: Inside PS1, it will work too at the cost of inserting an extra
#   whitespace after the newline (otherwise the newline will be striped)
#
#
#      ALMOST WORKS :
#      PS1='$(echo -ne "\n ")\[$(tput kbs)$\] '
#
#      INDENTATION
#      PS1='\[$(tput sc)\]\[\033[60C (`date "+%a, %b %d"`)\]\[$(tput rc)\]'
#
#
#
#   * Line Wrapping Calculation
#
#     The one thing (that I know of) which confuse line wrapping (when browsing
#     command history with long lines, for ex) is non-printable characters
#     (such as ansi escape color codes, cursor movement,...). So:
#
#       1 - non-printable characters in the PS1 variable have to be "escaped"
#       by enclosing them between a pair of escaped brackets :
#
#           \[\033[0;30m\]   instead of  \033[0;30m
#
#       And this has to be done at PS1 definition-time, as PS1 is only assigned
#       ONCE but evaluated at EACH PROMPT.
#
#       2 - function calls inside the PS1 variable that issue non-printable
#       characters will confuse the prompt, naturally, if the said n-p-chars
#       are not escaped IN the PS1 variable itself at assignement time. Example :
#
#               PS1=">"
#               > pwd
#               /some/dir
#               > myfunc(){ echo  "\[\033[0;30m\]\$(pwd) > \[\033[0m\]"; }
#               > myfunc
#               \[\033[0;30m\]$(pwd) > \[\033[0m\]
#
#           this will work
#               > PS1=$(myfunc)
#               /some/dir > echo $PS1
#               \[\033[0;30m\]$(pwd) > \[\033[0m\]
#               /some/dir > cd tmp
#               /some/dir/tmp >
#
#            this won't:
#               /some/dir/tmp > PS1='$(myfunc)'
#               \[\]stevejobs~ echo $PS1
#               $(myfunc)

#            As you can see in the latter, there are no escaped ansi codes
#            whatsoever, just a function call.  the prompt will print
#            litterally '\[\033[0;30m\]' each time, as this escaped substring
#            was not hardcoded in the PS1 variable at the time when it was
#            assigned, but generated by a function call evaluated for each
#            prompt, INSIDE the PS1 variable

#       MORE: on the subject
#       http://www.issociate.de/board/post/481503/bash_command_substitution,_functions_and_quoting_:_need_help.html
#
#     Problem is : if a function used in the PS1 variable is to adapt it's colored
#                  output according to context, there is no way to hardcode that
#                  directly in $PS1 with the '\[' escapes.
#
#       -> better use `printf` rather than `echo` (which somewhat sucks and which
#       behaviour is inconsistant across shells and OSes)
#
#       OR...
#       -> need to be issued on a line prior to the last line of the prompt, with :
#           * either \n insertion,
#
#               PS1="\$(tartify)\n$ "
#
#           * or use of the PROMPT_COMMAND environment variable
#
#               __somefunc() {
#                 ...
#                 tartify
#                 ...
#               }
#               export PROMPT_COMMAND=__somefunc
#               PS1=...
#
#       otherwise they will confuse wrapping too. Hence, your PS1 better look
#       something like :
#
#
#
#       (SEE:http://hintsforums.macworld.com/archive/index.php/t-17068.html)
#
#    * Quick n dirty benchmark
#      loop over 1000 executions of `tartify` on a 3.06GHz Intel Core 2 Duo Imac
#      without any further methodology
#
#       **execution-time (ms)**
#       _____________________________________________________________
#      |    REPO   | TINY       | SMALL     | MEDIUM    | LARGE      |
#      |           | ms   %     | ms   %    | ms   %    | ms   %     |
#      |___________|____________|___________|___________|____________|
#      |    remote | 48   25%   | 59   29%  | 92   27%  | 93  23%    |
#      |   1 stash | 56   30%   | 56   28%  | 179  52%  | 202 50%    |
#      |    branch | 60   32%   | 63   31%  | 46   13%  | 81  20%    |
#      |      repo | 14    7%   | 13    6%  | 13    4%  | 14   3%    |
#      |  timelast | 11    6%   | 11    5%  | 12    3%  | 12   3%    |
#      |           |            |           |           |            |
#      |     total | 189        | 202       | 342       | 402        |
#      |           |            |           |           |            |
#      | __git_ps1 |            |           |           | 63         |
#      | __git_ps1 |            |           |           |            |
#      |shwupstream|            |           | 21        | 26         |
#      |___________|____________|___________|___________|____________|
#
#
#------------------------------------------------------------------------------
#
# NOTA :
#          Special Character Codes
#          \a – an ASCII bell character (07)
#          \d – the date in “Weekday Month Date” format (e.g., “Tue May 26″)
#          \D{format} – the format is passed to strftime(3) and the result is inserted into the prompt string; an empty format results in a locale-specific time representation. The braces are required
#          \e – an ASCII escape character (033)  (hence : \e and \033 are equivalent)
#          \h – the hostname up to the first `.’
#          \H – the hostname
#          \j – the number of jobs currently managed by the shell
#          \l – the basename of the shell’s terminal device name
#          \n – newline
#          \r – carriage return
#          \s – the name of the shell, the basename of $0 (the portion following the final slash)
#          \t – the current time in 24-hour HH:MM:SS format
#          \T – the current time in 12-hour HH:MM:SS format
#          \@ – the current time in 12-hour am/pm format
#          \A – the current time in 24-hour HH:MM format
#          \u – the username of the current user
#          \v – the version of bash (e.g., 2.00)
#          \V – the release of bash, version + patchelvel (e.g., 2.00.0)
#          \w – the current working directory
#          \W – the basename of the current working directory
#          \! – the history number of this command
#          \# – the command number of this command
#          \$ – if the effective UID is 0, a #, otherwise a $
#          \nnn – the character corresponding to the octal number nnn
#          \\ – a backslash
#          \[ - begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt
#          \] – end a sequence of non-printing characters
#
#          (http://www.wiredrevolution.com/bash-programming/customize-the-bash-ps1-command-prompt)



#------------------------------------------------------------------------------
#
#             PRELIMINARY CHECKS
#
#------------------------------------------------------------------------------
# store command line params
__tartify_args="$*"

# Are we being sourced or executed ?
Prog="tartify"
__tartify_whocalled=
if [ "$(basename $0 2>/dev/null )" = "$Prog" ]; then
  __tartify_whocalled="exec"
else
  __tartify_whocalled="source"
fi

# take care of non UTF-8 terminals
supports8=
locale | grep -i utf-8 >/dev/null 2>&1 && supports8="true"


#------------------------------------------------------------------------------
#
#             SHELL DETECTION
#
#------------------------------------------------------------------------------

## SHELL detection
## SHELL      DARWIN      LINUX
## sh         path/to/sh  sh
## csh        -sh         -sh
## tcsh       -csh        -csh
## ksh        ksh         ksh
## bash       -bash       bash
## zsh        zsh         zsh

#__thisShell=`ps $$ | grep $$ | awk '{ print $5 }' | sed 's/\-/\\\-/g'`
#echo $__thisShell
#__thisShell=$(basename $__thisShell)
#echo $__thisShell
## Darwin detection
#if uname -s | grep "Darwin" >/dev/null 2>&1
#then
#  __OSflavor="Darwin" # macos
#fi

## BAIL if using SH on OSX, (scrambles "echo -ne" commands)
#[ "$__OSflavor" = "Darwin" ] && [ "$__thisShell" = "sh" ] && { echo " SH detected, exit";  exit 1; }

#------------------------------------------------------------------------------
#
#             MISC GLOBAL VARIABLES
#
#------------------------------------------------------------------------------


__tartify_define_colors_TPUT() {
# COLOR VARS :  * declare those color codes ONCE and for ALL.
#                 This somewhat pollutes the GLOBAL SCOPE but the variable names
#                 are (thought to be) unique enough so that won't cause problems
#
#               * do that like a grownup (tput, not ANSI escapes)
#
#               * TODO: handle dark vs light background
#
#               * TODO: handle 256 colors (if [ $(tput colors) -ge 256 ] ...)
#                       -> do that via tartitheme()

#
                                                                     #   ANSI equivalent
                                                                     #  <attr> <fg>  <bg>
  # ALL
   __NN_=$( tput sgr0   || : 2>/dev/null )                    # [ 0m                RESET ALL attributes

  # STYLES
  # <BEGIN>
   __EM_=$( tput bold    || : 2>/dev/null )                   # [ 1m                BEGIN DOUBLE INTENSITY (bold) mode
   __DM_=$( tput dim     || : 2>/dev/null )                   # [ 2m                BEGIN HALF INTENSITY    (dim) mode
   __UN_=$( tput smul    || : 2>/dev/null )                   # [ 4m                BEGIN UNDESCORE  (underlined) mode
   __BL_=$( tput blink   || : 2>/dev/null )                   # [ 5m                BEGIN BLINKING                mode
   __RV_=$( tput rev     || : 2>/dev/null )                   # [ 7m                BEGIN REVERSE VIDEO (reverse) mode
   __SO_=$( tput smso    || : 2>/dev/null )                   #?[ 7m                BEGIN STANDOUT      (reverse) mode
   __IN_=$( tput invis   || : 2>/dev/null )                   # [ 8m                BEGIN INVISIBLE               mode
   __DEL_=$(tput cub1    || : 2>/dev/null )                   #                     MOVE cursor LEFT one space
  # <END>
  __SOQ_=$( tput rmso    || : 2>/dev/null )                   #?[ 27m               END   STANDOUT      (reverse) mode
  __UNQ_=$( tput rmul    || : 2>/dev/null )                   # [ 24m               END   UNDESCORE  (underlined) mode
  # for all other END style, use `tput sgr0` ($__NN_)

  # COLORS
  # <Foreground>
    __K_=$( tput setf 0 || tput setaf 0 || : 2>/dev/null )    # [       0m          SET   FG color to BLACK
    __R_=$( tput setf 4 || tput setaf 1 || : 2>/dev/null )    # [       1m          SET   FG color to RED
    __G_=$( tput setf 2 || tput setaf 2 || : 2>/dev/null )    # [       2m          SET   FG color to GREEN
    __Y_=$( tput setf 6 || tput setaf 3 || : 2>/dev/null )    # [       3m          SET   FG color to YELLOW
    __B_=$( tput setf 1 || tput setaf 4 || : 2>/dev/null )    # [       4m          SET   FG color to BLUE
    __M_=$( tput setf 5 || tput setaf 5 || : 2>/dev/null )    # [       5m          SET   FG color to MAGENTA
    __C_=$( tput setf 3 || tput setaf 6 || : 2>/dev/null )    # [       6m          SET   FG color to CYAN
    __W_=$( tput setf 7 || tput setaf 7 || : 2>/dev/null )    # [       7m          SET   FG color to WHITE
  # <Background>
  __BGK_=$( tput setb 0 || tput setab 0 || : 2>/dev/null )    # [       0m          SET   BG color to BLACK
  __BGR_=$( tput setb 4 || tput setab 1 || : 2>/dev/null )    # [       1m          SET   BG color to RED
  __BGG_=$( tput setb 2 || tput setab 2 || : 2>/dev/null )    # [       2m          SET   BG color to GREEN
  __BGY_=$( tput setb 6 || tput setab 3 || : 2>/dev/null )    # [       3m          SET   BG color to YELLOW
  __BGB_=$( tput setb 1 || tput setab 4 || : 2>/dev/null )    # [       4m          SET   BG color to BLUE
  __BGM_=$( tput setb 5 || tput setab 5 || : 2>/dev/null )    # [       5m          SET   BG color to MAGENTA
  __BGC_=$( tput setb 3 || tput setab 6 || : 2>/dev/null )    # [       6m          SET   BG color to CYAN
  __BGW_=$( tput setb 7 || tput setab 7 || : 2>/dev/null )    # [       7m          SET   BG color to WHITE
  # <reset>
   __NF_=$( tput setf 9 || tput setaf 9 || : 2>/dev/null )    # [       39m         RESET FG color to term's default
   __NG_=$( tput setb 9 || tput setab 9 || : 2>/dev/null )    # [             49m   RESET BG color to term's default
  __NFG_=$__NF_$__NB_                                         # [       39;   49m   RESET FG & BG color to term's default

  if [ $(tput colors) -eq 256 ]; then
  ## <Foreground>
    __K_=$( tput setf 243 || tput setaf 243 || : 2>/dev/null ) #                    SET   FG color to BLACK
  #  __R_=$( tput setf 196 || tput setaf 196 || : 2>/dev/null ) #                    SET   FG color to RED
  #  __G_=$( tput setf 34  || tput setaf 34  || : 2>/dev/null ) #                    SET   FG color to GREEN
  #  __Y_=$( tput setf 220 || tput setaf 220 || : 2>/dev/null ) #                    SET   FG color to YELLOW
  #  __B_=$( tput setf 33  || tput setaf 33  || : 2>/dev/null ) #                    SET   FG color to BLUE
  #  __M_=$( tput setf 201 || tput setaf 201 || : 2>/dev/null ) #                    SET   FG color to MAGENTA
  #  __C_=$( tput setf 45  || tput setaf 45  || : 2>/dev/null ) #                    SET   FG color to CYAN
  #  __W_=$( tput setf 15  || tput setaf 15  || : 2>/dev/null ) #                    SET   FG color to WHITE
  ## <Background>
  #__BGK_=$( tput setb 243 || tput setab 243 || : 2>/dev/null ) #                    SET   BG color to BLACK
  #__BGR_=$( tput setb 196 || tput setab 196 || : 2>/dev/null ) #                    SET   BG color to RED
  #__BGG_=$( tput setb 34  || tput setab 34  || : 2>/dev/null ) #                    SET   BG color to GREEN
  #__BGY_=$( tput setb 220 || tput setab 220 || : 2>/dev/null ) #                    SET   BG color to YELLOW
  #__BGB_=$( tput setb 33  || tput setab 33  || : 2>/dev/null ) #                    SET   BG color to BLUE
  #__BGM_=$( tput setb 201 || tput setab 201 || : 2>/dev/null ) #                    SET   BG color to MAGENTA
  #__BGC_=$( tput setb 45  || tput setab 45  || : 2>/dev/null ) #                    SET   BG color to CYAN
  #__BGW_=$( tput setb 15  || tput setab 15  || : 2>/dev/null ) #                    SET   BG color to WHITE

  fi

  # <pseudo Foreground-bold>
  __EMK_=$__EM_$__K_                                          # [ 1;    20m         SET   FG color to BOLD BLACK
  __EMR_=$__EM_$__R_                                          # [ 1;    21m         SET   FG color to BOLD RED
  __EMG_=$__EM_$__G_                                          # [ 1;    22m         SET   FG color to BOLD GREEN
  __EMY_=$__EM_$__Y_                                          # [ 1;    23m         SET   FG color to BOLD YELLOW
  __EMB_=$__EM_$__B_                                          # [ 1;    24m         SET   FG color to BOLD BLUE
  __EMM_=$__EM_$__M_                                          # [ 1;    25m         SET   FG color to BOLD MAGENTA
  __EMC_=$__EM_$__C_                                          # [ 1;    26m         SET   FG color to BOLD CYAN
  __EMW_=$__EM_$__W_                                          # [ 1;    27m         SET   FG color to BOLD RED

  #MISC (non color)
  __NL_=$( tput cud1 )



}

__tartify_reset_PS1_globs(){

  # REPOSITORY NAME
     __t4_rep=""   # repo name
    __t4_sepN=""   # dynamic separator for repo name

  # BRANCH
      #
      # TODO: explain that better !
      # __t4B=__tartify_branch()
      # T=untracked files    t=no untracked files
      # U=unstaged changes   u=no unstaged changes
      # S=staged changes     s=no staged changes
      # R=remote info        r=no remote info

      __t4_tU=""   #           Unstaged
      __t4_tuSr="" #           Staged                (stag-before-rem
      __t4_tRA=""  #           remote Ahead of
      __t4_tRD=""  #           remote behinD
      __t4_tRI=""  #           remote dIverged
      __t4_tRO=""  #           remote Ok (uptodate)
      __t4_tRN=""  #           remote None
      __t4_turS="" #           Staged                (stag-before-rem
      __t4_TU=""   #UNtracked  Unstaged
      __t4_TuSr="" #UNtracked  Staged                (stag-before-rem
      __t4_TRA=""  #UNtracked  remote Ahead of
      __t4_TRD=""  #UNtracked  remote behinD
      __t4_TRI=""  #UNtracked  remote dIverged
      __t4_TRO=""  #UNtracked  remote Ok (uptodate)
      __t4_TRN=""  #UNtracked  remote None
      __t4_TurS="" #UNtracked  Staged                (rem-before-stag

     __t4_sepB=""  # dynamic separator for branch
     __t4_merg=""  # merge infos for branch
     __t4_bare=""  # bare repository indicator


  #REMOTE
    __t4_sepR=""   # dynamic separator for remotes


  #STASH
     __t4_st=""   # stash nocount
     __t4_ST=""   # stash count
   __t4_sepS=""   # dynamic separator for stashes

  #LAST COMMIT
    __t4_sepL=""   # dynamic separator for time-last-commit
    __t4_lccan=""  # Could Commit Activity None
    __t4_lccal=""  # Could Commit Activity Low
    __t4_lccah=""  # Could Commit Activity High
    __t4_lscan=""  # Should Commit Activity None
    __t4_lscal=""  # Should Commit Activity Low
    __t4_lscah=""  # Should Commit Activity High
    __t4_lnhan=""  # No Hurry Activity None
    __t4_lnhal=""  # No Hurry Activity Low
    __t4_lnhah=""  # No Hurry Activity High


  #NOTA : all variables named __t4_D*, where * is one or more numbers
  #       are dynamically generated at `tartify` evaluation time
  #       (reserved variables for delimiters)
  #
  #       NB1: 100 delimiters should be plenty enough
  #       NB2: could have used loop
  #             for ((n=0;n<100;n++)); do eval "__t4_D$n=" ; done;
  #           but about 10 times slower

    __t4_D0=;     __t4_D1=;     __t4_D2=;     __t4_D3=;     __t4_D4=;
    __t4_D5=;     __t4_D6=;     __t4_D7=;     __t4_D8=;     __t4_D9=;
    __t4_D10=;    __t4_D11=;    __t4_D12=;    __t4_D13=;    __t4_D14=;
    __t4_D15=;    __t4_D16=;    __t4_D17=;    __t4_D18=;    __t4_D19=;
    __t4_D20=;    __t4_D21=;    __t4_D22=;    __t4_D23=;    __t4_D24=;
    __t4_D25=;    __t4_D26=;    __t4_D27=;    __t4_D28=;    __t4_D29=;
    __t4_D30=;    __t4_D31=;    __t4_D32=;    __t4_D33=;    __t4_D34=;
    __t4_D35=;    __t4_D35=;    __t4_D36=;    __t4_D38=;    __t4_D39=;
    __t4_D40=;    __t4_D41=;    __t4_D42=;    __t4_D43=;    __t4_D44=;
    __t4_D45=;    __t4_D46=;    __t4_D47=;    __t4_D48=;    __t4_D49=;
    __t4_D50=;    __t4_D51=;    __t4_D52=;    __t4_D53=;    __t4_D54=;
    __t4_D55=;    __t4_D56=;    __t4_D57=;    __t4_D58=;    __t4_D59=;
    __t4_D60=;    __t4_D61=;    __t4_D62=;    __t4_D63=;    __t4_D64=;
    __t4_D65=;    __t4_D66=;    __t4_D67=;    __t4_D68=;    __t4_D69=;
    __t4_D70=;    __t4_D71=;    __t4_D72=;    __t4_D73=;    __t4_D74=;
    __t4_D75=;    __t4_D76=;    __t4_D77=;    __t4_D78=;    __t4_D79=;
    __t4_D80=;    __t4_D81=;    __t4_D82=;    __t4_D83=;    __t4_D84=;
    __t4_D85=;    __t4_D86=;    __t4_D87=;    __t4_D88=;    __t4_D89=;
    __t4_D90=;    __t4_D91=;    __t4_D92=;    __t4_D93=;    __t4_D94=;
    __t4_D95=;    __t4_D96=;    __t4_D97=;    __t4_D98=;    __t4_D99=;


    __t4_newline_before=""
    __t4_newline_after=""
    __t4_tune=""

}

__tartify_reset_PS1_globsDEPREC(){

  # REPOSITORY NAME
  if [ "REPO" = "$1" ] ||  [ "ALL" = "$1" ]; then
     __t4_rep=""   # repo name
    __t4_sepN=""   # dynamic separator for repo name
  fi

  # BRANCH
  if [ "BRANCH" = "$1" ] ||  [ "ALL" = "$1" ]; then
      #
      # TODO: explain that better !
      # __t4B=__tartify_branch()
      # T=untracked files    t=no untracked files
      # U=unstaged changes   u=no unstaged changes
      # S=staged changes     s=no staged changes
      # R=remote info        r=no remote info

      __t4_tU=""   #           Unstaged
      __t4_tuSr="" #           Staged                (stag-before-rem
      __t4_tRA=""  #           remote Ahead of
      __t4_tRD=""  #           remote behinD
      __t4_tRI=""  #           remote dIverged
      __t4_tRO=""  #           remote Ok (uptodate)
      __t4_tRN=""  #           remote None
      __t4_turS="" #           Staged                (stag-before-rem
      __t4_TU=""   #UNtracked  Unstaged
      __t4_TuSr="" #UNtracked  Staged                (stag-before-rem
      __t4_TRA=""  #UNtracked  remote Ahead of
      __t4_TRD=""  #UNtracked  remote behinD
      __t4_TRI=""  #UNtracked  remote dIverged
      __t4_TRO=""  #UNtracked  remote Ok (uptodate)
      __t4_TRN=""  #UNtracked  remote None
      __t4_TurS="" #UNtracked  Staged                (rem-before-stag

     __t4_sepB=""  # dynamic separator for branch
     __t4_merg=""  # merge infos for branch
     __t4_bare=""  # bare repository indicator
  fi


  #REMOTE
  if [ "STASH" = "$1" ] ||  [ "ALL" = "$1" ]; then
    __t4_sepR=""   # dynamic separator for remotes
  fi


  #STASH
  if [ "STASH" = "$1" ] ||  [ "ALL" = "$1" ]; then
     __t4_st=""   # stash nocount
     __t4_ST=""   # stash count
   __t4_sepS=""   # dynamic separator for stashes
  fi

  #LAST COMMIT
  if [ "LAST" = "$1" ] ||  [ "ALL" = "$1" ]; then
    __t4_sepL=""   # dynamic separator for time-last-commit
    __t4_lccan=""  # Could Commit Activity None
    __t4_lccal=""  # Could Commit Activity Low
    __t4_lccah=""  # Could Commit Activity High
    __t4_lscan=""  # Should Commit Activity None
    __t4_lscal=""  # Should Commit Activity Low
    __t4_lscah=""  # Should Commit Activity High
    __t4_lnhan=""  # No Hurry Activity None
    __t4_lnhal=""  # No Hurry Activity Low
    __t4_lnhah=""  # No Hurry Activity High
  fi


  #NOTA : all variables named __t4_D*, where * is one or more numbers
  #       are dynamically generated a `tartify q' evaluation time
  #       (reserved variables for delimiters)
  if [ "ALL" = "$1" ]; then
    #clear __t4_D* variables
    for ((n=0;n<100;n++)); do eval "__t4_D$n=" ; done;
    __t4_newline_before=""
    __t4_newline_after=""
    __t4_tune=""
  fi

}


__tartify_init_globs(){

# Internal (RESERVED)


# External TARTIFY PARAMETERS : adapt to your needs

#-------------------------------------------------------
# GLOBAL

export TARTIFY_SETTING_FORCE=""                         # A string containing tartify command-line params. If non empty, will
                                                        # overwrite any arguments the tartify command receives
export TARTITUNE_SETTING_FORCE="false"                  # "true" : bypass TARTIFY_SETTING_FORCE during a tartitune session
export TARTITUNE_SETTING_LAST=""                        # saves last tartitune session
export TARTITUNE_SETTING_GROUNDZERO=""                  # save tartify settings before beginning a new tartitune session
#TODO: allow empty separator (' ' should not be default)
export TARTIFY_STRING_MISC_SEPARATOR=""                      # Default separator to be used with mono-character options (tartify
export TARTIFY_STRING_MISC_SEPARATOR="--"                      # Default separator to be used with mono-character options (tartify

#-------------------------------------------------------
# TIME
# //COMMIT-WISE
export TARTIFY_SETTING_TIME_BUGME=TRUE                  # Non empty : will color and style the 'time since last commit' string
export TARTIFY_SETTING_TIME_DISPLAY=LONG                # LONG (min, hours, days) SHORT (mine | hours | days) CHAR (cf. next var)

[ "true" = $supports8 ] && {
export TARTIFY_STRING_TIME_DISPLAY="⟳ "                 # String to display in case prec. var == CHAR
} || {
export TARTIFY_STRING_TIME_DISPLAY="◉ "                 # String to display in case prec. var == CHAR
}

                                                        # Uncommited changes (staged, unstaged)
export TARTIFY_SETTING_TIME_COULDCOMMIT=14400           #     *     nb seconds after which you COULD  commit (default is 4 hours)
export TARTIFY_SETTING_TIME_SHOULDCOMMIT=86400          #     * Max nb seconds after which you SHOULD commit (default is 1 day)

                                                        # styles applied to the 'time elapsed since last commit'
                                                        # string, in case of uncommited changes
export TARTIFY_STYLE_TIME_COULDCOMMIT=${__UN_}          #                                  UNDERLINED
export TARTIFY_STYLE_TIME_SHOULDCOMMIT=${__EM_}${__UN_} #                           BOLD UNDERLINED



# //ACTIVITY-WISE
export TARTIFY_SETTING_TIME_LOWACTIVITY=604800          #     *     nb seconds after which ACTIVITY is considered low (default is  7 days)
export TARTIFY_SETTING_TIME_MEDIUMACTIVITY=86400        #     * Max nb seconds after which ACTIVITY is considered medium (default is  1 day)
                                                        # colors applied to the 'time elapsed since last commit'
                                                        # string in case of no uncommited changes
export TARTIFY_COLOR_TIME_ACTIVITY_HIGH=${__G_}         #                                  GREEN
export TARTIFY_COLOR_TIME_ACTIVITY_LOW=${__Y_}          #                                  YELLOW
export TARTIFY_COLOR_TIME_ACTIVITY_NONE=${__R_}         #                                  RED

#-------------------------------------------------------
#BRANCH
export TARTIFY_STRING_BRANCH_DOTGIT="GIT_DIR!"                 # "branch name" replacement string for .git directory
export TARTIFY_STRING_BRANCH_BARE="BARE:"                      # "branch name" replacement string for bare .git directory
export TARTIFY_COLOR_BRANCH_BARE=$__EMW_                       # "branch name" replacement string for bare .git directory

#Branch style : Untracked files
export TARTIFY_STYLE_BRANCH_UNTRACKED=${__UN_}                 # Untracked Files                  UNDERLINED

# Branch COLOR : first 2 chars
export TARTIFY_COLOR_BRANCH_UNSTAGED=${__EMR_}          # unstaged changes (first char)    BOLD RED
export TARTIFY_COLOR_BRANCH_STAGED=${__EMM_}            # staged changes   (2nd char)      BOLD MAGENTA
# Branch COLOR : remaining chars
export TARTIFY_COLOR_BRANCH_UPSTREAM_DIVERGE=${__K_}  # tracked remot diverg from HEAD   BOLD DARK GREY
export TARTIFY_COLOR_BRANCH_UPSTREAM_BEHIND=${__R_}     # tracked remote ahead of HEAD     RED
export TARTIFY_COLOR_BRANCH_UPSTREAM_AHEAD=${__Y_}      # tracked remote behind HEAD       YELLOW
export TARTIFY_COLOR_BRANCH_UPSTREAM_UPTODATE=${__G_}   # tracked remote == HEAD           GREEN
export TARTIFY_COLOR_BRANCH_UPSTREAM_NOTRACK=${__B_}    # no remote tracking branch        BLUE
                                                        # NB: this is also the color used when
                                                        # tartify does not display 'upstream' info in branch

export TARTIFY_COLOR_BRANCH_NOCOMMITYET=${__W_}         # empty repo, no commit yet        WHITE
export TARTIFY_COLOR_BRANCH_GITDIR=${__C_}              # inside .git dir                  CYAN

#Branch color : additional info
export TARTIFY_COLOR_BRANCH_MERGEINFOS=${__RV_}${__EMR_} # color for the merge/rebase/cherry-pick/bisect status of current branch (if any)
                                                        #                                  BOLD RED

# Tartify shows U (Unstaged state), S (Staged state) and P (uPstream state,
# ahead, behind, diverged, uptodate) directly in the branch name. This
# can be tuned for lisibility's sake
export TARTIFY_SETTING_BRANCH_STAGED_INFO=              # empty     -> (unstaged)UPSTREAM[staged]
                                                        # non-empty -> (unstaged)[staged]UPSTREAM
export TARTIFY_SETTING_BRANCH_STAGED_INFOLENGTH=2       # How many letters of resulting branchname are to be colored with
                                                        # the "unstaged" and "staged" markers
# Example:
#     () for      unstaged,      [] for      staged,     rest: upstream info
#
#     $TARTIFY_SETTING_BRANCH_STAGED_INFO empty
#     $TARTIFY_SETTING_BRANCH_STAGED_INFOLENGTH =
#     0 : master    1 : (m)aste[r]    2 : (ma)st[er]    3 : (mas)[ter]    4 : (mas)[ter]    ,...
#     0 : feature   1 : (f)eatur[e]   2 : (fe)atu[re]   3 : (fea)t[ure]   4 : (fea)t[ure]   ,...
#
#     $TARTIFY_SETTING_BRANCH_STAGED_INFO non-empty
#     $TARTIFY_SETTING_BRANCH_STAGED_INFOLENGTH =
#     0 : master    1 : (m)[a]ster    2 : (ma)[st]er    3 : (mas)[ter]    4 : (mas)[ter]    ,...


#-------------------------------------------------------
# REPOSITORY
export TARTIFY_COLOR_REPO_NAME=${__K_}                  # repository's "name"              DIM GREY

#-------------------------------------------------------
# REMOTES
export TARTIFY_STRING_REMOTE_NAME_ORIGIN="O"            # marker for remote repo called 'origin'
export TARTIFY_STRING_REMOTE_NAME_UPSTREAM="U"          # marker for remote repo called 'upstream'
export TARTIFY_STRING_REMOTE_NAME_OTHER="⇧ "            # generic marker for remote repo
export TARTIFY_STRING_REMOTE_COUNT_SEP="/"              # separator for ahead/behind count

export TARTIFY_STRING_REMOTE_TRACKING="➝ "              # marker for tracked branch
export TARTIFY_COLOR_REMOTE_NAME_ORIGIN=${__G_}         # repository's "name"              GREEN
export TARTIFY_COLOR_REMOTE_NAME_UPSTREAM=${__M_}       # repository's "name"              MAGENTA
export TARTIFY_COLOR_REMOTE_NAME_OTHER=${__Y_}          # repository's "name"              YELLOW


export TARTIFY_COLOR_REMOTE_COUNT_AHEAD=${__G_}         # nb commits ahead of remote       GREEN
export TARTIFY_COLOR_REMOTE_COUNT_BEHIND=${__R_}        # nb commits behind of remote      RED


#-------------------------------------------------------
# STASH
export TARTIFY_SETTING_STASH_COUNT=                    # non empty: print 1 $TARTIFY_STRING_STASH per existing stash
                                                        # (WARN: this is slow process, add ~50ms computing time)
[ "true" = $supports8 ] && {
#export TARTIFY_STRING_STASH="☆ "                        # marker for stash
export TARTIFY_STRING_STASH="•"                         # marker for stash
} || {
export TARTIFY_STRING_STASH="*"                         # marker for stash
}
export TARTIFY_COLOR_STASH_NOCOUNT=${__Y_}              # color when not counting          YELLOW
export TARTIFY_COLOR_STASH_COUNT=${__EMY_}              # color in "count mode"            BOLD YELLOW

#-------------------------------------------------------
# UNPARSED CHARS
export TARTIFY_COLOR_MISC_DELIMITER=${__K_}             # color for (unparsed) delimiters  DIM GREY


#-------------------------------------------------------
# MENU

export TARTIFY_COLOR_MENU_BORDER=$__B_

[ "true" = $supports8 ] && {
  export TARTIFY_STRING_MENU_TOPLEFT="┌"
  export TARTIFY_STRING_MENU_TOP="─"
  export TARTIFY_STRING_MENU_TOPRIGHT="┐"
  export TARTIFY_STRING_MENU_LEFT="│"
  export TARTIFY_STRING_MENU_RIGHT="│"
  export TARTIFY_STRING_MENU_BOTTOMLEFT="└"
  export TARTIFY_STRING_MENU_BOTTOM="─"
  export TARTIFY_STRING_MENU_BOTTOMRIGHT="┘"
} || {
  export TARTIFY_STRING_MENU_TOPLEFT=" "
  export TARTIFY_STRING_MENU_TOP="_"
  export TARTIFY_STRING_MENU_TOPRIGHT=" "
  export TARTIFY_STRING_MENU_LEFT=" "
  export TARTIFY_STRING_MENU_RIGHT=" "
  export TARTIFY_STRING_MENU_BOTTOMLEFT=" "
  export TARTIFY_STRING_MENU_BOTTOM="_"
  export TARTIFY_STRING_MENU_BOTTOMRIGHT=" "
  #export TARTIFY_STRING_MENU_TOPLEFT="┌"
  #export TARTIFY_STRING_MENU_TOP="="
  #export TARTIFY_STRING_MENU_TOPRIGHT="┐"
  #export TARTIFY_STRING_MENU_LEFT="│"
  #export TARTIFY_STRING_MENU_RIGHT="│"
  #export TARTIFY_STRING_MENU_BOTTOMLEFT="└"
  #export TARTIFY_STRING_MENU_BOTTOM="="
  #export TARTIFY_STRING_MENU_BOTTOMRIGHT="┘"
}

#-------------------------------------------------------
# TODO: (restrict that to OLDSCHOOL)
# The usual environment variables from git-completion.bash still apply
# in "OLDSCHOOL" mode
#
#     GIT_PS1_SHOWDIRTYSTATE
#     GIT_PS1_SHOWSTASHSTATE
#     GIT_PS1_SHOWUNTRACKEDFILES
#     GIT_PS1_SHOWUPSTREAM
}


#------------------------------------------------------------------------------
#
#             ORIGINAL __git_ps1 FUNCTIONS (tuned to tartify)
#
#------------------------------------------------------------------------------
#
# following functions are copy/paste of the original functions from
# bash-completion.sh, slightly tuned for tartify.
#
#    __tartify__git_ps1_find_upstream   *CLONES*    first part of __git_ps1_show_upstream
#    __tartify_git_ps1_process_remote   *CLONES*    second part of __git_ps1_show_upstream
#    __tartify_git_ps1                  *CLONES*    __git_ps1
#
# This, to ease keeping compatibility with original __git_ps1(), and to
# ease updates (at the cost of spaghettying tartify's code even more
# with dynamic variable scope shit)
#
# Modifications :
#
# * local declarations moved to tartify(), as it's the root of our
#   local dynamic scope
#
# Note to self : keep chunks of code in original order to ease diffing


__tartify_git_ps1_find_upstream () {
  # fills the tartify() local variables :
  #    $upstream
  #    $verbose
  #    $legacy


  # hack to restrain the following modification to this global variable
  # to local dynamic scope, and set it to "auto" for all modes
  # but __git_ps1 compatibility mode
  local GIT_PS1_SHOWUPSTREAM=$GIT_PS1_SHOWUPSTREAM
  [ "OLDSCHOOL" = "$mode" ] || GIT_PS1_SHOWUPSTREAM="auto"
  #[ "OLDSCHOOL" = "$mode" ] || GIT_PS1_SHOWUPSTREAM="auto verbose"


  # ----- BEGIN __git_ps1_show_upstream chunk -----
  local key value
  local svn_remote=() svn_url_pattern count n
  #local upstream=git legacy="" verbose=""

  # get some config options from git-config
  while read key value; do
    case "$key" in
    bash.showupstream)
      GIT_PS1_SHOWUPSTREAM="$value"
      if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]] && [ "OLDSCHOOL" = "$mode" ]; then
        p=""
        return
      fi
      ;;
    svn-remote.*.url)
      svn_remote[ $((${#svn_remote[@]} + 1)) ]="$value"
      svn_url_pattern+="\\|$value"
      upstream=svn+git # default upstream is SVN if available, else git
      ;;
    esac
  done < <(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')

  # parse configuration values
  for option in ${GIT_PS1_SHOWUPSTREAM}; do
    case "$option" in
    git|svn) upstream="$option" ;;
    verbose) verbose=1 ;;
    legacy)  legacy=1  ;;
    esac
  done

  # Find our upstream
  case "$upstream" in
  git)    upstream="@{upstream}" ;;
  svn*)
    # get the upstream from the "git-svn-id: ..." in a commit message
    # (git-svn uses essentially the same procedure internally)
    local svn_upstream=($(git log --first-parent -1 \
          --grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null))
    if [[ 0 -ne ${#svn_upstream[@]} ]]; then
      svn_upstream=${svn_upstream[ ${#svn_upstream[@]} - 2 ]}
      svn_upstream=${svn_upstream%@*}
      local n_stop="${#svn_remote[@]}"
      for ((n=1; n <= n_stop; ++n)); do
        svn_upstream=${svn_upstream#${svn_remote[$n]}}
      done

      if [[ -z "$svn_upstream" ]]; then
        # default branch name for checkouts with no layout:
        upstream=${GIT_SVN_ID:-git-svn}
      else
        upstream=${svn_upstream#/}
      fi
    elif [[ "svn+git" = "$upstream" ]]; then
      upstream="@{upstream}"
    fi
    ;;
  esac
  # ----- END   __git_ps1_show_upstream chunk -----


}


__tartify_git_ps1_process_remote () {
  # by default, processes the value of $upstream (tartify()'s scope)
  # as previously set by __tartify_git_ps1_find_upstream()
  # or something else if an argument is given
  [ ${#1} -gt 0 ] && upstream=$1


  # ----- BEGIN __git_ps1_show_upstream chunk -----
  # Find how many commits we are ahead/behind our upstream
  if [ ${#legacy} == 0 ]; then
  #if [[ -z "$legacy" ]]; then
    count="$(git rev-list --count --left-right \
        "$upstream"...HEAD 2>/dev/null)"
  else
    # produce equivalent output to --count for older versions of git
    local commits
    if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"
    then
      local commit behind=0 ahead=0
      for commit in $commits
      do
        case "$commit" in
        "<"*) let ++behind
          ;;
        *)    let ++ahead
          ;;
        esac
      done
      count="$behind  $ahead"
    else
      count=""
    fi
  fi

  # calculate the result
  if [[ -z "$verbose" ]]; then
    case "$count" in
    "") # no upstream
      p="" ;;
    "0	0") # equal to upstream
      p="=" ;;
    "0	"*) # ahead of upstream
      p=">" ;;
    *"	0") # behind upstream
      p="<" ;;
    *)      # diverged from upstream
      p="<>" ;;
    esac
  else
    case "$count" in
    "") # no upstream
      p="" ;;
    "0	0") # equal to upstream
      p=" u=" ;;
    "0	"*) # ahead of upstream
      p=" u+${count#0	}" ;;
    *"	0") # behind upstream
      p=" u-${count%	0}" ;;
    *)      # diverged from upstream
      p=" u+${count#*	}-${count%	*}" ;;
    esac
  fi

  # ----- END   __git_ps1_show_upstream chunk -----
}


__tartify_git_ps1(){
  #local g="$(__gitdir)"
  if [ -n "$g" ]; then
    #local r=""
    #local b=""
    if [ -f "$g/rebase-merge/interactive" ]; then
      r="|REBASE-i"
      b="$(cat "$g/rebase-merge/head-name")"
    elif [ -d "$g/rebase-merge" ]; then
      r="|REBASE-m"
      b="$(cat "$g/rebase-merge/head-name")"
    else
      if [ -d "$g/rebase-apply" ]; then
        if [ -f "$g/rebase-apply/rebasing" ]; then
          r="|REBASE"
        elif [ -f "$g/rebase-apply/applying" ]; then
          r="|AM"
        else
          r="|AM/REBASE"
        fi
      elif [ -f "$g/MERGE_HEAD" ]; then
        r="|MERGING"
      elif [ -f "$g/CHERRY_PICK_HEAD" ]; then
        r="|CHERRY-PICKING"
      elif [ -f "$g/BISECT_LOG" ]; then
        r="|BISECTING"
      fi

      b="$(git symbolic-ref HEAD 2>/dev/null)" || {

        b="$(
        case "${GIT_PS1_DESCRIBE_STYLE-}" in
        (contains)
          git describe --contains HEAD ;;
        (branch)
          git describe --contains --all HEAD ;;
        (describe)
          git describe HEAD ;;
        (* | default)
          git describe --tags --exact-match HEAD ;;
        esac 2>/dev/null)" ||

        b="$(cut -c1-7 "$g/HEAD" 2>/dev/null)..." ||
        b="unknown"
        b="($b)"
      }
    fi

    #local w=""
    #local i=""
    #local s=""
    #local u=""
    #local c=""
    #local p=""

    if [ "true" = "$(git rev-parse --is-inside-git-dir 2>/dev/null)" ]; then
      if [ "true" = "$(git rev-parse --is-bare-repository 2>/dev/null)" ]; then
        c=$TARTIFY_STRING_BRANCH_BARE
        idaongbe="B"
      else
        b="GIT_DIR!"
        idaongbe="G"
      fi
    elif [ "true" = "$(git rev-parse --is-inside-work-tree 2>/dev/null)" ]; then
      if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] || [ "OLDSCHOOL" != "$mode" ]; then
        #TODO: !!!!! only OLDSCHOOL for this test
        if [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
          git diff --no-ext-diff --quiet --exit-code || w="*"
          if git rev-parse --quiet --verify HEAD >/dev/null; then
            git diff-index --cached --quiet HEAD -- || i="+"
          else
            i="#"
            idaongbe="E"
          fi
        fi
      fi
      if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ] || [ "OLDSCHOOL" != "$mode" ]; then
              git rev-parse --verify refs/stash >/dev/null 2>&1 && s="$"
      fi

      if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] || [ "OLDSCHOOL" != "$mode" ]; then
         if [ -n "$(git ls-files --others --exclude-standard)" ]; then
            u="%"
         fi
      fi

      if [ "true" = "$processupstream" ] && [ -n $upstream ]; then
        #no arg : processes upstream
        __tartify_git_ps1_process_remote
      fi
    fi

    f="$w$i$s$u"
    #local f="$w$i$s$u"
    #printf "${1:- (%s)}" "$c${b##refs/heads/}${f:+ $f}$r$p"
  fi

}


#------------------------------------------------------------------------------
#
#             HELPER FUNCTIONS
#
#------------------------------------------------------------------------------


__tartify_diff_count() {
#count the nb of commits between two branches of two repositorie
#   ex: __tartify_diff_count HEAD origin/master
#   ex: __tartify_diff_count upstream/dev HEAD
    echo "$(git rev-list $1..$2 2>/dev/null | awk 'END {print NR}')"
}


__tartify_usage(){
# Display the help message
  cat <<HELPTEXT

${__EMR_}NAME
     tartify${__NN_} -- One-Liner condensed GIT infos (for your prompt, screen
                statusline, ...)

${__EMR_}SYNOPSIS${__NN_}
     ${__EMR_}tartify${__NN_} [${__EMG_}option string${__NN_}]

${__EMR_}DESCRIPTION${__NN_}
     The ${__EMG_}option string${__NN_} is a CASE-SENSITIVE sequence of characters.

      * The following characters are reserved tartify commands :
         ${__Y_}0123456789ZzabBcefhilLnNopqrRsStuUvwW${__NN_} (and maybe more letters in the future)

      * any other character will be printed "as is", including spaces. You can use
      those to format the output of the tarttify command (as delimiters,...)
              \`tartify [r]b - l\` will output \"[repository]master - 12m\"

      * if you need multiple spaces, escape them \"\ \" :
              \`tartify [r]b -\ \ l\` will output \"[repository]master -  12m\"

      * following characters need to be escaped  ${__Y_}\(\)<>;*\"\'\`\#&|~${__NN_}


      ${__EMG_}Elements${__NN_}

      ${__Y_}n${__NN_}       repository ${__EMY_}n${__NN_}ame       ${__Y_}N${__NN_}   same without colors
      ${__Y_}b${__NN_}       ${__EMY_}b${__NN_}ranch name           ${__Y_}B${__NN_}          \` \`
      ${__Y_}r${__NN_}       (all)  ${__EMY_}r${__NN_}emotes  info  ${__Y_}R${__NN_}          \` \`
      ${__Y_}u${__NN_}       (only) ${__EMY_}u${__NN_}pstream info  ${__Y_}U${__NN_}          \` \`
      ${__Y_}s${__NN_}       ${__EMY_}s${__NN_}tash info            ${__Y_}S${__NN_}          \` \`
      ${__Y_}l${__NN_}       ${__EMY_}l${__NN_}ast commit info      ${__Y_}L${__NN_}          \` \`


      ${__EMG_}Modifiers${__NN_}

      ${__Y_}c${__NN_}       no${__EMY_}c${__NN_}olor      strip all colors
      ${__Y_}t${__NN_}       no ups${__EMY_}t${__NN_}ream  in branch

      ${__Y_}w${__NN_}       ne${__EMY_}w${__NN_}line     insert newline : positionnal in MENU mode
                                           at end of line  in other modes
      ${__Y_}W${__NN_}       ne${__EMY_}W${__NN_}line     prepend newline at beginning (non-positionnal)
                                          ignored in MENU mode
      ${__Y_}z${__NN_}       rever${__EMY_}z${__NN_}e     reverse color of next ${__Y_}Element${__NN_}
      ${__Y_}Z${__NN_}       rever${__EMY_}z${__NN_}e     reverse color of ALL ${__Y_}Elements${__NN_}

      ${__Y_}f${__NN_}       ${__EMY_}f${__NN_}orce       overwrite global TARTIFY_SETTING_FORCE (once)
                          (see tartitune(), tartiforce() )

      ${__EMG_}Modes${__NN_}

      ${__Y_}i${__NN_}       succ${__EMY_}i${__NN_}nt    even shorter version
      ${__Y_}a${__NN_}       ch${__EMY_}a${__NN_}tterbox looong version
      ${__Y_}q${__NN_}       ${__EMY_}q${__NN_}uiet      only update variables, no output
      ${__Y_}o${__NN_}       ${__EMY_}o${__NN_}ldschool  __git_ps1 mode
      ${__Y_}p${__NN_}       ${__EMY_}p${__NN_}s1 mode   string with escaped (\[...\])ansi escape codes
      ${__Y_}v${__NN_}       ${__EMY_}v${__NN_}im mode   result formated for the Vim tartify plugin
                         (color info appended to result)

      ${__Y_}number${__NN_}  menu mode  display result as menu
              ┌───────────────────┐
              │${__EMY_}1/4/7 ${__NN_} ${__EMY_}2/5/8${__NN_}  ${__EMY_}3/6/9${__NN_}│
              │${__EMY_}    ${__NN_}      ${__EMY_} ${__NN_}       ${__EMY_} ${__NN_}│
              │${__EMY_}    ${__NN_}      ${__EMY_} ${__NN_}       ${__EMY_}0${__NN_}│
              └───────────────────┘
              1line prompt ${__EMY_}1${__NN_} top left  ${__EMY_}2${__NN_} top middle  ${__EMY_}3${__NN_} top right
              2line prompt ${__EMY_}4${__NN_} top left  ${__EMY_}5${__NN_} top middle  ${__EMY_}6${__NN_} top right
              3line prompt ${__EMY_}7${__NN_} top left  ${__EMY_}8${__NN_} top middle  ${__EMY_}9${__NN_} top right
              ${__EMY_}0${__NN_} bottom right (one liner)

      ${__EMG_}Help${__NN_} ${__EM_}all other arguments are ignored${__NN_}

      ${__Y_}h${__NN_}     ${__EMY_}h${__NN_}elp      display this help message
      ${__Y_}e${__NN_}     ${__EMY_}e${__NN_}nv help  list customizable environment variables

${__EMR_}DEFAULT${__NN_}
     tartify   : is equivalent to ${__EM_}tartify${__EMQ_} ${__Y_}nbrsl${__NN_}
     tartify w : is equivalent to ${__EM_}tartify${__EMQ_} ${__Y_}nbrslw${__NN_}
     tartify o : is equivalent to ${__EM_}tartify${__EMQ_} ${__Y_}obsr${__NN_}

${__EMR_}SEE ALSO${__NN_}
     ${__Y_}tartitune${__NN_}  (easily tune  tartify's colors)
     ${__Y_}tartiforce${__NN_} (force overwrite any options passed to tartify)

HELPTEXT
}


__tartify_show_env() {
  #TODO: do that with less clutter, using something like :
  # echo ${!TARTIFY_*} | xargs  printf "%s\n" to list the args

  # pretty print TARTIFY environment
  echo;echo
  echo "   Tartify's ENVIRONMENT variables are currently"
  echo "   set to :"
  echo
  echo ""$__UN_"                                                         "$__NN_
  echo       "$__W_$__BGK_             PREDEFINED COLORS                           $__NN_ "
  echo       "$__UN_$__W_$__BGK_          (for use in your dotfiles)                     $__NN_ "
  echo
  local simplecols=$(\
    env | grep '^__[A-Z]\{1\}_=' | sort -df |  awk -F"=" '{printf("%s%s%s ", "\033[0m",$2,($1 "\033[0m"))}'\
  )
  printf "$__K_$__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s\n" $simplecols

  local boldcols=$(\
    env | grep '^__EM[A-Z]\{1\}_=' | sort -df |  awk -F"=" '{printf("%s%s%s ", "\033[0m",$2,($1 "\033[0m"))}'\
  )
  printf "$__K_$__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s\n" $boldcols

  local bgcols=$(\
    env | grep '^__BG[A-Z]\{1\}_=' | sort -df |  awk -F"=" '{printf("%s%s%s ", "\033[0m",$2,("\033[30m" $1 "\033[0m"))}'\
  )
  printf "$__K_$__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s\n" $bgcols

  local others=$(\
    env | grep -v '^__EM[A-Z]_\|__[A-Z]_\|__BG[A-Z]_' | grep '^__[A-Z]\{1,3\}_=' | sort -df |  awk -F"=" '{printf("%s%s%s ", "\033[0m",$2,($1 "\033[0m"))}'\
  )
  printf "$__K_$__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s\n" $others


  #printf "%6s  %0s  %10s %s %10s %s %10s %s\n" $(
  #env | grep '^__[a-zA-Z]\{1,3\}_=' | sort -df\
  #    | awk -F"=" '{printf("%'0s'%'0s'%-'8s'%'0s'", "\033[0m    ",$2,($1 "\033[0m")," ")}'\
  #    )
  echo ""$__UN_"                                                         "$__NN_
  echo       "$__UN_$__W_$__BGK_                  STRINGS                                $__NN_"
  echo
  env | grep "^TARTIFY_STRING_" | sort -df \
      | awk -F"=" '{printf("%'11s'%-'15s'%-'29s'%'0s'\n", "\033[0m    ",$2,$1," ")}'
  echo ""$__UN_"                                                         "$__NN_
  echo       "$__UN_$__W_$__BGK_                  SETTINGS                               $__NN_"
  echo
  env | grep "^TARTIFY_SETTING" | sort -df \
      | awk -F"=" '{printf("%'11s'%-'15s'%-'29s'%'0s'\n", "\033[0m    ",$2,$1," ")}'
  echo ""$__UN_"                                                         "$__NN_
  echo       "$__UN_$__W_$__BGK_                  STYLES                                 $__NN_ "
  echo
  env | grep "^TARTIFY_STYLE" | sort -df \
      | awk -F"=" '{printf("%'11s'%'0s'%-'48s'%'0s'\n", "\033[0m    ",$2,($1 "\033[0m")," ")}'
  echo ""$__UN_"                                                         "$__NN_
  echo       "$__UN_$__W_$__BGK_                  COLORS                                 $__NN_ "
  echo
  env | grep "^TARTIFY_COLOR" | sort -df \
      | awk -F"=" '{printf("%'11s'%'0s'%-'48s'%'0s'\n", "\033[0m    ",$2,($1 "\033[0m")," ")}'
  echo;echo
  echo $__NN_"   \`tartify help\` for more";
  echo $__NN_"   \`tartitune help\` for more";
}


__tartify_build_PS1() {
  #WARN: this is called from within the PS1 string, hence we're in a
  #      subshell -> no exporting
  local argstr="$*"

  local before=""
  local after=""

  #force dynamic separator if need be
  [ -z "$forceDefaultSep" ] || {
    separator=$TARTIFY_STRING_MISC_SEPARATOR
    [ -z "$separator" ] && separator=' '
  }



  [[ "$argstr" =~ W ]] && printf "%s" '$__t4_newline_before'

        # tartitune session
        printf "%s" '\['$__EMR_'\]$__t4_tune\[$__NN_\]'

  local firstn="true" #don't insert dynamic separator ($__t4_sep*) before first item
  local delimNb=0     #delimiter's position
  for ((n=0;n<${#argstr};n++))
  do
    local ch=${argstr:$n:1}
    case $ch in
      n)
        #REPO NAME
        [ -z $firstn ] && [ ! -z "$separator" ] && printf "%s" '$__t4_sepN'
        printf "%s" '\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_REPO_NAME'\]$__t4_rep'
        printf "%s" '\['$__NN_'\]'
        ;;
      b)
        #BRANCH
        [ -z $firstn ] && [ ! -z "$separator" ] && printf "%s" '$__t4_sepB'
        printf "%s" '\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_BARE'\]$__t4_bare'

        #no untracked files
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UNSTAGED'\]$__t4_tU''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_STAGED'\]$__t4_tuSr''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_AHEAD'\]$__t4_tRA''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_BEHIND'\]$__t4_tRD''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_DIVERGE'\]$__t4_tRI''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_UPTODATE'\]$__t4_tRO''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_NOTRACK'\]$__t4_tRN''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_STAGED'\]$__t4_turS''\['$__NN_'\]'

        #untracked files
        printf "%s" '\['$TARTIFY_STYLE_BRANCH_UNTRACKED'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UNSTAGED'\]$__t4_TU''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_STAGED'\]$__t4_TuSr''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_AHEAD'\]$__t4_TRA''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_BEHIND'\]$__t4_TRD''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_DIVERGE'\]$__t4_TRI''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_UPTODATE'\]$__t4_TRO''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_NOTRACK'\]$__t4_TRN''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_STAGED'\]$__t4_TurS'
        printf "%s" '\['$__NN_'\]'

        #merge infos
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_MERGEINFOS'\]$__t4_merg'
        printf "%s" '\['$__NN_'\]'
        ;;
      r)
        #REMOTES
        [ -z $firstn ] && [ ! -z "$separator" ] && printf "%s" '$__t4_sepR'
        printf "%s" '\['$__NN_'\]'

        printf "%s" '\['$__NN_'\]'
        ;;
      u)
        #UPSTREAM ONLY
        [ -z $firstn ] && [ ! -z "$separator" ] && printf "%s" '$__t4_sepR'
        printf "%s" '\['$__NN_'\]'

        printf "%s" '\['$__NN_'\]'
        ;;
      s)
        #STASHES
        [ -z $firstn ] && [ ! -z "$separator" ] && printf "%s" '$__t4_sepS'
        printf "%s" '\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_STASH_NOCOUNT'\]$__t4_st'
        printf "%s" '\['$TARTIFY_COLOR_STASH_COUNT'\]$__t4_ST'
        printf "%s" '\['$__NN_'\]'
        ;;
      l)
        #LAST COMMIT
        [ -z $firstn ] && [ ! -z "$separator" ] && printf "%s" '$__t4_sepL'
        printf "%s" '\['$__NN_'\]'
        #COULD COMMIT
        printf "%s" '\['$TARTIFY_STYLE_TIME_COULDCOMMIT'\]'
        printf "%s" '\['$TARTIFY_COLOR_TIME_ACTIVITY_NONE'\]$__t4_lccan'
        printf "%s" '\['$TARTIFY_COLOR_TIME_ACTIVITY_LOW'\]$__t4_lccal'
        printf "%s" '\['$TARTIFY_COLOR_TIME_ACTIVITY_HIGH'\]$__t4_lccah'
        printf "%s" '\['$__NN_'\]'
        #SHOULD COMMIT
        printf "%s" '\['$TARTIFY_STYLE_TIME_SHOULDCOMMIT'\]'
        printf "%s" '\['$TARTIFY_COLOR_TIME_ACTIVITY_NONE'\]$__t4_lscan'
        printf "%s" '\['$TARTIFY_COLOR_TIME_ACTIVITY_LOW'\]$__t4_lscal'
        printf "%s" '\['$TARTIFY_COLOR_TIME_ACTIVITY_HIGH'\]$__t4_lscah'
        printf "%s" '\['$__NN_'\]'
        # NO HURRY
        printf "%s" '\['$TARTIFY_COLOR_TIME_ACTIVITY_NONE'\]$__t4_lnhan'
        printf "%s" '\['$TARTIFY_COLOR_TIME_ACTIVITY_LOW'\]$__t4_lnhal'
        printf "%s" '\['$TARTIFY_COLOR_TIME_ACTIVITY_HIGH'\]$__t4_lnhah'
        printf "%s" '\['$__NN_'\]'
        ;;
      c) ;;
      o) ;;
      p) ;;
      f) ;;
      i) ;;
      a) ;;
      q) ;;
      t) ;;
      v) ;;
      w) ;;
      W) ;;
      0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) ;;
      #TODO: make that issue ansi escapes (PS1 and standard mode)
      \\) ;;
      #TODO: make that work with PS1 and NOCOLORS
      #*) printf "%s" '\['$TARTIFY_COLOR_MISC_DELIMITER'\]'$ch'\['$__NN_'\]';;
      *)
        #Delimiters will be generated and stored dynamically in __t4_D* variables for each
        #call of 'tartify q'
        printf "%s" '\['$TARTIFY_COLOR_MISC_DELIMITER'\]$__t4_D'$delimNb'\['$__NN_'\]'
        delimNb=$((delimNb + 1))
        ;;
    esac
    unset firstn
  done


  printf "%s" '\['$__NN_'\]'

  [[ "$argstr" =~ w ]] && printf "%s" '$__t4_newline_after'

  #TODO: newline insertion


}


__tartify_popup ()
{

  #  position the 'tartify()' result on the screen
  #   ┌───────────────┐
  #   │1      2      3│
  #   │4      5      6│
  #   │7      8      9│
  #   │               │
  #   │               │
  #   │       9      0│
  #   └───────────────┘

  #TODO: next test is not necessary
  #[ -z "$menuPos" ] && menuPos="3" #default : top right corner


  #result=$(tartify "n/b - l");
  local border=$__NN_$__B_;
  tput sc;
  if [ -z "$tartanswer" ]; then
    :;
  else
    local stripansi=$(printf "%s" "$tartanswer" | perl -pe 's/\e\[?.*?[\@-~]//g');
    local resLength=$((${#stripansi} + 4));
    local menuBorderTop=$(printf "%s" "$stripansi""##" | tr "[:print:]" $TARTIFY_STRING_MENU_TOP);
    local menuBorderBottom=$(printf "%s" "$stripansi""##" | tr "[:print:]" $TARTIFY_STRING_MENU_BOTTOM);

    local blankLine=$(printf "%s" "$stripansi""####")
    blankLine=$(printf "%${#blankLine}s")
    ##much slower alternative :
    #local blankLine=$(printf "%s" $stripansi"    " | tr "[:print:]" ' ');

    local firstC=
    local firstL=
    local oneliner=
    local additLines=
    local sttysize=
    local nlines=
    local ncol=

    sttysize=$(stty size 2>/dev/null)
    [ $? -eq 0 ]  && {
      nlines=${sttysize%% *}
      ncol=${sttysize##* }
    } || {
      nlines=$(tput lines);
      ncol=$(tput cols);
    }


    case $menuPos in

      1) firstL=0                 ; firstC=0                                              ;;
      2) firstL=0                 ; firstC=$(( ($ncol - $resLength)/2 ))                  ;;
      3) firstL=0                 ; firstC=$((  $ncol - $resLength ))                     ;;
      4) firstL=1                 ; firstC=0                            ; additLines=1    ;;
      5) firstL=1                 ; firstC=$(( ($ncol - $resLength)/2 )); additLines=1    ;;
      6) firstL=1                 ; firstC=$((  $ncol - $resLength ))   ; additLines=1    ;;
      7) firstL=2                 ; firstC=0                            ; additLines=2    ;;
      8) firstL=2                 ; firstC=$(( ($ncol - $resLength)/2 )); additLines=2    ;;
      9) firstL=2                 ; firstC=$((  $ncol - $resLength ))   ; additLines=2    ;;
      0) firstL=$(( $nlines - 1 )); firstC=$((  $ncol - $resLength ))   ; oneliner="true" ;;

    esac

    [ -z $additLines ] || {
      [ 2 -le $additLines ] && {
      tput cup $(($firstL - 2)) $firstC;
        printf "%s" "$__NN_$blankLine";
      }

      [ 1 -le $additLines ] && {
      tput cup $(($firstL - 1)) $firstC;
        printf "%s" "$__NN_$blankLine";
      }
    }

    [ -z $oneliner ] && {
      tput cup $firstL $firstC;
      printf "%s" "$TARTIFY_COLOR_MENU_BORDER$TARTIFY_STRING_MENU_TOPLEFT$menuBorderTop$TARTIFY_STRING_MENU_TOPRIGHT$__NN_";
      tput cup $(($firstL + 1)) $firstC;
      printf "%s" "$TARTIFY_COLOR_MENU_BORDER$TARTIFY_STRING_MENU_LEFT$__NN_" "$tartanswer" "$TARTIFY_COLOR_MENU_BORDER$TARTIFY_STRING_MENU_RIGHT$__NN_";
      tput cup $(($firstL + 2)) $firstC;
      printf "%s" "$TARTIFY_COLOR_MENU_BORDER$TARTIFY_STRING_MENU_BOTTOMLEFT$menuBorderBottom$TARTIFY_STRING_MENU_BOTTOMRIGHT$__NN_";
    } || {
      tput cup $(($firstL )) $(($firstC + 4));
      printf "%s" $__NN_$tartanswer$__NN_;
    }


    tput rc;
    #echo "stty-size=$(stty size) - nlines=$nlines ($(tput lines)) - ncol=$ncol ($(tput cols)) - firstL=$firstL - firstC=$firstC - resLength=$resLength - stripansi=$stripansi - menuBorder=["$menuBorder"]"
  fi;
  #echo "nlines=$nlines - ncol=$ncol - firstL=$firstL - firstC=$firstC - resLength=$resLength - stripansi=$stripansi - menuBorder=["$menuBorder"]"
  #stty size
}


__tartify_reformat_timestamp(){
# prints a relative-formatted time string from unix timestamp
# arg: unix timestamp in seconds
# optional arg: true to include coloring
# copied from https://github.com/xtrementl/dev-bash-git-ps1.git
    local secs="$1"
    local yrs="$(( $secs / 31557600 ))"
    local div="$(( $secs % 31557600 ))"
    local days="$(( div / 86400 ))"
    div="$(( $secs % 86400 ))"
    local hrs="$(( $div / 3600 ))"
    div="$(( $secs % 3600 ))"
    local mins="$(( $div / 60 ))"

    # create the formatted time string
    [ 0 -lt "$yrs" ] && timestr="${yrs}y"
    [ -n "$timestr" ] && [ "SHORT" = $TARTIFY_SETTING_TIME_DISPLAY ] && return 0
    if [ 0 -lt "$days" ]; then
        [ -n "$timestr" ] && timestr="$timestr,"
        timestr="${timestr}${days}d"
        [ -n "$timestr" ] && [ "SHORT" = $TARTIFY_SETTING_TIME_DISPLAY ] && return 0
    fi
    if [ 0 -lt "$hrs" ]; then
        [ -n "$timestr" ] && timestr="$timestr,"
        timestr="${timestr}${hrs}h"
        [ -n "$timestr" ] && [ "SHORT" = $TARTIFY_SETTING_TIME_DISPLAY ] && return 0
    fi
    [ -n "$timestr" ] && timestr="${timestr},"
    timestr="${timestr}${mins}m"

}


#------------------------------------------------------------------------------
#
#             TARTIFY commands
#
# All the following functions are intended for use from the tartify command and
# assume we are inside a GIT repository.
#
#------------------------------------------------------------------------------


__tartify_repo_name()
{
  [ "QUIET" = "$mode" ]     && __tartify_reset_PS1_globs "REPO"
  local updir=""
  [ $isbare = "false" ] && updir="/.." #don't go 1 level up for bare repo
  local color
  local nocolor

  # Print the REPO's name
  color=$TARTIFY_COLOR_REPO_NAME
  nocolor=$(echo `cd $g$updir; pwd` | sed 's,.*/,,' | tr -d '\n')
  color=$color$nocolor
  color=$color"${__NN_}"

  [ "QUIET" = "$mode" ] && { __t4_rep=$nocolor; [ -z $__t4_rep ] || __t4_sepN="$separator"; }
  [ "true" = $nocolors ] &&   tartanswer=$tartanswer$nocolor || tartanswer=$tartanswer$color
  #[ "true" = $nocolors ] &&   echo "nocolors true" || echo "nocolors false"
  #echo " [REPONAME before leaving] nocolor=$nocolor tartanswer=$tartanswer"
}


__tartify_branch(){
  # OLDSCHOOL _mode : output the same exact string __git_ps1 would
  #
  # VIM _mode
  #
  #   Return value:
  #
  #       $nci\|$branchname\|$merge_status
  #
  #     nci =~ /[U]?[S]?[IDAONGBE][T]?/    (nci : no colors info)
  #
  #        [U]nstaged modif(s)
  #
  #        [S]taged modif(s)
  #
  #       d[I]verged from remote
  #   behin[D] remote
  #        [A]head of remote
  #        [O]K (remote == HEAD)
  #        [N]o tracked remote
  #        [G]it directory
  #        [B]are repository
  #        [E]mpty repository
  #
  #        un[T]racked files,
  #
  #     merge_infos : either one of these values, or "" :
  #
  #        REBASE-i, REBASE-m, REBASE, AM, AM/REBASE, MERGING, CHERRY-PICKING,
  #        BISECTING
  #
  # QUIET _mode
  #
  # PS1 _mode
  #
  #   will use on-the-fly variable-NAMES creation
  #
  #     TOTO=2
  #     TATA=TO
  #     TITI=$(eval "printf "%s" "\$${TATA}TO"")
  case $mode in

    OLDSCHOOL)
      local f="$w$i$s$u"
      #printf "%s" "$c${b##refs/heads/}${f:+ $f}$r$p"
      tartanswer=$tartanswer$c${b##refs/heads/}${f:+ $f}$r$p
      #
      #printf "%s" "$c   ${b##refs/heads/}${f:+ $f}$r$p"
      #             $c   $b               $w       $i     $s    $u        $r           $p
      #             BARE:master           unstaged staged stash untracked rebase/merge upstream
      #
      #             [ branch name ]       [red]    [**]   [OLDSC] [underl] [??]
    ;;

    VIM)
      #IDAONGBE : SGBE already taken care of by __tartify_git_ps1()
      #          Determine AON (tracking branch info)
      #
      #          As S overrides all other IDAONGBE states, begin with this:
      case $p in
        '<>') idaongbe="I"  ;;
        '<')  idaongbe="D"  ;;
        '>')  idaongbe="A"  ;;
        '=')  idaongbe="O"  ;;
        *)    idaongbe="N"  ;;
      esac
      #NOCOLORSINFOS ($nci)
      local nci=$idaongbe
      [ -n "$w" ]      && nci=$nci"U"  #unstaged
      [ "+" =  "$i" ]  && nci=$nci"S"  #staged
      [ -n "$u" ]      && nci=$nci"T"  #untracked
      #RESULT
      tartanswer=$tartanswer$nci"|"${b##refs/heads/}$r #$r already includes the "|" separator
    ;;


    #HANDLED SEPARATELY
    PS1)
    ;;

    #__t4_tU=""   #           Unstaged
    #__t4_tuSr="" #           Staged                (stag-before-rem
    #__t4_tRA=""  #           remote Ahead of
    #__t4_tRD=""  #           remote behinD
    #__t4_tRI=""  #           remote dIverged
    #__t4_tRO=""  #           remote Ok (uptodate)
    #__t4_tRN=""  #           remote None
    #__t4_turS="" #           Staged                (stag-before-rem
    #__t4_TU=""   #UNtracked  Unstaged
    #__t4_TuSr="" #UNtracked  Staged                (stag-before-rem
    #__t4_TRA=""  #UNtracked  remote Ahead of
    #__t4_TRD=""  #UNtracked  remote behinD
    #__t4_TRI=""  #UNtracked  remote dIverged
    #__t4_TRO=""  #UNtracked  remote Ok (uptodate)
    #__t4_TRN=""  #UNtracked  remote None
    #__t4_TurS="" #UNtracked  Staged                (rem-before-stag

    #TODO: *) would be better
    NORMAL | QUIET | SHORT | LONG)
      local bname=${b##refs/heads/}
      local bnameL=${#bname}

      [ "QUIET" = "$mode" ] && __tartify_reset_PS1_globs "BRANCH"

      # determine "remote info" color
      local prefix=""  # stores prefix for dynamic '__t4_' variable generation (QUIET mode)
      local bColRemote="" # stores color used in NORMAL mode
      case $p in
        '<>')  bColRemote=$TARTIFY_COLOR_BRANCH_UPSTREAM_DIVERGE  ; prefix="I" ;;
         '<')  bColRemote=$TARTIFY_COLOR_BRANCH_UPSTREAM_BEHIND   ; prefix="D" ;;
         '>')  bColRemote=$TARTIFY_COLOR_BRANCH_UPSTREAM_AHEAD    ; prefix="A" ;;
         '=')  bColRemote=$TARTIFY_COLOR_BRANCH_UPSTREAM_UPTODATE ; prefix="O" ;;
           *)  bColRemote=$TARTIFY_COLOR_BRANCH_UPSTREAM_NOTRACK  ; prefix="N" ;;
      esac
      local colUntracked=
      [ -n "$u" ] && colUntracked=$TARTIFY_STYLE_BRANCH_UNTRACKED

      # concatenate some
      local Unst=$TARTIFY_COLOR_BRANCH_UNSTAGED$colUntracked
      local Stag=$TARTIFY_COLOR_BRANCH_STAGED$colUntracked
      local Remo=$bColRemote$colUntracked

      local ll=$TARTIFY_SETTING_BRANCH_STAGED_INFOLENGTH
      local remaind
      local res1=""; local res2=""; local res3=""

      # CASE1 both Staged and Unstaged changes
      if [ -n "$w" ] && [ "+" = "$i" ]; then
          remaind=$(($bnameL - ((2 * $ll)) ))
          [ $(($remaind <= 0)) -eq 1  ] && { remaind=$(($bnameL % 2)); ll=$(($bnameL / 2)) ; }

          [ -z $TARTIFY_SETTING_BRANCH_STAGED_INFO ] && {
              #URS [m]aste[r],[ma]st[er] ,[mas][ter], ...
              res1=${bname:0:$ll}
              res2=${bname:$ll:$remaind}
              res3=${bname:(($remaind + $ll )):$ll}
              [ "QUIET" = "$mode" ] && {
                  #update PS1 vars
                  [ -n "$u" ] &&  { __t4_TU=$res1; eval "__t4_TR$prefix=\$res2" ; __t4_TurS=$res3; } ||
                                  { __t4_tU=$res1; eval "__t4_tR$prefix=\$res2" ; __t4_turS=$res3; }
              } || {
                  #colors for NORMAL mode
                  res1=$Unst$res1; res2=$Remo$res2; res3=$Stag$res3$__NN_
              }
          } || {
              #USR [m][a]ster, [ma][st]er, [mas][ter], ...
              res1=${bname:0:$ll}
              res2=${bname:$ll:$ll}
              res3=${bname:(($ll * 2)):$remaind}
              [ "QUIET" = "$mode" ] && {
                  #update PS1 vars
                  [ -n "$u" ] &&  { __t4_TU=$res1; __t4_TuSr=$res2; eval "__t4_TR$prefix=\$res3"; } ||
                                  { __t4_tU=$res1; __t4_tuSr=$res2; eval "__t4_tR$prefix=\$res3"; }
              } || {
                  #colors for NORMAL mode
                  res1=$Unst$res1; res2=$Stag$res2; res3=$Remo$res3$__NN_
              }
          }

      # CASE2 only Unstaged changes
      elif [ -n "$w" ]; then
          remaind=$(($bnameL -  $ll))
          [ $(($remaind <= 0)) -eq 1  ] && { remaind=1; ll=$(($bnameL - 1)) ; }

          #URS & UR (m)aster,(ma)ster ,(mas)ter, ...
          res1=${bname:0:$ll}
          res2=${bname:$ll:$remaind}
          [ "QUIET" = "$mode" ] && {
              #update PS1 vars
              [ -n "$u" ] &&  { __t4_TU=$res1; eval "__t4_TR$prefix=\$res2"; } ||
                              { __t4_tU=$res1; eval "__t4_tR$prefix=\$res2"; }
          } || {
              #colors for NORMAL mode
              res1=$Unst$res1; res2=$Remo$res2$__NN_
          }

      # CASE3 only Staged changes
      elif [ "+" = "$i" ]; then
          remaind=$(($bnameL -  $ll  ))
          [ $(($remaind <= 0)) -eq 1  ] && { remaind=1; ll=$(($bnameL - 1)) ; }
          [ -z $TARTIFY_SETTING_BRANCH_STAGED_INFO ] && {
              #RS maste[r],mast[er] ,mas[ter], ...
              res1=${bname:0:$remaind}
              res2=${bname:$remaind:$ll}
              [ "QUIET" = "$mode" ] && {
                  #update PS1 vars
                  [ -n "$u" ] &&  { eval "__t4_TR$prefix=\$res1" ; __t4_TurS=$res2; } ||
                                  { eval "__t4_tR$prefix=\$res1" ; __t4_turS=$res2; }
              } || {
                  #colors for NORMAL mode
                  res1=$Remo$res1; res2=$Stag$res2$__NN_
              }
          } || {
              #SR [m]aster, [ma]ster, [mas]ter, ...
              res1=${bname:0:$ll}
              res2=${bname:$ll:$remaind}
              [ "QUIET" = "$mode" ] && {
                  #update PS1 vars
                  [ -n "$u" ] &&  { __t4_TuSr=$res1; eval "__t4_TR$prefix=\$res2"; } ||
                                  { __t4_tuSr=$res1; eval "__t4_tR$prefix=\$res2"; }
              } || {
                  #colors for NORMAL mode
                  res1=$Stag$res1; res2=$Remo$res2$__NN_
              }
          }
      # CASE4 no changes in index
      else
        res1=$bname
        [ "QUIET" = "$mode" ] && {
            #update PS1 vars
            [ -n "$u" ] &&  { eval "__t4_TR$prefix=\$res1"; } ||
                            { eval "__t4_tR$prefix=\$res1"; }
          } || {
              #colors for NORMAL mode
              res1=$Remo$res1$__NN_
          }
      fi

      [ "QUIET" = "$mode" ] && {
          #dynamic separator in QUIET mode
          [ ! -z $bname ] && __t4_sepB="$separator"
          #mergeinfos
          [ ! -z $r ] && __t4_merg=$r
          #bare
          [ ! -z $c ] && __t4_bare=$c
      }

      # All Modes
      tartanswer=$tartanswer$c$res1$res2$res3$TARTIFY_COLOR_BRANCH_MERGEINFOS$r$__NN_

    ;;



  esac

  return 0

}


__tartify_remote2(){
  [ "OLDSCHOOL" = "$mode" ] && return 0
  return 0
}


__tartify_remote()
{
  # OLDSCHOOL :
  #
  #    #:no upstream

  local _gitdir=$1
  local _nocolors=$2   #TRUE for no color
  local color
  local nocolor

  local branchname=$(git branch 2>/dev/null| sed -n '/^\*/s/^\* //p')
  color="  "$__NN_

  # NON-EMPTY GIT REPO
  # VERIFY that .git/refs/heads/ directory is not empty
  if [ $(ls $_gitdir/refs/heads/ | wc -l) -gt 0 ]
  then

    # ------- REMOTES INFO ( + BRANCH TRACKED ) --------
    local marker
    local marker_color
    local before_traked
    local after_tracked
    local before_untraked
    local after_untracked

    # loop through remotes
    for remotename in $(git remote show); do

      # special markers for origin and upstream
      # nb: a tracked remote is preceded by a little ➝ symbol
      case $remotename in
          origin)   marker="O"; marker_color=$TARTIFY_COLOR_REMOTE_NAME_ORIGIN   ;;
        upstream)   marker="U"; marker_color=$TARTIFY_COLOR_REMOTE_NAME_UPSTREAM ;;
                *)   marker="⇧"; marker_color=$TARTIFY_COLOR_REMOTE_NAME_OTHER    ;;
      esac

      # CURRENT BRANCH is tracked to CURRENT REMOTE ?
      if [[ $(git config --get branch.$branchname.remote) =~ $remotename ]]
      then
        [ "true" = $_nocolors ]  &&  {
                              before_traked=" ➝ "; after_tracked="";
                              before_untraked=" "; after_untracked="";
                            } || {
                              before_traked=" ➝${__EM_} "; after_tracked="${_EMQ_}";
                              before_untraked=" "; after_untracked="";
                            }
      else
        before_traked=""; after_tracked="";before_traked=" "; after_tracked="";
      fi


      # nb of commits AHEAD/BEHIND
      local ahead_count="$(__tartify_diff_count $remotename/$branchname HEAD)"
      local behind_count="$(__tartify_diff_count HEAD $remotename/$branchname)"
      local diffcount=""
      local diffcountnocol=""
      if [ 0 -lt "$ahead_count" ]; then
          diffcount="${TARTIFY_COLOR_REMOTE_COUNT_AHEAD}${ahead_count}"
          diffcountnocol="+${ahead_count}"
      fi

      if [ 0 -lt "$behind_count" ]; then
          [ -n "$diffcount" ] && {
                  diffcount=${diffcount}${marker_color}$TARTIFY_STRING_REMOTE_COUNT_SEP
                  diffcountnocol=${diffcountnocol}$TARTIFY_STRING_REMOTE_COUNT_SEP
                }
          diffcount="${diffcount}${TARTIFY_COLOR_REMOTE_COUNT_BEHIND}${behind_count}"
          diffcountnocol="${diffcountnocol}-${behind_count}"
      fi

      [ -n "$diffcount" ] && diffcount=" ${marker_color}($diffcount${marker_color}) "
      [ -n "$diffcountnocol" ] && diffcountnocol=" ($diffcountnocol) "
      #echo "$diffcount"


      color=$color"${marker_color}${before_traked}${marker}${after_tracked}${diffcount}${__NN_}"
      nocolor=$nocolor"${before_traked}${marker}${after_tracked}${diffcountnocol}"

    done
  fi

  [ "true" = $_nocolors ] &&  echo -ne $nocolor || echo -e $color

 #TODO: oldschool
      #if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
      #  __git_ps1_show_upstream
      #fi

}


#optimized
__tartify_stash()
{
  [ "OLDSCHOOL" = "$mode" ] && return 0
  [ "QUIET" = "$mode" ]     && __tartify_reset_PS1_globs "STASH"

  local color
  local nocolor
  #? are we inside a GIT repo's working tree
  if [ "true" = "$isinsideworktree" ]; then
    if [ "true" = "$hasstash" ]; then
    if [ -n "$TARTIFY_SETTING_STASH_COUNT" ]; then
        # One star per stash
        color=$TARTIFY_COLOR_STASH_COUNT
        #nocolor="  "
        local n
        #! `git stash list | wc -l` adds about 50ms
        for (( n=0; n< $(git stash list | wc -l); n++ ))
        do
          nocolor=$nocolor$TARTIFY_STRING_STASH
        done
        #nocolor=$nocolor" "
        [ "QUIET" = "$mode" ] && __t4_ST=$nocolor
      else
        color=$TARTIFY_COLOR_STASH_NOCOUNT
        nocolor=$TARTIFY_STRING_STASH
        [ "QUIET" = "$mode" ] && __t4_st=$nocolor
      fi
      color=$color$nocolor${__NN_}
    fi
    [ "true" = $nocolors ] &&   tartanswer=$tartanswer$nocolor || tartanswer=$tartanswer$color
  fi
}


__tartify_timelastcommit(){
  [ "QUIET" = "$mode" ]     && __tartify_reset_PS1_globs "LAST"

  #TODO: COLORS !!!!!!!
  local color
  local nocolor

  # calc relative time diff of last commit
  local secs="$(
    # get the unix timestamp for the lastest commit (seconds)
    # copied from https://github.com/xtrementl/dev-bash-git-ps1.git
        local now="$(date +%s)"
        local last_commit="$(git log --format='%at' -1 2>/dev/null)"
        if [ -z "$last_commit" ]; then # probably initial git init, no commits
            return
        fi
        if [ 0 -lt "$now" ] && [ 0 -lt "$last_commit" ]; then
            echo "$((now - last_commit))"
        fi
  )"
  #TODO: include $nocolors
  if [ -n "$secs" ]; then
    local timestr
    [ "CHAR" = $TARTIFY_SETTING_TIME_DISPLAY ] && timestr=$TARTIFY_STRING_TIME_DISPLAY ||
        __tartify_reformat_timestamp $secs #fills in timestr

    # Compute colors
    if [ "false" = $nocolors ]; then
      local color
      if [ "QUIET" = "$mode" ]; then

        [ -n "$TARTIFY_SETTING_TIME_BUGME" ] && [ -n "$w$i" ] && { # $w:unstaged changes, $i: staged changes
            if [ $TARTIFY_SETTING_TIME_COULDCOMMIT -gt "$secs" ]; then
                if [ $TARTIFY_SETTING_TIME_LOWACTIVITY -lt "$secs" ]; then __t4_lnhan=${timestr}
                elif [ $TARTIFY_SETTING_TIME_MEDIUMACTIVITY -lt "$secs" ]; then __t4_lnhal=${timestr}
                else __t4_lnhah=${timestr}
                fi
            elif [ $TARTIFY_SETTING_TIME_SHOULDCOMMIT -gt "$secs" ]; then
                if [ $TARTIFY_SETTING_TIME_LOWACTIVITY -lt "$secs" ]; then __t4_lccan=${timestr}
                elif [ $TARTIFY_SETTING_TIME_MEDIUMACTIVITY -lt "$secs" ]; then __t4_lccal=${timestr}
                else __t4_lccah=${timestr}
                fi
            else
                if [ $TARTIFY_SETTING_TIME_LOWACTIVITY -lt "$secs" ]; then __t4_lscan=${timestr}
                elif [ $TARTIFY_SETTING_TIME_MEDIUMACTIVITY -lt "$secs" ]; then __t4_lscal=${timestr}
                else __t4_lscah=${timestr}
                fi
            fi
        } || {
                if [ $TARTIFY_SETTING_TIME_LOWACTIVITY -lt "$secs" ]; then __t4_lnhan=${timestr}
                elif [ $TARTIFY_SETTING_TIME_MEDIUMACTIVITY -lt "$secs" ]; then __t4_lnhal=${timestr}
                else __t4_lnhah=${timestr}
                fi
        }


      else
        # STYLES
        [ -n "$TARTIFY_SETTING_TIME_BUGME" ] && [ -n "$w$i" ] && { # $w:unstaged changes, $i: staged changes
            if [ $TARTIFY_SETTING_TIME_COULDCOMMIT -gt "$secs" ]; then
              :
            elif [ $TARTIFY_SETTING_TIME_SHOULDCOMMIT -gt "$secs" ]; then
                color=$TARTIFY_STYLE_TIME_COULDCOMMIT
            else color=$TARTIFY_STYLE_TIME_SHOULDCOMMIT
            fi
        }
        # COLORS
        if [ $TARTIFY_SETTING_TIME_LOWACTIVITY -lt "$secs" ]; then
            color=$color$TARTIFY_COLOR_TIME_ACTIVITY_NONE
        elif [ $TARTIFY_SETTING_TIME_MEDIUMACTIVITY -lt "$secs" ]; then
            color=$color$TARTIFY_COLOR_TIME_ACTIVITY_LOW
        else color=$color$TARTIFY_COLOR_TIME_ACTIVITY_HIGH
        fi

        timestr="${color}${timestr}${__NN_}"

      fi
    fi


    tartanswer="$tartanswer$timestr"
  fi
}

#------------------------------------------------------------------------------
#
#             TARTIFY
#
#------------------------------------------------------------------------------


tartify()
{
#TODO: distinguish between FAST and SLOW modes to try and bypass a
#      maximum tests (VIM, OLDSCHOOL, ...)

  local argstr="$*"
  local forceDefaultSep=""


  # (optionnal) paramater expansion
  if [ ${#argstr} -lt 3 ]; then
    #expand optionless tartify
    if [ ${#argstr} -eq 0 ]; then
      argstr="nbrsl"                            #no args
    #expand some mono-character options
    elif [ ${#argstr} -eq 1 ]; then
      case "$argstr" in
        o) argstr="ob";   forceDefaultSep=true   ;; #oldschool
        v) argstr="vnbrsl"                       ;; #vim
        p) argstr="pnbrsl"; forceDefaultSep=true ;; #PS1
        q) argstr="qnbrsl"; forceDefaultSep=true ;; #QUIET mode
        w) argstr="nbrslw"                       ;; #newline after
        W) argstr="nbrslW"                       ;; #newline before
      esac
    #expand some 2-characters options
    else
      case "$argstr" in
        wW) argstr="nbrslwW"                      ;; #newline BOTH
        Ww) argstr="nbrslwW"                      ;; #newline BOTH
        #TODO: '1w', '3q',...
      esac
    fi
  fi

  # -- PARSE help options and exit --
  # do that first to enable testing if 'tartify' is present with exit
  # value of zero
  [[ "$argstr" =~ h ]] && { __tartify_usage; return 0; }
  [[ "$argstr" =~ e ]] && { __tartify_show_env; return 0; }

  # PS1 building (done here because it has to work wether wether we're
  # in a GIT dir or not
  [[ "$argstr" =~ p ]] && { __tartify_build_PS1 $argstr; return 0; }

  # Override args with $TARTIFY_SETTING_FORCE if $argstr is non empty,
  # and there's no 'f' (force) option in the command line args, and
  # we're not in VIM mode
  [[ "$argstr" =~ f ]] || {
      [ -n "$TARTIFY_SETTING_FORCE" ] && {
          # ignore FORCE in VIM mode
          [[ "$argstr" =~ v ]] || argstr=$TARTIFY_SETTING_FORCE
        }
  }


  # -- INIT tartify local vars --
  local tartanswer=""
  local isbare="false"
  local isinsideworktree="false"
  local hasstash="false"
  local hasupstream="false"
  local nocolors="false"
  local mode="NORMAL"
  local menuPos=""

  local staged_info=""  # (VIM mode) branch status - store either one of these letters (US)
  local idaongbe=""     # (VIM mode) branch status - store either one of these letters (IDAONGBE)
  local pre_idaongbe="" # (VIM mode) branch status - store either one of these letters (US)
                        # used by __tartify_branch()

  local upstream=git legacy="" verbose=""  # moved here from original __git_ps1_showupstream
  local processupstream="false"  # check if current branch is tracked to a remote, and ahead/behind state
                                 # used by __tartify_branch()
                                 #         __tartify_remote()

  local processremotes="false"   # used by __tartify_remote()

  # -- INIT __git_ps1 locals --
  local g=""   #GITDIR
  local r=""   #REBASE/MERGE/... info
  local b=""   #BRANCH
  local w=""   #UNSTAGED indicator "*"
  local i=""   #STAGED indicator "+"  or NO COMMIT YET in HEAD "#"
  local s=""   #STASH state $
  local u=""   #UNTRACKED files %
  local f=""   #"$w$i$s$u"  UNSTAGED STAGED STASH UNTRACKED
  local c=""   #BARE: prefix to $b (BRANCH)
  local p=""   #UPSTREAM info || empty string


  # -- BAIL if not INSIDE a GIT REPO --
  g=`git rev-parse --git-dir 2>/dev/null`
  [ $? -eq 0  ] && {

    #load optionnal config file (if we're not in the middle of a tartitune session)
    [ "false" = $TARTITUNE_SETTING_FORCE ] && [ -z $TARTIFY_SETTING_FORCE ] && [ -f ~/.tartifyrc ] && . ~/.tartifyrc

    #TODO: DEPREC ????
    #Perform all cheap 'git' tests (used in more than one '__tartify_*' function)
    isbare=$( git rev-parse --is-bare-repository 2>/dev/null )
    isinsideworktree=$(git rev-parse --is-inside-work-tree 2>/dev/null)
    if [ "true" = "$isinsideworktree" ]; then
      git rev-parse --verify refs/stash >/dev/null 2>&1 && hasstash="true"
    fi
    git rev-list  @{upstream}...HEAD >/dev/null 2>&1                  # 8ms
    [ $? -eq 0 ] && hasupstream="true" || hasupstream="false"




    #TODO: make this work
    local separator=
    #force default ' ' separator if need be
    [ -z "$forceDefaultSep" ] || {
      separator=$TARTIFY_STRING_MISC_SEPARATOR
      [ -z "$separator" ] && separator=' '
    }

    local n
    #
    # PRE-PARSING (modes)
    #
    for ((n=0;n<${#argstr};n++))
    do
      local ch=${argstr:$n:1}
      case $ch in

        # -- MODES --

        # No Colors MODE : strip all color info, whatever the result
        c)  nocolors="true"         ;;
        # Vim MODE : no color, prepend color infos for 'branch', use 'vimsplitsep' as separator
        v)
          nocolors="true"
          mode="VIM"
          # don't fucking change that:
          separator="vimsplitsep"
                                    ;;
        # OldSchool MODE : no color, branch results with $*+, stash results with %
        o)
          nocolors="true"
          mode="OLDSCHOOL"
                                    ;;
        # Quiet mode (only update the __TART4PS1* variables)
        # ($tartanswer is discarded)
        q) mode="QUIET"
           #__t4_del=$__NN_
                                    ;;

        # PS1 mode (ansi color codes escaped with '\[' and '\]' for PS1
        p) mode="PS1"               ;;

        # SUCCINT (SHORT) mode
        i) mode="SHORT"             ;;

        # CHATTERBOX (LOOONG) mode
        a) mode="LONG"              ;;

        0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 )
           menuPos=$ch
                                    ;;
        # -- MODAL ARGS --

        u|U) processupstream="true" ;;

        r|R) processupstream="true"
             processremotes="true"  ;;

        b) #no upstream calculation in branch with 't' (no upstream), 'c' (no color) and 'v' (VIM mode)
             [[ "$argstr" =~ v ]] || [[ "$argstr" =~ c ]] || [[ "$argstr" =~ t ]] ||  processupstream="true"
                                    ;;
        #l) #time since last commit
        #   [ -n "$TARTIFY_SETTING_TIME_BUGME" ] && processupstream="true"
        #                            ;;
        o) [ -n "${GIT_PS1_SHOWUPSTREAM-}" ] && processupstream="true" ;; #oldschool

        # -- MODIFIERS --
        t) processupstream="false"  ;;
      esac
    done

    #
    # PRE-PROCESSING
    #

    # fill $upstream if any
    [ "true" = "$processupstream" ] && __tartify_git_ps1_find_upstream

    # Fill in __git_ps1 locals
    __tartify_git_ps1

    #
    # PROCESSING
    #
    #TODO: cache already done calculations ? (tartify nb-n-b)
    #(might be totally stupid)
    local firstn="true" #don't insert separator before first item
    local delimNb=0     #delimiter's position
    tartanswer=""
    for ((n=0;n<${#argstr};n++))
    do
      [ -z $firstn ] && [ ! -z "$separator" ] && tartanswer="$tartanswer$separator"

      local ch=${argstr:$n:1}
      case $ch in
        n) __tartify_repo_name      ;;
        b) __tartify_branch         ;;
        #TODO:
        r) tartanswer=$tartanswer$( __tartify_remote2 );;
        #TODO:
        #u) tartanswer=$tartanswer$( __tartify_remote    $g                                           $nocolors);;
        s) __tartify_stash          ;;
        #TODO:
        l) __tartify_timelastcommit ;;
        0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) ;;
        c) ;;
        o) ;;
        p) ;;
        f) ;;
        i) ;;
        a) ;;
        q) ;;
        t) ;;
        v) ;;
        w) ;;
        W) ;;
        #TODO: make that issue ansi escapes (PS1 and standard mode)
        \\) tartanswer=$tartanswer$TARTIFY_COLOR_MISC_DELIMITER$ch$__NN_;;
        #TODO: make that work with PS1 and NOCOLORS
        *)
          tartanswer=$tartanswer$TARTIFY_COLOR_MISC_DELIMITER$ch$__NN_

          if [ "QUIET" = $mode ]; then
            [ " " = "$ch" ] && eval "__t4_D$delimNb=\" \"" || eval "__t4_D$delimNb=\"$ch\""
          fi
          delimNb=$((delimNb + 1))
          ;;
      esac
      unset firstn
    done

    # Post Process

    # tartitune session
    [ "true" = $TARTITUNE_SETTING_FORCE ] && {
        tartanswer="($__EMR_*$__NN_)"$tartanswer
        __t4_tune="(*)"
      } || {
        __t4_tune=
      }

    # VIM mode : remove first occurence of $separator
    [ "$mode" = "VIM" ] && tartanswer=${tartanswer/#vimsplitsep/}

    # -- OUTPUT --

    # TODO: this test sucks (time lost in subshell)
    # remove ansi escapes
    # TODO: Make that linux compatible (sed -E is bsd)
    local testforblank=$(echo  $tartanswer | sed -E "s/\\\\033\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g")
    # variant : sed 's/\[[0-9;]*m//g'
    # variant2 : perl -pe 's/\e\[?.*?[\@-~]//g'
    #  (http://unix.stackexchange.com/questions/4527/program-that-passes-stdin-to-stdout-with-color-codes-stripped/4533#4533)
    #
    testforblank=${testforblank/ //}

    # 1 - QUIET MODE
    if [ "QUIET" = "$mode" ]; then
      [ ${#testforblank} != 0 ] && {
        [[ "$argstr" =~ W ]] &&  __t4_newline_before=$(echo -ne "\n ")
        [[ "$argstr" =~ w ]] &&  __t4_newline_after=$(echo -ne "\n ")
      }
       return 0
    fi

    # 2 - MENU MODIFIER
    if [ ! -z $menuPos ]; then
      [ ${#testforblank} != 0 ] && {
          __tartify_popup
          #( __tartify_popup & )
      }
       return 0
    fi

    # 3 - OTHER MODEs
    #TODO: 'w' newline insertion can happen anywhere, 'W' only at BOL
    # only do something if answer is not empty
    [ ${#testforblank} != 0 ] && {
      [[ "$argstr" =~ W ]] && {
        echo -ne "\n" # linebreak before
      }
      echo -ne $tartanswer
      [[ "$argstr" =~ w ]] && {
        echo -ne "\n" # linebreak after
      }
    }
  } || __tartify_reset_PS1_globs ALL

  return 0
}


#------------------------------------------------------------------------------
#
#             TARTIFY ADDONS
#
#------------------------------------------------------------------------------


tartitune(){
  # Quick tuner for tartify's COLOR-RELATED environment variables
  # (with completion)

  #save tartify() environment before beginning a tartitune session
  [ -z "$TARTITUNE_SETTING_GROUNDZERO" ] && TARTITUNE_SETTING_GROUNDZERO=$(env | grep "^TARTIFY_" | sort)


  local myargs=$(echo "$*" | tr '[A-Z]' '[a-z]' | tr '-' ' ' | sed 's/tartify_//g')
  [ -z "$myargs" ] && { tartify e; return 0; }
  local myansw
  local action
  local myarg
  local myenv

  for myarg in $myargs; do
    case $myarg in

      # ENV VARS
      style_*|color_*) myenv=$myenv$myarg" "
                                       ;;

      # STYLES
      bold|emphasized)   myansw=$myansw$__EM_ ;;  underlined)        myansw=$myansw$__UN_ ;;
      i*)        myansw=$myansw$__RV_  ;;

      # COLORS
      black)     myansw=$myansw$__K_   ;;  red)        myansw=$myansw$__R_  ;;
      green)     myansw=$myansw$__G_   ;;  yellow)     myansw=$myansw$__Y_  ;;
      blue)      myansw=$myansw$__B_   ;;  magenta)    myansw=$myansw$__M_  ;;
      cyan)      myansw=$myansw$__C_   ;;  white)      myansw=$myansw$__W_  ;;

      # BACKGROUND COLORS
      bgblack)   myansw=$myansw$__BGK_ ;;  bgred)      myansw=$myansw$__BGR_;;
      bggreen)   myansw=$myansw$__BGG_ ;;  bgyellow)   myansw=$myansw$__BGY_;;
      bgblue)    myansw=$myansw$__BGB_ ;;  bgmagenta)  myansw=$myansw$__BGM_;;
      bgcyan)    myansw=$myansw$__BGC_ ;;  bgwhite)    myansw=$myansw$__BGW_;;

      # SETTINGS
      bugme)     action="b"            ;;
      timelong)  action="L"            ;;
      timeshort)  action="S"            ;;
      timechar)  action="C"            ;;

      # MISC
      test)      action="t"            ;;
      export)    action="e"            ;;
      quit)      action="q"            ;;
      last)      action="l"            ;;
      nuke)      action="n"            ;;

      # HELP
      h|help|?) cat <<HELPMSG

${__EMR_}NAME
     tartitune${__NN_} -- Quick color changer for ${__EM_}tartify${__NN_}

${__EMR_}SYNOPSIS${__NN_}
     ${__EMR_}tartitune${__NN_} [${__EMR_}-SHORTNAME${__NN_}][${__EMG_}TARTIFY_* ...${__NN_}][${__EMG_}compound${__NN_}]

${__EMR_}DESCRIPTION${__NN_}
     The order of command line arguments doesn't matter. When used
     without arguments, ${__EMR_}tartitune${__NN_} pretty prints a list of
     ALL ${__EMR_}tartify${__NN_} environment variables with their current value
     (same as \`${__EMR_}tartify${__NN_} e\`)

     The options have the following meaning:

     ${__EMG_}TARTIFY_*${__NN_}
           any sequence of TARTIFY_COLOR_... or TARTIFY_STYLE_...
           environment variables, by full name (eg: TARTIFY_COLOR_BRANCH_STAGED)
                -> case insensitive
                -> run ${__EMR_}tartitune${__NN_} without any argument to get a complete
                   list of ALL ${__EMR_}tartify${__NN_} environment variables with their
                   current value)
                -> use ${__EMG_}T+completion${__NN_} to loop through ${__EM_}full${__NN_} names

     ${__EMR_}-SHORTNAME${__NN_}
           any sequence of TARTIFY_COLOR or TARTIFY_STYLE
           environment variables, by short name (eg: -COLOR_STAGED),
           prefixed with a ${__Y_}single-dash${__NN_}

            -> case insensitive
            -> use ${__EMG_}dash+completion${__NN_} to loop through ${__Y_}short${__NN_} names

           If no environement variable is specified, ${__EMR_}tartitune${__NN_}
           will print the compound color corresponding to ${__EMG_}compound${__NN_}
           to STDOUT

     ${__EMG_}compound${__NN_}  a list of any of the following words (case insensitive,
           use completion to loop through)

        ${__EMG_}*${__NN_} ${__G_}colors & styles${__NN_}
           ${__EM_}bold${__NN_}    ${__EM_}emphasized${__NN_} ${__UN_}underlined${__NN_} ${__RV_}inverse${__NN_}

           ${__K_}black${__NN_}   ${__R_}red${__NN_}        ${__G_}green${__NN_}     ${__Y_}yellow${__NN_}
           ${__B_}blue${__NN_}    ${__M_}magenta${__NN_}    ${__C_}cyan${__NN_}      ${__W_}white${__NN_}

           ${__BGK_}BGblack${__NN_} ${__BGR_}BGred${__NN_}      ${__K_}${__BGG_}BGgreen${__NN_}   ${__K_}${__BGY_}BGyellow${__NN_}
           ${__K_}${__BGB_}BGblue${__NN_}  ${__K_}${__BGM_}BGmagenta${__NN_}  ${__K_}${__BGC_}BGcyan${__NN_}    ${__K_}${__BGW_}BGwhite${__NN_}

        ${__EMG_}*${__NN_} ${__G_}Other${__NN_} ${__EM_}${__NN_}
           ${__G_}test${__NN_}      Doesn't modify any environment variable, just simulates.

           ${__G_}export${__NN_}    Save the current ${__EMR_}tartify${__NN_} environment in ~/.tartitunebak
                     (WARN: will overwrite previous .tartitunebak silently).
                     Move ~/.tartitunebak to ~/.tartifyrc to make that the
                     default ${__EMR_}tartify${__NN_} environment.
           ${__G_}nuke${__NN_}      Replace ~/.tartifyrc with the current ${__EMR_}tartify${__NN_}
                     environment
           ${__G_}last${__NN_}      Revert to latest ${__EMR_}tartitune${__NN_} environment
           ${__G_}quit${__NN_}      Exit ${__EMR_}tartitune${__NN_} session (discard changes)

           ${__G_}bugme${__NN_}     switch TARTIFY_SETTING_TIME_BUGME setting on/off
           ${__G_}timelong${__NN_}  set    TARTIFY_SETTING_TIME_DISPLAY setting to LONG
           ${__G_}timeshort${__NN_} set    TARTIFY_SETTING_TIME_DISPLAY setting to SHORT
           ${__G_}timechar${__NN_}  set    TARTIFY_SETTING_TIME_DISPLAY setting to CHAR

${__EMR_}INDICATOR${__NN_}

      As soon as a ${__EMR_}tartify${__NN_} parameter is modified with ${__EMR_}tartitune${__NN_} and/or
      ${__EMR_}tartiforce${__NN_}, and as long as the ${__G_}quit${__NN_} option is not called,
      an indicator will appear at the beginning of all ${__EMR_}tartify${__NN_}
      results : (${__EMR_}*${__NN_})

${__EMR_}LIMITATIONS${__NN_}

      ${__EMR_}tartitune${__NN_} won't have visible effects on ${__EMR_}tartify${__NN_} in PS1 mode as
      the colors in PS1 are hardcoded at PS1 creation time. However, the
      indicator will be present. In which case, use ${__EMR_}tartify${__NN_} from the
      command line to see the effects of ${__EMR_}tartitune${__NN_}

      ${__EMR_}tartitune${__NN_} is limited to setting COLOR and STYLE related
      '${__EMR_}tartify${__NN_} variables'

${__EMR_}SEE ALSO${__NN_}
      tartify, tartiforce
${__EMR_}EXAMPLES${__NN_}

      ${__K_}\$ tartitune TARTIFY_COLOR_BRANCH_STAGED bold magenta${__NN_}
      ${__K_}\$ tartitune -COLOR_BRANCH_STAGED bold blue underline verbose${__NN_}
      TARTIFY_COLOR_BRANCH_STAGED (${__EMM_}was${__NN_}) (${__EMB_}${__UN_}now is${__NN_})
      ${__K_}\$ tartitune -COLOR_BRANCH_STAGED -COLOR_BRANCH_UPTODATE r i test${__NN_}
      TARTIFY_COLOR_BRANCH_STAGED (${__EMB_}${__UN_}was${__NN_}) (${__EMR_}${__RV_}*TEST*${__NN_})
      TARTIFY_COLOR_BRANCH_UPSTREAM_UPTODATE (${__EMG_}was${__NN_}) (${__EMR_}${__RV_}*TEST*${__NN_})
      ${__K_}\$ tartitune test bold cyan${__NN_}
      ${__EMC_}*TEST*${__NN_}
      ${__K_}\$ tartitune un yellow; echo \"colored string\"${__NN_}
      ${__Y_}${__UN_}colored string${__NN_}
      ${__K_}\$ MYENVVAR=\$(tartitune bo r); echo \$MYENVVAR\"colored string\"${__NN_}
      ${__EMR_}colored string${__NN_}

HELPMSG
        return 0                      ;;

     *) echo "Unknown argument $myarg"
        return 1
                                      ;;
    esac
  done;


  # -- COLOR/STYLE --
  [ -n "$myenv" ] && {
        # WITH ENV
        local thisenv
        for thisenv in $myenv; do
            thisenvUP="TARTIFY_"$(echo $thisenv | tr '[a-z]' '[A-Z]')
            [ -n "$myansw" ] && {
                printf "\n%s" "$thisenvUP ($(eval printf "%s" "\$$thisenvUP")was$__NN_)"
                [ "t" = "$action" ] && printf " %s\n" " (${myansw}*TEST*$__NN_)"|| {
                    printf " %s\n" " (${myansw}now is$__NN_)"
                    #ASSIGN env variable
                    eval "$thisenvUP=$myansw"
                    TARTITUNE_SETTING_FORCE="true"
                }
            } || {
                printf "\n%s\n" "no option set."
                printf "%s\n" "$thisenvUP ($(eval printf "%s" "\$$thisenvUP")is$__NN_)"
            }
        done
        echo
  } || {
      # NO ENV
      [ "t" = "$action" ] && printf "%s\n" "${myansw}*TEST*$__NN_" ||
        printf "%s" "${myansw}"
  }

  case $action in

    #  -- SETTINGS --
    b)  [ -z $TARTIFY_SETTING_TIME_BUGME ] && { 
        TARTIFY_SETTING_TIME_BUGME="TRUE"
        TARTITUNE_SETTING_FORCE="true"
        echo "time display ${__EMG_}will include${__NN_} ${TARTIFY_STYLE_TIME_COULDCOMMIT}could${__NN_}/${TARTIFY_STYLE_TIME_SHOULDCOMMIT}should${__NN_} commit styles"
      } || {
        TARTIFY_SETTING_TIME_BUGME=
        TARTITUNE_SETTING_FORCE="true"
        echo "time display ${__EMR_}won't include${__NN_} ${TARTIFY_STYLE_TIME_COULDCOMMIT}could${__NN_}/${TARTIFY_STYLE_TIME_SHOULDCOMMIT}should${__NN_} commit styles"
    }
        ;;
    L)  TARTIFY_SETTING_TIME_DISPLAY="LONG"
        TARTITUNE_SETTING_FORCE="true"
        echo "time display set to ${__EMG_}LONG${__NN_}"
        ;;
    S)  TARTIFY_SETTING_TIME_DISPLAY="SHORT"
        TARTITUNE_SETTING_FORCE="true"
        echo "time display set to ${__EMG_}SHORT${__NN_}"
        ;;
    C)  TARTIFY_SETTING_TIME_DISPLAY="CHAR"
        TARTITUNE_SETTING_FORCE="true"
        echo "time display set to ${__EMG_}CHAR${__NN_}"
        ;;

    # -- MISC --
    #export
    e)
        env | grep "^TARTIFY_" | sort > ~/.tartitunebak
        echo "current$__EMR_ tartify$__NN_ environment exported to ~/.tartunebak"
        ;;

    #nuke : save current in ~/.tartifyrc
    n)
        TARTITUNE_SETTING_FORCE="false"
        TARTITUNE_SETTING_LAST=""
        TARTITUNE_SETTING_GROUNDZERO=""
        env | grep "^TARTIFY_" | sort > ~/.tartifyrc
        echo "current$__EMR_ tartify$__NN_ environment exported to ~/.tartifyrc"
        return 0
        ;;

    #quit : exit without saving, revert to original env
    q)
        __tartitune_reset
        return 0
        ;;

    l)
        eval $TARTITUNE_SETTING_LAST;
        TARTITUNE_SETTING_FORCE="true";
        ;;
  esac

  TARTITUNE_SETTING_LAST=$(env | grep "^TARTIFY_" | sort)

}


__tartitune_completion()
{
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    optsVARLONG="${!TARTIFY_COLOR*} ${!TARTIFY_STYLE*}"
    optsVAR=$( echo $optsVARLONG |  sed 's/TARTIFY_/-/g')
    ## Slower
    #optsVAR=$(env | grep "^TARTIFY_COLOR\|^TARTIFY_STYLE" | awk -F"=" '{printf("-%s ", $1)}' | sed 's/TARTIFY_//g')
    #optsVARLONG=$(env | grep "^TARTIFY_COLOR\|^TARTIFY_STYLE" | awk -F"=" '{printf("%s ", $1)}')

    optsARG="bold emphasized underlined inverse black red green yellow
    blue magenta cyan white bgblack bgred bggreen bgyellow bgblue
    bgmagenta bgcyan bgwhite quit nuke last test export help bugme
    timelong timeshort timechar"

    #if [[ ${cur} == T* ]] ; then
    if [[ ${cur} == -* ]] ; then
        COMPREPLY=( $(compgen -W "${optsVAR}" -- ${cur}) )
        return 0
    elif [[ ${cur} == T* ]] ; then
        COMPREPLY=( $(compgen -W "${optsVARLONG}" -- ${cur}) )
        return 0
    else
        COMPREPLY=( $(compgen -W "${optsARG}" -- ${cur}) )
        return 0
    fi
}


tartiforce(){
  [ -z "$*" ] && {
      __tartitune_reset
    } || {
      case "$*" in
        h | -h | \? | -\?)
          echo "\$*=$*"
          echo "${__EMR_}tartiforce${__NN_} : force tartify settings in
          the current ${__EMR_}tartitune${__NN_} session"
          ;;
        *)
          TARTIFY_SETTING_FORCE="$*"
          TARTITUNE_SETTING_FORCE="true"
          ;;
      esac
    }



}

__tartitune_reset(){
  TARTITUNE_SETTING_FORCE="false"
  TARTITUNE_SETTING_LAST=$(env | grep "^TARTIFY_" | sort)
  eval $TARTITUNE_SETTING_GROUNDZERO
  TARTITUNE_SETTING_GROUNDZERO=""
  TARTIFY_SETTING_FORCE=
  echo "exiting$__EMR_ tartitune$__NN_ session, modified environment discarded
  (use 'tartitune last' to restore)"
}
#------------------------------------------------------------------------------
#
#             MAIN
#
#------------------------------------------------------------------------------

__tartify_define_colors_TPUT
__tartify_reset_PS1_globs ALL
#__tartify_init_PS1_globs
#__tartify_init_PS1_globs_EXPORT
__tartify_init_globs
[ -f ~/.tartifyrc ] && . ~/.tartifyrc

# ADDONS

##TODO: ZSH compatibility
#if [[ -n ${ZSH_VERSION-} ]]; then
#  autoload -U compinit
#  autoload -U +X bashcompinit && bashcompinit
#fi

#if [[ -n ${ZSH_VERSION-} ]]; then
#  emulate -L bash
#  setopt KSH_TYPESET

#  # workaround zsh's bug that leaves 'words' as a special
#  # variable in versions < 4.3.12
#  typeset -h words
#fi

complete -F __tartitune_completion tartitune

#DEPREC:
#export __tartify_shell_loaded=1

# script is being executed, run the main command
# script is being sourced, exit with 0
[ "$__tartify_whocalled" = "exec" ] && tartify $__tartify_args || return 0


# REMOVE ANSI ESCAPE from string
# MACOS
# echo  $TOTO | sed -E "s/\\\\033\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
# LINUX
#               sed -r


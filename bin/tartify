#!/bin/bash
##################################################################################
#
#       Filename:  tartify
#
#    Description:  BASH PS1 with GIT support
#
#                  Colored command prompt adapted to GIT repository. VERY
#                  colorfull, not for the faint hearted
#
#  Configuration:  place this file somewhere in your PATH and source it in your
#                  .bashrc
#
#                     source /path/to/bashps1
#
#   Dependencies:  Depends on GIT, might work on windows with Cygwin
#
#   GVIM Version:  1.7+ (?)
#
#         Author:  Pierre Lhoste
#        Twitter:  http://twitter.com/peterhost
#
#        Version:  0.1
#        Created:  01.05.2011
#        License:  WTFPL V2
#
# DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE Version 2, December 2004
#
# Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>
#
# Everyone is permitted to copy and distribute verbatim or modified
# copies of this license document, and changing it is allowed as long as
# the name is changed.
#
#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE TERMS AND
#            CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
#
#  0. You just DO WHAT THE FUCK YOU WANT TO.
#
#------------------------------------------------------------------------------
#

# USAGE : Just call the tartify() function from the command line
#
#         PROMPT integration : call tartify() inside your $PS1. Examples:
#
#           PS1="\$(tartify) [\u@\h]\$ "
#           PS1="\$(tartify)\n[\u@\h]\$ "
#           ...
#
#         You can also pass arguments to tartify() to make it display only
#         certain informations
#
#           tartify -h
#
#

#PS1="${__PS1NN_}${__PS1EMK_}[${__PS1UC_}\u${__PS1EMK_}@${__PS1EMUC_}\h ${__PS1C_}\${NEW_PWD}${__PS1EMK_}] \$"
#PROMPT_COMMAND=tartify
#
#
#
#------------------------------------------------------------------------------
#
# ISSUE :
#
#   * no support for SVN upstream (as I don't use SVN), feel free to augment
#     this script
#
#

#   * conditionnal newline : there is no such thing in a prompt. Either a
#   newline is hardcoded in the prompt, or it's not. All linebreak(s) inserted
#   by an external command called in the PS1 variable via "$(command)" are
#   stripped out when $PS1 is evaluated.
#
#   Solution: if you need a multiline prompt, with the 'tartify' line only
#   inserted if you're being in a 'git' repository, consider using a
#   PROMPT_COMMAND like this :
#
#     prompt_command(){
#       ...
#       tartify w
#     }
#     PROMPT_COMMAND=prompt_command
#
#   The 'w' option to tartify issues a newline if the contents of \`tartify\`
#   is not an empty string.
#
#   * Line Wrapping Calculation
#
#     The one thing (that I know of) which confuse line wrapping (when browsing
#     command history with long lines, for ex) is non-printable characters
#     (such as ansi escape color codes, cursor movement,...). So:
#
#       1 - non-printable characters in the PS1 variable have to be "escaped"
#       by enclosing them between a pair of escaped brackets :
#
#           \[\033[0;30m\]   instead of  \033[0;30m
#
#       And this has to be done at PS1 definition-time, as PS1 is only assigned
#       ONCE but evaluated at EACH PROMPT.
#
#       2 - function calls inside the PS1 variable that issue non-printable
#       characters will confuse the prompt, naturally, if the said n-p-chars
#       are not escaped IN the PS1 variable itself at assignement time. Example :
#
#               PS1=">"
#               > pwd
#               /some/dir
#               > myfunc(){ echo  "\[\033[0;30m\]\$(pwd) > \[\033[0m\]"; }
#               > myfunc
#               \[\033[0;30m\]$(pwd) > \[\033[0m\]
#
#           this will work
#               > PS1=$(myfunc)
#               /some/dir > echo $PS1
#               \[\033[0;30m\]$(pwd) > \[\033[0m\]
#               /some/dir > cd tmp
#               /some/dir/tmp >
#
#            this won't:
#               /some/dir/tmp > PS1='$(myfunc)'
#               \[\]stevejobs~ echo $PS1
#               $(myfunc)

#            As you can see in the latter, there are no escaped ansi codes
#            whatsoever, just a function call.  the prompt will print
#            litterally '\[\033[0;30m\]' each time, as this escaped substring
#            was not hardcoded in the PS1 variable at the time when it was
#            assigned, but generated by a function call evaluated for each
#            prompt, INSIDE the PS1 variable

#       MORE: on the subject
#       http://www.issociate.de/board/post/481503/bash_command_substitution,_functions_and_quoting_:_need_help.html
#
#     Problem is : if a function used in the PS1 variable is to adapt it's colored
#                  output according to context, there is no way to hardcode that
#                  directly in $PS1 with the '\[' escapes.
#
#       -> better use `printf` rather than `echo` (which somewhat sucks and which
#       behaviour is inconsistant across shells and OSes)
#
#       OR...
#       -> need to be issued on a line prior to the last line of the prompt, with :
#           * either \n insertion,
#
#               PS1="\$(tartify)\n$ "
#
#           * or use of the PROMPT_COMMAND environment variable
#
#               __somefunc() {
#                 ...
#                 tartify
#                 ...
#               }
#               export PROMPT_COMMAND=__somefunc
#               PS1=...
#
#       otherwise they will confuse wrapping too. Hence, your PS1 better look
#       something like :
#
#
#
#       (SEE:http://hintsforums.macworld.com/archive/index.php/t-17068.html)
#
#    * Quick n dirty benchmark
#      loop over 1000 executions of `tartify` on a 3.06GHz Intel Core 2 Duo Imac
#      without any further methodology
#
#       **execution-time (ms)**
#       _____________________________________________________________
#      |    REPO   | TINY       | SMALL     | MEDIUM    | LARGE      |
#      |           | ms   %     | ms   %    | ms   %    | ms   %     |
#      |___________|____________|___________|___________|____________|
#      |    remote | 48   25%   | 59   29%  | 92   27%  | 93  23%    |
#      |   1 stash | 56   30%   | 56   28%  | 179  52%  | 202 50%    |
#      |    branch | 60   32%   | 63   31%  | 46   13%  | 81  20%    |
#      |      repo | 14    7%   | 13    6%  | 13    4%  | 14   3%    |
#      |  timelast | 11    6%   | 11    5%  | 12    3%  | 12   3%    |
#      |           |            |           |           |            |
#      |     total | 189        | 202       | 342       | 402        |
#      |           |            |           |           |            |
#      | __git_ps1 |            |           |           | 63         |
#      | __git_ps1 |            |           |           |            |
#      |shwupstream|            |           | 21        | 26         |
#      |___________|____________|___________|___________|____________|
#
#
#------------------------------------------------------------------------------
#
# NOTA :
#          Special Character Codes
#          \a – an ASCII bell character (07)
#          \d – the date in “Weekday Month Date” format (e.g., “Tue May 26″)
#          \D{format} – the format is passed to strftime(3) and the result is inserted into the prompt string; an empty format results in a locale-specific time representation. The braces are required
#          \e – an ASCII escape character (033)  (hence : \e and \033 are equivalent)
#          \h – the hostname up to the first `.’
#          \H – the hostname
#          \j – the number of jobs currently managed by the shell
#          \l – the basename of the shell’s terminal device name
#          \n – newline
#          \r – carriage return
#          \s – the name of the shell, the basename of $0 (the portion following the final slash)
#          \t – the current time in 24-hour HH:MM:SS format
#          \T – the current time in 12-hour HH:MM:SS format
#          \@ – the current time in 12-hour am/pm format
#          \A – the current time in 24-hour HH:MM format
#          \u – the username of the current user
#          \v – the version of bash (e.g., 2.00)
#          \V – the release of bash, version + patchelvel (e.g., 2.00.0)
#          \w – the current working directory
#          \W – the basename of the current working directory
#          \! – the history number of this command
#          \# – the command number of this command
#          \$ – if the effective UID is 0, a #, otherwise a $
#          \nnn – the character corresponding to the octal number nnn
#          \\ – a backslash
#          \[ - begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt
#          \] – end a sequence of non-printing characters
#
#          (http://www.wiredrevolution.com/bash-programming/customize-the-bash-ps1-command-prompt)



#------------------------------------------------------------------------------
#
#             PRELIMINARY CHECKS
#
#------------------------------------------------------------------------------
# store command line params
__tartify_args="$*"

# Are we being sourced or executed ?
Prog="tartify"
__tartify_whocalled=
if [ "$(basename $0 2>/dev/null )" = "$Prog" ]; then
  __tartify_whocalled="exec"
else
  __tartify_whocalled="source"
fi



#------------------------------------------------------------------------------
#
#             SHELL DETECTION
#
#------------------------------------------------------------------------------

## SHELL detection
## SHELL      DARWIN      LINUX
## sh         path/to/sh  sh
## csh        -sh         -sh
## tcsh       -csh        -csh
## ksh        ksh         ksh
## bash       -bash       bash
## zsh        zsh         zsh

#__thisShell=`ps $$ | grep $$ | awk '{ print $5 }' | sed 's/\-/\\\-/g'`
#echo $__thisShell
#__thisShell=$(basename $__thisShell)
#echo $__thisShell
## Darwin detection
#if uname -s | grep "Darwin" >/dev/null 2>&1
#then
#  __OSflavor="Darwin" # macos
#fi

## BAIL if using SH on OSX, (scrambles "echo -ne" commands)
#[ "$__OSflavor" = "Darwin" ] && [ "$__thisShell" = "sh" ] && { echo " SH detected, exit";  exit 1; }

#------------------------------------------------------------------------------
#
#             MISC GLOBAL VARIABLES
#
#------------------------------------------------------------------------------


__tartify_define_colors_TPUT() {
# COLOR VARS :  * declare those color codes ONCE and for ALL.
#                 This somewhat pollutes the GLOBAL SCOPE but the variable names
#                 are (thought to be) unique enough so that won't cause problems
#
#               * do that like a grownup (tput, not ANSI escapes)
#
#               * TODO: handle dark vs light background
#
#               * TODO: handle 256 colors (if [ $(tput colors) -ge 256 ] ...)
#                       -> do that via tartitheme()

                                                                     #   ANSI equivalent
                                                                     #  <attr> <fg>  <bg>
  # ALL
   export __NN_=$( tput sgr0   || : 2>/dev/null )                    # [ 0m                RESET ALL attributes

  # STYLES
  # <BEGIN>
   export __EM_=$( tput bold    || : 2>/dev/null )                   # [ 1m                BEGIN DOUBLE INTENSITY (bold) mode
   export __DM_=$( tput dim     || : 2>/dev/null )                   # [ 2m                BEGIN HALF INTENSITY    (dim) mode
   export __UN_=$( tput smul    || : 2>/dev/null )                   # [ 4m                BEGIN UNDESCORE  (underlined) mode
   export __BL_=$( tput blink   || : 2>/dev/null )                   # [ 5m                BEGIN BLINKING                mode
   export __RV_=$( tput rev     || : 2>/dev/null )                   # [ 7m                BEGIN REVERSE VIDEO (reverse) mode
   export __SO_=$( tput smso    || : 2>/dev/null )                   #?[ 7m                BEGIN STANDOUT      (reverse) mode
   export __IN_=$( tput invis   || : 2>/dev/null )                   # [ 8m                BEGIN INVISIBLE               mode
   export __DEL_=$(tput cub1    || : 2>/dev/null )                   #                     MOVE cursor LEFT one space
  # <END>
  export __SOQ_=$( tput rmso    || : 2>/dev/null )                   #?[ 27m               END   STANDOUT      (reverse) mode
  export __UNQ_=$( tput rmul    || : 2>/dev/null )                   # [ 24m               END   UNDESCORE  (underlined) mode
  # for all other END style, use `tput sgr0` ($__NN_)

  # COLORS
  # <Foreground>
    export __K_=$( tput setf 0 || tput setaf 0 || : 2>/dev/null )    # [       0m          SET   FG color to BLACK
    export __R_=$( tput setf 4 || tput setaf 1 || : 2>/dev/null )    # [       1m          SET   FG color to RED
    export __G_=$( tput setf 2 || tput setaf 2 || : 2>/dev/null )    # [       2m          SET   FG color to GREEN
    export __Y_=$( tput setf 6 || tput setaf 3 || : 2>/dev/null )    # [       3m          SET   FG color to YELLOW
    export __B_=$( tput setf 1 || tput setaf 4 || : 2>/dev/null )    # [       4m          SET   FG color to BLUE
    export __M_=$( tput setf 5 || tput setaf 5 || : 2>/dev/null )    # [       5m          SET   FG color to MAGENTA
    export __C_=$( tput setf 3 || tput setaf 6 || : 2>/dev/null )    # [       6m          SET   FG color to CYAN
    export __W_=$( tput setf 7 || tput setaf 7 || : 2>/dev/null )    # [       7m          SET   FG color to WHITE
  # <Background>
  export __BGK_=$( tput setb 0 || tput setab 0 || : 2>/dev/null )    # [       0m          SET   BG color to BLACK
  export __BGR_=$( tput setb 4 || tput setab 1 || : 2>/dev/null )    # [       1m          SET   BG color to RED
  export __BGG_=$( tput setb 2 || tput setab 2 || : 2>/dev/null )    # [       2m          SET   BG color to GREEN
  export __BGY_=$( tput setb 6 || tput setab 3 || : 2>/dev/null )    # [       3m          SET   BG color to YELLOW
  export __BGB_=$( tput setb 1 || tput setab 4 || : 2>/dev/null )    # [       4m          SET   BG color to BLUE
  export __BGM_=$( tput setb 5 || tput setab 5 || : 2>/dev/null )    # [       5m          SET   BG color to MAGENTA
  export __BGC_=$( tput setb 3 || tput setab 6 || : 2>/dev/null )    # [       6m          SET   BG color to CYAN
  export __BGW_=$( tput setb 7 || tput setab 7 || : 2>/dev/null )    # [       7m          SET   BG color to WHITE
  # <reset>
   export __NF_=$( tput setf 9 || tput setaf 9 || : 2>/dev/null )    # [       39m         RESET FG color to term's default
   export __NG_=$( tput setb 9 || tput setab 9 || : 2>/dev/null )    # [             49m   RESET BG color to term's default
  export __NFG_=$__NF_$__NB_                                         # [       39;   49m   RESET FG & BG color to term's default
  # <pseudo Foreground-bold>
  export __EMK_=$__EM_$__K_                                          # [ 1;    20m         SET   FG color to BOLD BLACK
  export __EMR_=$__EM_$__R_                                          # [ 1;    21m         SET   FG color to BOLD RED
  export __EMG_=$__EM_$__G_                                          # [ 1;    22m         SET   FG color to BOLD GREEN
  export __EMY_=$__EM_$__Y_                                          # [ 1;    23m         SET   FG color to BOLD YELLOW
  export __EMB_=$__EM_$__B_                                          # [ 1;    24m         SET   FG color to BOLD BLUE
  export __EMM_=$__EM_$__M_                                          # [ 1;    25m         SET   FG color to BOLD MAGENTA
  export __EMC_=$__EM_$__C_                                          # [ 1;    26m         SET   FG color to BOLD CYAN
  export __EMW_=$__EM_$__W_                                          # [ 1;    27m         SET   FG color to BOLD RED

  #MISC (non color)
  export __NL_=$( tput cud1 )
}


#__tartify_list_PS1_globs(){

#  # BRANCH
#  echo "
#      __t4_tU=$__t4_tU    __t4_tuSr=$__t4_tuSr  __t4_tRA=$__t4_tRA
#      __t4_tRD=$__t4_tRD   __t4_tRI=$__t4_tRI   __t4_tRO=$__t4_tRO
#      __t4_tRN=$__t4_tRN   __t4_turS=$__t4_turS  __t4_TU=$__t4_TU
#      __t4_TuSr=$__t4_TuSr  __t4_TRA=$__t4_TRA   __t4_TRD=$__t4_TRD
#      __t4_TRI=$__t4_TRI   __t4_TRO=$__t4_TRO   __t4_TRN=$__t4_TRN
#      __t4_TurS=$__t4_TurS
#"

#}


__tartify_reset_PS1_globs(){

  # REPOSITORY NAME
  if [ "REPO" = "$1" ] ||  [ "ALL" = "$1" ]; then
     __t4_rep=""   # repo name
    __t4_sepN=""   # dynamic separator for repo name
  fi

  # BRANCH
  if [ "BRANCH" = "$1" ] ||  [ "ALL" = "$1" ]; then
      #
      # TODO: explain that better !
      # __t4B=__tartify_branch()
      # T=untracked files    t=no untracked files
      # U=unstaged changes   u=no unstaged changes
      # S=staged changes     s=no staged changes
      # R=remote info        r=no remote info

      __t4_tU=""   #           Unstaged
      __t4_tuSr="" #           Staged                (stag-before-rem
      __t4_tRA=""  #           remote Ahead of
      __t4_tRD=""  #           remote behinD
      __t4_tRI=""  #           remote dIverged
      __t4_tRO=""  #           remote Ok (uptodate)
      __t4_tRN=""  #           remote None
      __t4_turS="" #           Staged                (stag-before-rem
      __t4_TU=""   #UNtracked  Unstaged
      __t4_TuSr="" #UNtracked  Staged                (stag-before-rem
      __t4_TRA=""  #UNtracked  remote Ahead of
      __t4_TRD=""  #UNtracked  remote behinD
      __t4_TRI=""  #UNtracked  remote dIverged
      __t4_TRO=""  #UNtracked  remote Ok (uptodate)
      __t4_TRN=""  #UNtracked  remote None
      __t4_TurS="" #UNtracked  Staged                (rem-before-stag

     __t4_sepB=""  # dynamic separator for branch
  fi


  #REMOTE
  if [ "STASH" = "$1" ] ||  [ "ALL" = "$1" ]; then
    __t4_sepR=""   # dynamic separator for remotes
  fi


  #STASH
  if [ "STASH" = "$1" ] ||  [ "ALL" = "$1" ]; then
     __t4_st=""   # stash nocount
     __t4_ST=""   # stash count
   __t4_sepS=""   # dynamic separator for stashes
  fi

  #LAST COMMIT
  if [ "LAST" = "$1" ] ||  [ "ALL" = "$1" ]; then
    __t4_sepL=""   # dynamic separator for time-last-commit
  fi


  #NOTA : all variables named __t4_D*, where * is one or more numbers
  #       are dynamically generated a `tartify q' evaluation time
  #       (reserved variables for delimiters)
  if [ "ALL" = "$1" ]; then
    #clear __t4_D* variables
    for ((n=0;n<100;n++)); do eval "__t4_D$n=" ; done;
    __t4_newline_before=""
    __t4_newline_after=""
  fi

}


__tartify_init_globs(){

# Internal
TARTIFY_PROMPT_COMMAND_SET=""

# External TARTIFY PARAMETERS : adapt to your needs

# // GLOBAL

export TARTIFY_SETTING_FORCE=""                         # A string containing tartify command-line params. If non empty, will
                                                        # overwrite any arguments the tartify command receives
export TARTIFY_STRING_SEPARATOR=""                      # Default separator to be used with mono-character options (tartify 

# // TIME
export TARTIFY_SETTING_TIME_BUGME=TRUE                  # Non empty : will color and style the 'time since last commit' string
export TARTIFY_SETTING_TIME_DISPLAY=LONG                # LONG (min, hours, days) SHORT (mine | hours | days) CHAR (cf. next var)
export TARTIFY_STRING_TIME_DISPLAY="⟳ "                 # String to display in case prec. var == CHAR

                                                        # Uncommited changes (staged, unstaged)
export TARTIFY_SETTING_TIME_COULDCOMMIT=3600            #     *     nb seconds after which you COULD  commit
export TARTIFY_SETTING_TIME_SHOULDCOMMIT=86400          #     * Max nb seconds after which you SHOULD commit
                                                        # (default is 86400, 24hours)


                                                        # colors applied to the 'time elapsed since last commit'
                                                        # string, in case of uncommited changes
export TARTIFY_STYLE_TIME_COULDCOMMIT=${__UN_}          #                                  UNDERLINED
export TARTIFY_STYLE_TIME_SHOULDCOMMIT=${__EM_}${__UN_} #                           BOLD UNDERLINED

                                                        # styles applied to the 'time elapsed since last commit'
                                                        # string in case of no uncommited changes
export TARTIFY_COLOR_TIME_ACTIVITY_HIGH=${__G_}         #                                  GREEN
export TARTIFY_COLOR_TIME_ACTIVITY_LOW=${__Y_}          #                                  YELLOW
export TARTIFY_COLOR_TIME_ACTIVITY_NON=${__R_}          #                                  RED

# //BRANCH
export TARTIFY_STRING_BRANCH_DOTGIT="GIT_DIR!"                 # "branch name" replacement string for .git directory
export TARTIFY_STRING_BRANCH_BARE="<BARE>"                     # "branch name" replacement string for bare .git directory

#Branch style : Untracked files
export TARTIFY_STYLE_BRANCH_UNTRACKED=${__UN_}                 # Untracked Files                  UNDERLINED

# Branch COLOR : first 2 chars
export TARTIFY_COLOR_BRANCH_UNSTAGED=${__EMR_}          # unstaged changes (first char)    BOLD RED
export TARTIFY_COLOR_BRANCH_STAGED=${__EMM_}            # staged changes   (2nd char)      BOLD MAGENTA
# Branch COLOR : remaining chars
export TARTIFY_COLOR_BRANCH_UPSTREAM_DIVERGE=${__K_}  # tracked remot diverg from HEAD   BOLD DARK GREY
export TARTIFY_COLOR_BRANCH_UPSTREAM_BEHIND=${__R_}     # tracked remote ahead of HEAD     RED
export TARTIFY_COLOR_BRANCH_UPSTREAM_AHEAD=${__Y_}      # tracked remote behind HEAD       YELLOW
export TARTIFY_COLOR_BRANCH_UPSTREAM_UPTODATE=${__G_}   # tracked remote == HEAD           GREEN
export TARTIFY_COLOR_BRANCH_UPSTREAM_NOTRACK=${__B_}    # no remote tracking branch        BLUE
export TARTIFY_COLOR_BRANCH_NOCOMMITYET=${__W_}         # empty repo, no commit yet        WHITE
export TARTIFY_COLOR_BRANCH_GITDIR=${__C_}              # inside .git dir                  CYAN

#Branch color : additional info
export TARTIFY_COLOR_BRANCH_MERGE_INFOS=${__EMR_}       # color for the merge/rebase/cherry-pick/bisect status of current branch (if any)
                                                        #                                  BOLD RED

# Tartify shows U (Unstaged state), S (Staged state) and P (uPstream state,
# ahead, behind, diverged, uptodate) directly in the branch name. This
# can be tuned for lisibility's sake
export TARTIFY_SETTING_BRANCH_STAGED_INFO=              # empty     -> (unstaged)UPSTREAM[staged]
                                                        # non-empty -> (unstaged)[staged]UPSTREAM
export TARTIFY_SETTING_BRANCH_STAGED_INFO_LENGTH=2      # How many letters of resulting branchname are to be colored with
                                                        # the "unstaged" and "staged" markers
# Example:
#     () for      unstaged,      [] for      staged,     rest: upstream info
#
#     $TARTIFY_SETTING_BRANCH_STAGED_INFO empty
#     $TARTIFY_SETTING_BRANCH_STAGED_INFO_LENGTH =
#     0 : master    1 : (m)aste[r]    2 : (ma)st[er]    3 : (mas)[ter]    4 : (mas)[ter]    ,...
#     0 : feature   1 : (f)eatur[e]   2 : (fe)atu[re]   3 : (fea)t[ure]   4 : (fea)t[ure]   ,...
#
#     $TARTIFY_SETTING_BRANCH_STAGED_INFO non-empty
#     $TARTIFY_SETTING_BRANCH_STAGED_INFO_LENGTH =
#     0 : master    1 : (m)[a]ster    2 : (ma)[st]er    3 : (mas)[ter]    4 : (mas)[ter]    ,...


# // REPOSITORY
export TARTIFY_COLOR_REPO_NAME=${__K_}                  # repository's "name"              DIM GREY

# // REMOTES
export TARTIFY_STRING_REMOTE_NAME_ORIGIN="O"            # marker for remote repo called 'origin'
export TARTIFY_STRING_REMOTE_NAME_UPSTREAM="U"          # marker for remote repo called 'upstream'
export TARTIFY_STRING_REMOTE_NAME_OTHER="⇧ "            # generic marker for remote repo
export TARTIFY_STRING_REMOTE_COUNT_SEP="/"              # separator for ahead/behind count

export TARTIFY_STRING_REMOTE_TRACKING="➝ "              # marker for tracked branch
export TARTIFY_COLOR_REMOTE_NAME_ORIGIN=${__G_}         # repository's "name"              GREEN
export TARTIFY_COLOR_REMOTE_NAME_UPSTREAM=${__M_}       # repository's "name"              MAGENTA
export TARTIFY_COLOR_REMOTE_NAME_OTHER=${__Y_}          # repository's "name"              YELLOW


export TARTIFY_COLOR_REMOTE_COUNT_AHEAD=${__G_}         # nb commits ahead of remote       GREEN
export TARTIFY_COLOR_REMOTE_COUNT_BEHIND=${__R_}        # nb commits behind of remote      RED


# // STASH
export TARTIFY_SETTING_COUNTSTASHES=TRUE                # non empty: print 1 $TARTIFY_STRING_STASH per existing stash
                                                        # (WARN: this is slow process, add ~50ms computing time)
export TARTIFY_STRING_STASH="☆ "                        # marker for stash
export TARTIFY_STRING_STASH="•"                         # marker for stash
export TARTIFY_COLOR_STASH_NOCOUNT=${__Y_}              # color when not counting          YELLOW
export TARTIFY_COLOR_STASH_COUNT=${__EMY_}              # color in "count mode"            BOLD YELLOW

# // UNPARSED CHARS
export TARTIFY_COLOR_MISC_DELIMITER=${__K_}             # color for (unparsed) delimiters  DIM GREY


# TODO: (restrict that to OLDSCHOOL)
# The usual environment variables from git-completion.bash still apply
# in "OLDSCHOOL" mode
#
#     GIT_PS1_SHOWDIRTYSTATE
#     GIT_PS1_SHOWSTASHSTATE
#     GIT_PS1_SHOWUNTRACKEDFILES
#     GIT_PS1_SHOWUPSTREAM
}


__tartify_REMOVEME_exportall(){
  export -f __tartify_init_PS1_globs
  #export -f __tartify_init_PS1_globs_EXPORT
  export -f __tartify_reset_PS1_globs
  export -f __tartify_git_ps1_find_upstream
  export -f __tartify_git_ps1_process_remote
  export -f __tartify_git_ps1
  export -f __tartify_diff_count
  export -f __tartify_usage
  export -f __tartify_show_env
  export -f __tartify_build_PS1
  export -f __tartify_reformat_timestamp
  export -f __tartify_repo_name
  export -f __tartify_branch
  export -f __tartify_remote2
  export -f __tartify_stash
  export -f __tartify_timelastcommit
  export -f tartify
  export -f tartitune
  export -f __tartitune_completion
}

#------------------------------------------------------------------------------
#
#             ORIGINAL __git_ps1 FUNCTIONS (tuned to tartify)
#
#------------------------------------------------------------------------------
#
# following functions are copy/paste of the original functions from
# bash-completion.sh, slightly tuned for tartify.
#
#    __tartify__git_ps1_find_upstream   *CLONES*    first part of __git_ps1_show_upstream
#    __tartify_git_ps1_process_remote   *CLONES*    second part of __git_ps1_show_upstream
#    __tartify_git_ps1                  *CLONES*    __git_ps1
#
# This, to ease keeping compatibility with original __git_ps1(), and to
# ease updates (at the cost of spaghettying tartify's code even more
# with dynamic variable scope shit)
#
# Modifications :
#
# * local declarations moved to tartify(), as it's the root of our
#   local dynamic scope
#
# Note to self : keep chunks of code in original order to ease diffing


__tartify_git_ps1_find_upstream () {
  # fills the tartify() local variables :
  #    $upstream
  #    $verbose
  #    $legacy


  # hack to restrain the following modification to this global variable
  # to local dynamic scope, and set it to "auto" for all modes
  # but __git_ps1 compatibility mode
  local GIT_PS1_SHOWUPSTREAM=$GIT_PS1_SHOWUPSTREAM
  [ "OLDSCHOOL" = "$mode" ] || GIT_PS1_SHOWUPSTREAM="auto"
  #[ "OLDSCHOOL" = "$mode" ] || GIT_PS1_SHOWUPSTREAM="auto verbose"


  # ----- BEGIN __git_ps1_show_upstream chunk -----
  local key value
  local svn_remote=() svn_url_pattern count n
  #local upstream=git legacy="" verbose=""

  # get some config options from git-config
  while read key value; do
    case "$key" in
    bash.showupstream)
      GIT_PS1_SHOWUPSTREAM="$value"
      if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]] && [ "OLDSCHOOL" = "$mode" ]; then
        p=""
        return
      fi
      ;;
    svn-remote.*.url)
      svn_remote[ $((${#svn_remote[@]} + 1)) ]="$value"
      svn_url_pattern+="\\|$value"
      upstream=svn+git # default upstream is SVN if available, else git
      ;;
    esac
  done < <(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')

  # parse configuration values
  for option in ${GIT_PS1_SHOWUPSTREAM}; do
    case "$option" in
    git|svn) upstream="$option" ;;
    verbose) verbose=1 ;;
    legacy)  legacy=1  ;;
    esac
  done

  # Find our upstream
  case "$upstream" in
  git)    upstream="@{upstream}" ;;
  svn*)
    # get the upstream from the "git-svn-id: ..." in a commit message
    # (git-svn uses essentially the same procedure internally)
    local svn_upstream=($(git log --first-parent -1 \
          --grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null))
    if [[ 0 -ne ${#svn_upstream[@]} ]]; then
      svn_upstream=${svn_upstream[ ${#svn_upstream[@]} - 2 ]}
      svn_upstream=${svn_upstream%@*}
      local n_stop="${#svn_remote[@]}"
      for ((n=1; n <= n_stop; ++n)); do
        svn_upstream=${svn_upstream#${svn_remote[$n]}}
      done

      if [[ -z "$svn_upstream" ]]; then
        # default branch name for checkouts with no layout:
        upstream=${GIT_SVN_ID:-git-svn}
      else
        upstream=${svn_upstream#/}
      fi
    elif [[ "svn+git" = "$upstream" ]]; then
      upstream="@{upstream}"
    fi
    ;;
  esac
  # ----- END   __git_ps1_show_upstream chunk -----


}


__tartify_git_ps1_process_remote () {
  # by default, processes the value of $upstream (tartify()'s scope)
  # as previously set by __tartify_git_ps1_find_upstream()
  # or something else if an argument is given
  [ ${#1} -gt 0 ] && upstream=$1


  # ----- BEGIN __git_ps1_show_upstream chunk -----
  # Find how many commits we are ahead/behind our upstream
  if [ ${#legacy} == 0 ]; then
  #if [[ -z "$legacy" ]]; then
    count="$(git rev-list --count --left-right \
        "$upstream"...HEAD 2>/dev/null)"
  else
    # produce equivalent output to --count for older versions of git
    local commits
    if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"
    then
      local commit behind=0 ahead=0
      for commit in $commits
      do
        case "$commit" in
        "<"*) let ++behind
          ;;
        *)    let ++ahead
          ;;
        esac
      done
      count="$behind  $ahead"
    else
      count=""
    fi
  fi

  # calculate the result
  if [[ -z "$verbose" ]]; then
    case "$count" in
    "") # no upstream
      p="" ;;
    "0	0") # equal to upstream
      p="=" ;;
    "0	"*) # ahead of upstream
      p=">" ;;
    *"	0") # behind upstream
      p="<" ;;
    *)      # diverged from upstream
      p="<>" ;;
    esac
  else
    case "$count" in
    "") # no upstream
      p="" ;;
    "0	0") # equal to upstream
      p=" u=" ;;
    "0	"*) # ahead of upstream
      p=" u+${count#0	}" ;;
    *"	0") # behind upstream
      p=" u-${count%	0}" ;;
    *)      # diverged from upstream
      p=" u+${count#*	}-${count%	*}" ;;
    esac
  fi

  # ----- END   __git_ps1_show_upstream chunk -----
}


__tartify_git_ps1(){
  #local g="$(__gitdir)"
  if [ -n "$g" ]; then
    #local r=""
    #local b=""
    if [ -f "$g/rebase-merge/interactive" ]; then
      r="|REBASE-i"
      b="$(cat "$g/rebase-merge/head-name")"
    elif [ -d "$g/rebase-merge" ]; then
      r="|REBASE-m"
      b="$(cat "$g/rebase-merge/head-name")"
    else
      if [ -d "$g/rebase-apply" ]; then
        if [ -f "$g/rebase-apply/rebasing" ]; then
          r="|REBASE"
        elif [ -f "$g/rebase-apply/applying" ]; then
          r="|AM"
        else
          r="|AM/REBASE"
        fi
      elif [ -f "$g/MERGE_HEAD" ]; then
        r="|MERGING"
      elif [ -f "$g/CHERRY_PICK_HEAD" ]; then
        r="|CHERRY-PICKING"
      elif [ -f "$g/BISECT_LOG" ]; then
        r="|BISECTING"
      fi

      b="$(git symbolic-ref HEAD 2>/dev/null)" || {

        b="$(
        case "${GIT_PS1_DESCRIBE_STYLE-}" in
        (contains)
          git describe --contains HEAD ;;
        (branch)
          git describe --contains --all HEAD ;;
        (describe)
          git describe HEAD ;;
        (* | default)
          git describe --tags --exact-match HEAD ;;
        esac 2>/dev/null)" ||

        b="$(cut -c1-7 "$g/HEAD" 2>/dev/null)..." ||
        b="unknown"
        b="($b)"
      }
    fi

    #local w=""
    #local i=""
    #local s=""
    #local u=""
    #local c=""
    #local p=""

    if [ "true" = "$(git rev-parse --is-inside-git-dir 2>/dev/null)" ]; then
      if [ "true" = "$(git rev-parse --is-bare-repository 2>/dev/null)" ]; then
        c="BARE:"
        idaongbe="B"
      else
        b="GIT_DIR!"
        idaongbe="G"
      fi
    elif [ "true" = "$(git rev-parse --is-inside-work-tree 2>/dev/null)" ]; then
      if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] || [ "OLDSCHOOL" != "$mode" ]; then
        #TODO: !!!!! only OLDSCHOOL for this test
        if [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
          git diff --no-ext-diff --quiet --exit-code || w="*"
          if git rev-parse --quiet --verify HEAD >/dev/null; then
            git diff-index --cached --quiet HEAD -- || i="+"
          else
            i="#"
            idaongbe="E"
          fi
        fi
      fi
      if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ] || [ "OLDSCHOOL" != "$mode" ]; then
              git rev-parse --verify refs/stash >/dev/null 2>&1 && s="$"
      fi

      if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] || [ "OLDSCHOOL" != "$mode" ]; then
         if [ -n "$(git ls-files --others --exclude-standard)" ]; then
            u="%"
         fi
      fi

      if [ "true" = "$processupstream" ] && [ -n $upstream ]; then
        #no arg : processes upstream
        __tartify_git_ps1_process_remote
      fi
    fi

    f="$w$i$s$u"
    #local f="$w$i$s$u"
    #printf "${1:- (%s)}" "$c${b##refs/heads/}${f:+ $f}$r$p"
  fi

}


#------------------------------------------------------------------------------
#
#             HELPER FUNCTIONS
#
#------------------------------------------------------------------------------


__tartify_diff_count() {
#count the nb of commits between two branches of two repositorie
#   ex: __tartify_diff_count HEAD origin/master
#   ex: __tartify_diff_count upstream/dev HEAD
    echo "$(git rev-list $1..$2 2>/dev/null | awk 'END {print NR}')"
}


__tartify_usage(){
# Display the help message
  cat <<HELPTEXT
  ${__UN_}Description${__UNQ_} : One-Liner condensed GIT infos (for your prompt, screen
                statusline, ...)

  ${__UN_}Usage${__UNQ_} is : ${__EM_}tartify${__EMQ_} [${__Y_}options${__NN_}]

  ${__UN_}Options${__UNQ_} is : a CASE-SENSITIVE sequence of characters.

      * The following characters are reserved tartify commands :
         ${__Y_}abBcehilLnNopqrRsStuUvwW${__NN_} (and maybe more letters in the future)

      * any other character will be printed "as is", including spaces. You can use
      those to format the output of the tarttify command (as delimiters,...)
              \`tartify [r]b - l\` will output \"[repository]master - 12m\"

      * if you need multiple spaces, escape them \"\ \" :
              \`tartify [r]b -\ \ l\` will output \"[repository]master -  12m\"

      * following characters need to be escaped  ${__Y_}\(\)<>;*\"\'\`\#&|~${__NN_}


      ${__Y_}[Elements]${__NN_} ${__EM_}${__NN_}

      ${__Y_}n${__NN_}       repository ${__EMY_}n${__NN_}ame       ${__Y_}N${__NN_}   same without colors
      ${__Y_}b${__NN_}       ${__EMY_}b${__NN_}ranch name           ${__Y_}B${__NN_}          \` \`
      ${__Y_}r${__NN_}       (all)  ${__EMY_}r${__NN_}emotes  info  ${__Y_}R${__NN_}          \` \`
      ${__Y_}u${__NN_}       (only) ${__EMY_}u${__NN_}pstream info  ${__Y_}U${__NN_}          \` \`
      ${__Y_}s${__NN_}       ${__EMY_}s${__NN_}tash info            ${__Y_}S${__NN_}          \` \`
      ${__Y_}l${__NN_}       ${__EMY_}l${__NN_}ast commit info      ${__Y_}L${__NN_}          \` \`

      ${__Y_}w${__NN_}       ne${__EMY_}w${__NN_}line     insert newline (positionnal)
      ${__Y_}W${__NN_}       ne${__EMY_}W${__NN_}line     prepend newline at beginning (non-positionnal)

      ${__Y_}[Modifiers]${__NN_} ${__EM_}                 ${__NN_}

      ${__Y_}c${__NN_}       no${__EMY_}c${__NN_}olor    strip all colors
      ${__Y_}t${__NN_}       no ups${__EMY_}t${__NN_}ream in branch

      ${__Y_}[Modes]${__NN_} ${__EM_}mutually exclusive (only first one counts)${__NN_}

      ${__Y_}i${__NN_}       succ${__EMY_}i${__NN_}nt    even shorter version
      ${__Y_}a${__NN_}       ch${__EMY_}a${__NN_}tterbox looong version
      ${__Y_}q${__NN_}       ${__EMY_}q${__NN_}uiet      only update variables, no output
      ${__Y_}o${__NN_}       ${__EMY_}o${__NN_}ldschool  __git_ps1 mode
      ${__Y_}p${__NN_}       ${__EMY_}p${__NN_}s1 mode   string with escaped (\[...\])ansi escape codes
      ${__Y_}v${__NN_}       ${__EMY_}v${__NN_}im mode   result formated for the Vim tartify plugin
                         (color info appended to result)


      ${__Y_}[Help]${__NN_} ${__EM_}all other arguments are ignored${__NN_}

      ${__Y_}h${__NN_}     ${__EMY_}h${__NN_}elp      display this help message
      ${__Y_}e${__NN_}     ${__EMY_}e${__NN_}nv help  list customizable environment variables

  ${__UN_}Default${__UNQ_}   tartify   : is equivalent to ${__EM_}tartify${__EMQ_} ${__Y_}nbrsl${__NN_}
            tartify w : is equivalent to ${__EM_}tartify${__EMQ_} ${__Y_}nbrslw${__NN_}
            tartify o : is equivalent to ${__EM_}tartify${__EMQ_} ${__Y_}obsr${__NN_}

  ${__UN_}More${__UNQ_}      see the ${__Y_}tartitune${__NN_} command to easily change tartify's colors from
            the command line and experiment

HELPTEXT
}


__tartify_show_env() {

  # pretty print TARTIFY environment
  echo;echo
  echo "   Tartify's ENVIRONMENT variables are currently"
  echo "   set to :"
  echo
  echo ""$__UN_"                                                         "$__NN_
  echo       "$__W_$__BGK_             PREDEFINED COLORS                           $__NN_ "
  echo       "$__UN_$__W_$__BGK_          (for use in your dotfiles)                     $__NN_ "
  echo
  local simplecols=$(\
    env | grep '^__[A-Z]\{1\}_=' | sort -df |  awk -F"=" '{printf("%s%s%s ", "\033[0m",$2,($1 "\033[0m"))}'\
  )
  printf "$__K_$__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s\n" $simplecols

  local boldcols=$(\
    env | grep '^__EM[A-Z]\{1\}_=' | sort -df |  awk -F"=" '{printf("%s%s%s ", "\033[0m",$2,($1 "\033[0m"))}'\
  )
  printf "$__K_$__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s\n" $boldcols

  local bgcols=$(\
    env | grep '^__BG[A-Z]\{1\}_=' | sort -df |  awk -F"=" '{printf("%s%s%s ", "\033[0m",$2,("\033[30m" $1 "\033[0m"))}'\
  )
  printf "$__K_$__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s\n" $bgcols

  local others=$(\
    env | grep -v '^__EM[A-Z]_\|__[A-Z]_\|__BG[A-Z]_' | grep '^__[A-Z]\{1,3\}_=' | sort -df |  awk -F"=" '{printf("%s%s%s ", "\033[0m",$2,($1 "\033[0m"))}'\
  )
  printf "$__K_$__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s\n" $others


  #printf "%6s  %0s  %10s %s %10s %s %10s %s\n" $(
  #env | grep '^__[a-zA-Z]\{1,3\}_=' | sort -df\
  #    | awk -F"=" '{printf("%'0s'%'0s'%-'8s'%'0s'", "\033[0m    ",$2,($1 "\033[0m")," ")}'\
  #    )
  echo ""$__UN_"                                                         "$__NN_
  echo       "$__UN_$__W_$__BGK_                  STRINGS                                $__NN_"
  echo
  env | grep "^TARTIFY_STRING_" | sort -df \
      | awk -F"=" '{printf("%'11s'%-'15s'%-'29s'%'0s'\n", "\033[0m    ",$2,$1," ")}'
  echo ""$__UN_"                                                         "$__NN_
  echo       "$__UN_$__W_$__BGK_                  SETTINGS                               $__NN_"
  echo
  env | grep "^TARTIFY_SETTING" | sort -df \
      | awk -F"=" '{printf("%'11s'%-'15s'%-'29s'%'0s'\n", "\033[0m    ",$2,$1," ")}'
  echo ""$__UN_"                                                         "$__NN_
  echo       "$__UN_$__W_$__BGK_                  STYLES                                 $__NN_ "
  echo
  env | grep "^TARTIFY_STYLE" | sort -df \
      | awk -F"=" '{printf("%'11s'%'0s'%-'48s'%'0s'\n", "\033[0m    ",$2,($1 "\033[0m")," ")}'
  echo ""$__UN_"                                                         "$__NN_
  echo       "$__UN_$__W_$__BGK_                  COLORS                                 $__NN_ "
  echo
  env | grep "^TARTIFY_COLOR" | sort -df \
      | awk -F"=" '{printf("%'11s'%'0s'%-'48s'%'0s'\n", "\033[0m    ",$2,($1 "\033[0m")," ")}'
  echo;echo
  echo $__NN_"   \`tartify help\` for more";
  echo $__NN_"   \`tartitune help\` for more";
}


__tartify_build_PS1() {
  #WARN: this is called from within the PS1 string, hence we're in a
  #      subshell -> no exporting
  local argstr="$*"

  local before=""
  local after=""

  #force dynamic separator if need be
  [ -z "$forceDefaultSep" ] || {
    separator=$TARTIFY_STRING_SEPARATOR
    [ -z $separator ] && separator=' '
  }



  [[ "$argstr" =~ W ]] && printf "%s" '$__t4_newline_before'

  local firstn="true" #don't insert dynamic separator ($__t4_sep*) before first item
  local delimNb=0     #delimiter's position
  for ((n=0;n<${#argstr};n++))
  do
    local ch=${argstr:$n:1}
    case $ch in
      n)
        #REPO NAME
        [ -z $firstn ] && [ ! -z "$separator" ] && printf "%s" '$__t4_sepN'
        printf "%s" '\['$TARTIFY_COLOR_REPO_NAME'\]$__t4_rep'

        ;;
      b)
        #BRANCH
        [ -z $firstn ] && [ ! -z "$separator" ] && printf "%s" '$__t4_sepB'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UNSTAGED'\]$__t4_tU'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_STAGED'\]$__t4_tuSr'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_AHEAD'\]$__t4_tRA'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_BEHIND'\]$__t4_tRD'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_DIVERGE'\]$__t4_tRI'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_UPTODATE'\]$__t4_tRO'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_NOTRACK'\]$__t4_tRN'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_STAGED'\]$__t4_turS'

        printf "%s" '\['$TARTIFY_STYLE_BRANCH_UNTRACKED'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UNSTAGED'\]$__t4_TU'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_STAGED'\]$__t4_TuSr'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_AHEAD'\]$__t4_TRA'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_BEHIND'\]$__t4_TRD'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_DIVERGE'\]$__t4_TRI'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_UPTODATE'\]$__t4_TRO'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_NOTRACK'\]$__t4_TRN'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_STAGED'\]$__t4_TurS'
        printf "%s" '\['$__NN_'\]'
        ;;
      r)
        #REMOTES
        [ -z $firstn ] && [ ! -z "$separator" ] && printf "%s" '$__t4_sepR'
        ;;
      u)
        #UPSTREAM ONLY
        [ -z $firstn ] && [ ! -z "$separator" ] && printf "%s" '$__t4_sepR'
        ;;
      s)
        #STASHES
        [ -z $firstn ] && [ ! -z "$separator" ] && printf "%s" '$__t4_sepS'
        printf "%s" '\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_STASH_NOCOUNT'\]$__t4_st'
        printf "%s" '\['$TARTIFY_COLOR_STASH_COUNT'\]$__t4_ST'
        printf "%s" '\['$__NN_'\]'
        ;;
      l)
        #LAST COMMIT
        [ -z $firstn ] && [ ! -z "$separator" ] && printf "%s" '$__t4_sepL'
        ;;
      c) ;;
      o) ;;
      p) ;;
      i) ;;
      a) ;;
      q) ;;
      t) ;;
      v) ;;
      w) ;;
      W) ;;
      #TODO: make that issue ansi escapes (PS1 and standard mode)
      \\) ;;
      #TODO: make that work with PS1 and NOCOLORS
      #*) printf "%s" '\['$TARTIFY_COLOR_MISC_DELIMITER'\]'$ch'\['$__NN_'\]';;
      *)
        #Delimiters will be generated and stored dynamically in __t4_D* variables for each
        #call of 'tartify q'
        printf "%s" '\['$TARTIFY_COLOR_MISC_DELIMITER'\]$__t4_D'$delimNb'\['$__NN_'\]'
        delimNb=$((delimNb + 1))
        ;;
    esac
    unset firstn
  done


  printf "%s" '\['$__NN_'\]'

  [[ "$argstr" =~ w ]] && printf "%s" '$__t4_newline_after'

  #TODO: newline insertion


}

# TODO : DEPRECATED
#__tartify_augment_prompt_command() {
#  # build a function (or augment existing one) 
#  # and assign it to PROMPT_COMMAND
#  # TODO: make that ZSH compatible

#  # Create default PROMPT_COMMAND function
#  eval "__tartify_prompt_command(){ tartify \"\$TARTIFY_PS1_OPTION_SET\"; };
#        export -f __tartify_prompt_command;"

#  # Yank current definition of $PROMPT_COMMAND (if any)
#  # TODO: this is not portable outside of Bash
#  #
#  #                                          remove                         remove
#  #                                          "...is a function"             trailing "}"
#  local minusLast2=$(type  $PROMPT_COMMAND | tail -n +2        |  tail -r | tail -n +2)
#  local last2lines=$(printf '%s\n %s\n ' '}' '  tartify "$TARTIFY_PS1_OPTION_SET"' )

#  # $PROMPT_COMMAND already defined and is a valid function name
#  if [ ! -z "${PROMPT_COMMAND:-}" ]  &&  type $PROMPT_COMMAND >/dev/null 2>&1; then
#    #but not already augmented
#    if ! type $PROMPT_COMMAND | tail -n +3 | grep "TARTIFY_PS1_OPTION_SET" >/dev/null 2>&1; then
#      eval "$(echo -n  "$last2lines$minusLast2" | tail -r )"
#    #already augmented
#    else
#      return 0
#    fi
#  #default
#  else
#    export PROMPT_COMMAND="__tartify_prompt_command"
#  fi

#  export TARTIFY_PROMPT_COMMAND_SET="true"

#}


__tartify_reformat_timestamp(){
# prints a relative-formatted time string from unix timestamp
# arg: unix timestamp in seconds
# optional arg: true to include coloring
# copied from https://github.com/xtrementl/dev-bash-git-ps1.git
    local secs="$1"
    local yrs="$(( $secs / 31557600 ))"
    local div="$(( $secs % 31557600 ))"
    local days="$(( div / 86400 ))"
    div="$(( $secs % 86400 ))"
    local hrs="$(( $div / 3600 ))"
    div="$(( $secs % 3600 ))"
    local mins="$(( $div / 60 ))"

    # create the formatted time string
    local timestr
    [ 0 -lt "$yrs" ] && timestr="${yrs}y"
    if [ 0 -lt "$days" ]; then
        [ -n "$timestr" ] && timestr="$timestr,"
        timestr="${days}d"
    fi
    if [ 0 -lt "$hrs" ]; then
        [ -n "$timestr" ] && timestr="$timestr,"
        timestr="${timestr}${hrs}h"
    fi
    [ -n "$timestr" ] && timestr="${timestr},"
    timestr="${timestr}${mins}m"

    # TODO:
    # TARTIFY_STYLE_TIME_COULDCOMMIT
    # TARTIFY_STYLE_TIME_SHOULDCOMMIT
    # TARTIFY_SETTING_TIME_DISPLAY
    # TARTIFY_STRING_TIME_DISPLAY

    # add a hint of color
    if [ "$2" = "false" ] && [ -n "$TARTIFY_SETTING_TIME_BUGME" ]; then
    #if [ -n "$2" ] && [ -n "$TARTIFY_SETTING_TIME_BUGME" ]; then
        local color
        if [ $TARTIFY_SETTING_TIME_SHOULDCOMMIT -lt "$secs" ]; then # 30 mins
            color=$TARTIFY_COLOR_TIME_ACTIVITY_NON
        elif [ $TARTIFY_SETTING_TIME_COULDCOMMIT -lt "$secs" ]; then # 10 mins
            color=$TARTIFY_COLOR_TIME_ACTIVITY_LOW
        else
            color=$TARTIFY_COLOR_TIME_ACTIVITY_HIGH
        fi
        timestr="${color}${timestr}${__NN_}"
    fi
    echo "$timestr"
}


#------------------------------------------------------------------------------
#
#             TARTIFY commands
#
# All the following functions are intended for use from the tartify command and
# assume we are inside a GIT repository.
#
#------------------------------------------------------------------------------
#__tartify_repo_name()
#{
#  local _gitdir=$1
#  local updir=""; [ $2 = "false" ] && updir="/.." #don't go 1 level up for bare repo
#  local _nocolors=$3   #TRUE for no color
#  local color

#  # Print the REPO's name
#  color=$TARTIFY_COLOR_REPO_NAME
#  nocolor=$(echo `cd $_gitdir$updir; pwd` | sed 's,.*/,,' | tr -d '\n')
#  color=$color$nocolor
#  color=$color"${__NN_}"

#  [ "true" = $_nocolors ] &&  echo -ne $nocolor || echo -ne $color
#}


__tartify_repo_name()
{
  [ "QUIET" = "$mode" ]     && __tartify_reset_PS1_globs "REPO"
  local updir=""
  [ $isbare = "false" ] && updir="/.." #don't go 1 level up for bare repo
  local color
  local nocolor

  # Print the REPO's name
  color=$TARTIFY_COLOR_REPO_NAME
  nocolor=$(echo `cd $g$updir; pwd` | sed 's,.*/,,' | tr -d '\n')
  color=$color$nocolor
  color=$color"${__NN_}"

  [ "QUIET" = "$mode" ] && { __t4_rep=$nocolor; [ -z $__t4_rep ] || __t4_sepN=$separator; }
  [ "true" = $nocolors ] &&   tartanswer=$tartanswer$nocolor || tartanswer=$tartanswer$color
  #[ "true" = $nocolors ] &&   echo "nocolors true" || echo "nocolors false"
  #echo " [REPONAME before leaving] nocolor=$nocolor tartanswer=$tartanswer"
}


__tartify_branch(){
  # OLDSCHOOL _mode : output the same exact string __git_ps1 would
  #
  # VIM _mode
  #
  #   Return value:
  #
  #       $nci\|$branchname\|$merge_status
  #
  #     nci =~ /[U]?[S]?[IDAONGBE][T]?/    (nci : no colors info)
  #
  #        [U]nstaged modif(s)
  #
  #        [S]taged modif(s)
  #
  #       d[I]verged from remote
  #   behin[D] remote
  #        [A]head of remote
  #        [O]K (remote == HEAD)
  #        [N]o tracked remote
  #        [G]it directory
  #        [B]are repository
  #        [E]mpty repository
  #
  #        un[T]racked files,
  #
  #     merge_infos : either one of these values, or "" :
  #
  #        REBASE-i, REBASE-m, REBASE, AM, AM/REBASE, MERGING, CHERRY-PICKING,
  #        BISECTING
  #
  # QUIET _mode
  #
  # PS1 _mode
  #
  #   will use on-the-fly variable-NAMES creation
  #
  #     TOTO=2
  #     TATA=TO
  #     TITI=$(eval "printf "%s" "\$${TATA}TO"")

  case $mode in

    OLDSCHOOL)
      local f="$w$i$s$u"
      #printf "%s" "$c${b##refs/heads/}${f:+ $f}$r$p"
      tartanswer=$tartanswer$c${b##refs/heads/}${f:+ $f}$r$p
      #
      #printf "%s" "$c   ${b##refs/heads/}${f:+ $f}$r$p"
      #             $c   $b               $w       $i     $s    $u        $r           $p
      #             BARE:master           unstaged staged stash untracked rebase/merge upstream
      #
      #             [ branch name ]       [red]    [**]   [OLDSC] [underl] [??]
    ;;

    VIM)
      #IDAONGBE : SGBE already taken care of by __tartify_git_ps1()
      #          Determine AON (tracking branch info)
      #
      #          As S overrides all other IDAONGBE states, begin with this:
      case $p in
        '<>') idaongbe="I"  ;;
        '<')  idaongbe="D"  ;;
        '>')  idaongbe="A"  ;;
        '=')  idaongbe="O"  ;;
        *)    idaongbe="N"  ;;
      esac
      #NOCOLORSINFOS ($nci)
      local nci=$idaongbe
      [ -n "$w" ]      && nci=$nci"U"  #unstaged
      [ "+" =  "$i" ]  && nci=$nci"S"  #staged
      [ -n "$u" ]      && nci=$nci"T"  #untracked
      #RESULT
      tartanswer=$tartanswer$nci"|"${b##refs/heads/}$r #$r already includes the "|" separator
    ;;


    #HANDLED SEPARATELY
    PS1)
    ;;

    #__t4_tU=""   #           Unstaged
    #__t4_tuSr="" #           Staged                (stag-before-rem
    #__t4_tRA=""  #           remote Ahead of
    #__t4_tRD=""  #           remote behinD
    #__t4_tRI=""  #           remote dIverged
    #__t4_tRO=""  #           remote Ok (uptodate)
    #__t4_tRN=""  #           remote None
    #__t4_turS="" #           Staged                (stag-before-rem
    #__t4_TU=""   #UNtracked  Unstaged
    #__t4_TuSr="" #UNtracked  Staged                (stag-before-rem
    #__t4_TRA=""  #UNtracked  remote Ahead of
    #__t4_TRD=""  #UNtracked  remote behinD
    #__t4_TRI=""  #UNtracked  remote dIverged
    #__t4_TRO=""  #UNtracked  remote Ok (uptodate)
    #__t4_TRN=""  #UNtracked  remote None
    #__t4_TurS="" #UNtracked  Staged                (rem-before-stag

    NORMAL | QUIET)
      local bname=${b##refs/heads/}
      local bnameL=${#bname}

      [ "QUIET" = "$mode" ] && __tartify_reset_PS1_globs "BRANCH"

      # determine "remote info" color
      local prefix=""  # stores prefix for dynamic '__t4_' variable generation (QUIET mode)
      local bColRemote="" # stores color used in NORMAL mode
      case $p in
        '<>')  bColRemote=$TARTIFY_COLOR_BRANCH_UPSTREAM_DIVERGE  ; prefix="I" ;;
         '<')  bColRemote=$TARTIFY_COLOR_BRANCH_UPSTREAM_BEHIND   ; prefix="D" ;;
         '>')  bColRemote=$TARTIFY_COLOR_BRANCH_UPSTREAM_AHEAD    ; prefix="A" ;;
         '=')  bColRemote=$TARTIFY_COLOR_BRANCH_UPSTREAM_UPTODATE ; prefix="O" ;;
           *)  bColRemote=$TARTIFY_COLOR_BRANCH_UPSTREAM_NOTRACK  ; prefix="N" ;;
      esac
      local colUntracked=
      [ -n "$u" ] && colUntracked=$TARTIFY_STYLE_BRANCH_UNTRACKED

      # concatenate some
      local Unst=$TARTIFY_COLOR_BRANCH_UNSTAGED$colUntracked
      local Stag=$TARTIFY_COLOR_BRANCH_STAGED$colUntracked
      local Remo=$bColRemote$colUntracked

      local ll=$TARTIFY_SETTING_BRANCH_STAGED_INFO_LENGTH
      local remaind
      local res1=""; local res2=""; local res3=""

      # CASE1 both Staged and Unstaged changes
      if [ -n "$w" ] && [ "+" = "$i" ]; then
          remaind=$(($bnameL - ((2 * $ll)) ))
          [ $(($remaind <= 0)) -eq 1  ] && { remaind=$(($bnameL % 2)); ll=$(($bnameL / 2)) ; }

          [ -z $TARTIFY_SETTING_BRANCH_STAGED_INFO ] && {
              #URS [m]aste[r],[ma]st[er] ,[mas][ter], ...
              res1=${bname:0:$ll}
              res2=${bname:$ll:$remaind}
              res3=${bname:(($remaind + $ll )):$ll}
              [ "QUIET" = "$mode" ] && {
                  #update PS1 vars
                  [ -n "$u" ] &&  { __t4_TU=$res1; eval "__t4_TR$prefix=\$res2" ; __t4_TurS=$res3; } ||
                                  { __t4_tU=$res1; eval "__t4_tR$prefix=\$res2" ; __t4_turS=$res3; }
              } || {
                  #colors for NORMAL mode
                  res1=$Unst$res1; res2=$Remo$res2; res3=$Stag$res3$__NN_
              }
          } || {
              #USR [m][a]ster, [ma][st]er, [mas][ter], ...
              res1=${bname:0:$ll}
              res2=${bname:$ll:$ll}
              res3=${bname:(($ll * 2)):$remaind}
              [ "QUIET" = "$mode" ] && {
                  #update PS1 vars
                  [ -n "$u" ] &&  { __t4_TU=$res1; __t4_TuSr=$res2; eval "__t4_TR$prefix=\$res3"; } ||
                                  { __t4_tU=$res1; __t4_tuSr=$res2; eval "__t4_tR$prefix=\$res3"; }
              } || {
                  #colors for NORMAL mode
                  res1=$Unst$res1; res2=$Stag$res2; res3=$Remo$res3$__NN_
              }
          }

      # CASE2 only Unstaged changes
      elif [ -n "$w" ]; then
          remaind=$(($bnameL -  $ll))
          [ $(($remaind <= 0)) -eq 1  ] && { remaind=1; ll=$(($bnameL - 1)) ; }

          #URS & UR (m)aster,(ma)ster ,(mas)ter, ...
          res1=${bname:0:$ll}
          res2=${bname:$ll:$remaind}
          [ "QUIET" = "$mode" ] && {
              #update PS1 vars
              [ -n "$u" ] &&  { __t4_TU=$res1; eval "__t4_TR$prefix=\$res2"; } ||
                              { __t4_tU=$res1; eval "__t4_tR$prefix=\$res2"; }
          } || {
              #colors for NORMAL mode
              res1=$Unst$res1; res2=$Remo$res2$__NN_
          }

      # CASE3 only Staged changes
      elif [ "+" = "$i" ]; then
          remaind=$(($bnameL -  $ll  ))
          [ $(($remaind <= 0)) -eq 1  ] && { remaind=1; ll=$(($bnameL - 1)) ; }
          [ -z $TARTIFY_SETTING_BRANCH_STAGED_INFO ] && {
              #RS maste[r],mast[er] ,mas[ter], ...
              res1=${bname:0:$remaind}
              res2=${bname:$remaind:$ll}
              [ "QUIET" = "$mode" ] && {
                  #update PS1 vars
                  [ -n "$u" ] &&  { eval "__t4_TR$prefix=\$res1" ; __t4_TurS=$res2; } ||
                                  { eval "__t4_tR$prefix=\$res1" ; __t4_turS=$res2; }
              } || {
                  #colors for NORMAL mode
                  res1=$Remo$res1; res2=$Stag$res2$__NN_
              }
          } || {
              #SR [m]aster, [ma]ster, [mas]ter, ...
              res1=${bname:0:$ll}
              res2=${bname:$ll:$remaind}
              [ "QUIET" = "$mode" ] && {
                  #update PS1 vars
                  [ -n "$u" ] &&  { __t4_TuSr=$res1; eval "__t4_TR$prefix=\$res2"; } ||
                                  { __t4_tuSr=$res1; eval "__t4_tR$prefix=\$res2"; }
              } || {
                  #colors for NORMAL mode
                  res1=$Stag$res1; res2=$Remo$res2$__NN_
              }
          }
      # CASE4 no changes in index
      else
        res1=$bname
        [ "QUIET" = "$mode" ] && {
            #update PS1 vars
            [ -n "$u" ] &&  { eval "__t4_TR$prefix=\$res1"; } ||
                            { eval "__t4_tR$prefix=\$res1"; }
          } || {
              #colors for NORMAL mode
              res1=$Remo$res1$__NN_
          }
      fi

      [ "NORMAL" = "$mode" ] && tartanswer=$tartanswer$c$res1$res2$res3$r$__NN_
      #dynamic separator in QUIET mode
      [ "QUIET" = "$mode" ] && [ ! -z $bname ] && __t4_sepB=$separator

    ;;



  esac

  return 0

}


__tartify_remote2(){
  [ "OLDSCHOOL" = "$mode" ] && return 0
  return 0
}


__tartify_remote()
{
  # OLDSCHOOL :
  #
  #    #:no upstream

  local _gitdir=$1
  local _nocolors=$2   #TRUE for no color
  local color
  local nocolor

  local branchname=$(git branch 2>/dev/null| sed -n '/^\*/s/^\* //p')
  color="  "$__NN_

  # NON-EMPTY GIT REPO
  # VERIFY that .git/refs/heads/ directory is not empty
  if [ $(ls $_gitdir/refs/heads/ | wc -l) -gt 0 ]
  then

    # ------- REMOTES INFO ( + BRANCH TRACKED ) --------
    local marker
    local marker_color
    local before_traked
    local after_tracked
    local before_untraked
    local after_untracked

    # loop through remotes
    for remotename in $(git remote show); do

      # special markers for origin and upstream
      # nb: a tracked remote is preceded by a little ➝ symbol
      case $remotename in
          origin)   marker="O"; marker_color=$TARTIFY_COLOR_REMOTE_NAME_ORIGIN   ;;
        upstream)   marker="U"; marker_color=$TARTIFY_COLOR_REMOTE_NAME_UPSTREAM ;;
                *)   marker="⇧"; marker_color=$TARTIFY_COLOR_REMOTE_NAME_OTHER    ;;
      esac

      # CURRENT BRANCH is tracked to CURRENT REMOTE ?
      if [[ $(git config --get branch.$branchname.remote) =~ $remotename ]]
      then
        [ "true" = $_nocolors ]  &&  {
                              before_traked=" ➝ "; after_tracked="";
                              before_untraked=" "; after_untracked="";
                            } || {
                              before_traked=" ➝${__EM_} "; after_tracked="${_EMQ_}";
                              before_untraked=" "; after_untracked="";
                            }
      else
        before_traked=""; after_tracked="";before_traked=" "; after_tracked="";
      fi


      # nb of commits AHEAD/BEHIND
      local ahead_count="$(__tartify_diff_count $remotename/$branchname HEAD)"
      local behind_count="$(__tartify_diff_count HEAD $remotename/$branchname)"
      local diffcount=""
      local diffcountnocol=""
      if [ 0 -lt "$ahead_count" ]; then
          diffcount="${TARTIFY_COLOR_REMOTE_COUNT_AHEAD}${ahead_count}"
          diffcountnocol="+${ahead_count}"
      fi

      if [ 0 -lt "$behind_count" ]; then
          [ -n "$diffcount" ] && {
                  diffcount=${diffcount}${marker_color}$TARTIFY_STRING_REMOTE_COUNT_SEP
                  diffcountnocol=${diffcountnocol}$TARTIFY_STRING_REMOTE_COUNT_SEP
                }
          diffcount="${diffcount}${TARTIFY_COLOR_REMOTE_COUNT_BEHIND}${behind_count}"
          diffcountnocol="${diffcountnocol}-${behind_count}"
      fi

      [ -n "$diffcount" ] && diffcount=" ${marker_color}($diffcount${marker_color}) "
      [ -n "$diffcountnocol" ] && diffcountnocol=" ($diffcountnocol) "
      #echo "$diffcount"


      color=$color"${marker_color}${before_traked}${marker}${after_tracked}${diffcount}${__NN_}"
      nocolor=$nocolor"${before_traked}${marker}${after_tracked}${diffcountnocol}"

    done
  fi

  [ "true" = $_nocolors ] &&  echo -ne $nocolor || echo -e $color

 #TODO: oldschool
      #if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
      #  __git_ps1_show_upstream
      #fi

}


#optimized
__tartify_stash()
{
  [ "OLDSCHOOL" = "$mode" ] && return 0
  [ "QUIET" = "$mode" ]     && __tartify_reset_PS1_globs "STASH"

  local color
  local nocolor
  #? are we inside a GIT repo's working tree
  if [ "true" = "$isinsideworktree" ]; then
    if [ "true" = "$hasstash" ]; then
      if [ -n "$TARTIFY_SETTING_COUNTSTASHES" ]; then
        # One star per stash
        color=$TARTIFY_COLOR_STASH_COUNT
        #nocolor="  "
        local n
        #! `git stash list | wc -l` adds about 50ms
        for (( n=0; n< $(git stash list | wc -l); n++ ))
        do
          nocolor=$nocolor$TARTIFY_STRING_STASH
        done
        #nocolor=$nocolor" "
        [ "QUIET" = "$mode" ] && __t4_ST=$nocolor
      else
        color=$TARTIFY_COLOR_STASH_NOCOUNT
        nocolor=$TARTIFY_STRING_STASH
        [ "QUIET" = "$mode" ] && __t4_st=$nocolor
      fi
      color=$color$nocolor${__NN_}
    fi
    [ "true" = $nocolors ] &&   tartanswer=$tartanswer$nocolor || tartanswer=$tartanswer$color
  fi
}


__tartify_timelastcommit(){
  #TODO: COLORS !!!!!!!
  local _nocolors=$1           #TRUE for no color
  local color
  local nocolor

  #? are we inside a GIT repo
  if git rev-parse --git-dir >/dev/null 2>&1; then
    # calc relative time diff of last commit
    local secs="$(
      # get the unix timestamp for the lastest commit (seconds)
      # copied from https://github.com/xtrementl/dev-bash-git-ps1.git
          local now="$(date +%s)"
          local last_commit="$(git log --format='%at' -1 2>/dev/null)"
          if [ -z "$last_commit" ]; then # probably initial git init, no commits
              return
          fi
          if [ 0 -lt "$now" ] && [ 0 -lt "$last_commit" ]; then
              echo "$((now - last_commit))"
          fi
    )"
    #TODO: include $_nocolors
    [ -n "$secs" ] && echo -e "$(__tartify_reformat_timestamp $secs $_nocolors)"
  fi
}

#------------------------------------------------------------------------------
#
#             TARTIFY
#
#------------------------------------------------------------------------------

tartify()
{
  local argstr="$*"
  local forceDefaultSep=""

  # (optionnal) argument expansion
  #TODO: these tests suck
  [ "$argstr"  = "w" ] && argstr="nbrslw"                           #newline after
  [ "$argstr"  = "W" ] && argstr="nbrslW"                           #newline before
  [ "$argstr" = "Ww" ] || [ "$argstr" = "wW" ] && argstr="nbrslwW"  #newline BOTH
  #expand some mono-character options
  [ "$argstr"  = "o" ] && { argstr="obsr";   forceDefaultSep=true ; } #oldschool
  [ "$argstr"  = "v" ] && { argstr="vnbrsl";                        } #vim
  [ "$argstr"  = "p" ] && { argstr="pnbrsl"; forceDefaultSep=true ; } #PS1
  [ "$argstr"  = "q" ] && { argstr="qnbrsl"; forceDefaultSep=true ; } #QUIET mode
  [ ${#argstr} -eq 0 ] && { argstr="nbrsl";                         } #no args


  # -- PARSE help options and exit --
  # do that first to enable testing if 'tartify' is present with exit value of zero

  # Help
  [[ "$argstr" =~ h ]] && { __tartify_usage; return 0; }
  [[ "$argstr" =~ e ]] && { __tartify_show_env; return 0; }
  # PS1 building (done here because it has to work wether wether we're
  # in a GIT dir or not
  [[ "$argstr" =~ p ]] && { __tartify_build_PS1 $argstr; return 0; }

  # Override args with $TARTIFY_SETTING_FORCE if non empty
  [ -n "$TARTIFY_SETTING_FORCE" ] && argstr=$TARTIFY_SETTING_FORCE


  # -- INIT tartify local vars --
  local tartanswer=""
  local isbare="false"
  local isinsideworktree="false"
  local hasstash="false"
  local hasupstream="false"
  local nocolors="false"
  local mode="NORMAL"

  local staged_info=""  # (VIM mode) branch status - store either one of these letters (US)
  local idaongbe=""     # (VIM mode) branch status - store either one of these letters (IDAONGBE)
  local pre_idaongbe="" # (VIM mode) branch status - store either one of these letters (US)
                        # used by __tartify_branch()

  local upstream=git legacy="" verbose=""  # moved here from original __git_ps1_showupstream
  local processupstream="false"  # check if current branch is tracked to a remote, and ahead/behind state
                                 # used by __tartify_branch()
                                 #         __tartify_remote()

  local processremotes="false"   # used by __tartify_remote()

  # -- INIT __git_ps1 locals --
  local g=""   #GITDIR
  local r=""   #REBASE/MERGE/... info
  local b=""   #BRANCH
  local w=""   #UNSTAGED indicator "*"
  local i=""   #STAGED indicator "+"  or NO COMMIT YET in HEAD "#"
  local s=""   #STASH state $
  local u=""   #UNTRACKED files %
  local f=""   #"$w$i$s$u"  UNSTAGED STAGED STASH UNTRACKED
  local c=""   #BARE: prefix to $b (BRANCH)
  local p=""   #UPSTREAM info || empty string


  # -- BAIL if not INSIDE a GIT REPO --
  g=`git rev-parse --git-dir 2>/dev/null`
  [ $? -eq 0  ] && {

    #TODO: DEPREC ????
    #Perform all cheap 'git' tests (used in more than one '__tartify_*' function)
    isbare=$( git rev-parse --is-bare-repository 2>/dev/null )
    isinsideworktree=$(git rev-parse --is-inside-work-tree 2>/dev/null)
    if [ "true" = "$isinsideworktree" ]; then
      git rev-parse --verify refs/stash >/dev/null 2>&1 && hasstash="true"
    fi
    git rev-list  @{upstream}...HEAD >/dev/null 2>&1                  # 8ms
    [ $? -eq 0 ] && hasupstream="true" || hasupstream="false"




    local separator=""
    #force default separator if need be
    [ -z "$forceDefaultSep" ] || {
      separator=$TARTIFY_STRING_SEPARATOR
      [ -z $separator ] && separator=' '
    }

    local n
    #
    # PRE-PARSING (modes)
    #
    for ((n=0;n<${#argstr};n++))
    do
      local ch=${argstr:$n:1}
      case $ch in

        # -- MODES --

        # No Colors MODE : strip all color info, whatever the result
        c)  nocolors="true"         ;;
        # Vim MODE : no color, prepend color infos for 'branch', use 'vimsplitsep' as separator
        v)
          nocolors="true"
          mode="VIM"
          # don't fucking change that:
          separator="vimsplitsep"
                                    ;;
        # OldSchool MODE : no color, branch results with $*+, stash results with %
        o)
          nocolors="true"
          mode="OLDSCHOOL"
                                    ;;
        # Quiet mode (only update the __TART4PS1* variables)
        # ($tartanswer is discarded)
        q) mode="QUIET"
           #__t4_del=$__NN_
                                    ;;

        # PS1 mode (ansi color codes escaped with '\[' and '\]' for PS1
        p) mode="PS1"               ;;

        # SUCCINT (SHORT) mode
        i) mode="SHORT"             ;;

        # CHATTERBOX (LOOONG) mode
        a) mode="LONG"              ;;

        # -- MODAL ARGS --

        u|U) processupstream="true" ;;
        r|R) processupstream="true"; processremotes="true"  ;;
          b) processupstream="true" ;; #only colored version of 'branch' needs upstream info
          o) [ -n "${GIT_PS1_SHOWUPSTREAM-}" ] && processupstream="true" ;; #oldschool

        # -- MODIFIERS --
        t) ;; # no upstream in branch TODO:
      esac
    done

    #
    # PRE-PROCESSING
    #

    # fill $upstream if any
    [ "true" = "$processupstream" ] && __tartify_git_ps1_find_upstream

    # Fill in __git_ps1 locals
    __tartify_git_ps1

    #
    # PROCESSING
    #
    local firstn="true" #don't insert separator before first item
    local delimNb=0     #delimiter's position
    tartanswer=""
    for ((n=0;n<${#argstr};n++))
    do
      [ -z $firstn ] && [ ! -z "$separator" ] && tartanswer=$tartanswer$separator

      local ch=${argstr:$n:1}
      case $ch in
        #n) tartanswer=$tartanswer$( __tartify_repo_name $g $isbare                                   $nocolors);;
        n)
          __tartify_repo_name
          ;;
        b)
          __tartify_branch
        ;;
        #r) tartanswer=$tartanswer$( __tartify_remote    $g                                           $nocolors);;
        #TODO:
        r) tartanswer=$tartanswer$( __tartify_remote2 );;
        #TODO:
        #u) tartanswer=$tartanswer$( __tartify_remote    $g                                           $nocolors);;
        s)
          __tartify_stash
        ;;
        #TODO:
        l) tartanswer=$tartanswer$( __tartify_timelastcommit                                              $nocolors);;
        c) ;;
        o) ;;
        p) ;;
        i) ;;
        a) ;;
        q) ;;
        t) ;;
        v) ;;
        w) ;;
        W) ;;
        #TODO: make that issue ansi escapes (PS1 and standard mode)
        \\) tartanswer=$tartanswer$TARTIFY_COLOR_MISC_DELIMITER$ch$__NN_;;
        #TODO: make that work with PS1 and NOCOLORS
        *)
          tartanswer=$tartanswer$TARTIFY_COLOR_MISC_DELIMITER$ch$__NN_

          if [ "QUIET" = $mode ]; then
            [ " " = "$ch" ] && eval "__t4_D$delimNb=\" \"" || eval "__t4_D$delimNb=\"$ch\""
          fi
          delimNb=$((delimNb + 1))
          ;;
      esac
      unset firstn
    done

    # Post Process
    # VIM mode : remove first occurence of $separator
    [ "$mode" = "VIM" ] && tartanswer=${tartanswer/#vimsplitsep/}

    # -- OUTPUT --

    # TODO: this test sucks (time lost in subshell)
    # remove ansi escapes
    local testforblank=$(echo  $tartanswer | sed -E "s/\\\\033\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g")
    testforblank=${testforblank/ //}

    #[ "QUIET" = "$mode" ] && return 0
    if [ "QUIET" = "$mode" ]; then
      [ ${#testforblank} != 0 ] && {
        [[ "$argstr" =~ W ]] &&  __t4_newline_before=$(echo -ne "\n ")
        [[ "$argstr" =~ w ]] &&  __t4_newline_after=$(echo -ne "\n ")
      }
      return 0
    fi

    #TODO: 'w' newline insertion can happen anywhere, 'W' only at BOL
    # only do something if answer is not empty
    [ ${#testforblank} != 0 ] && {
      [[ "$argstr" =~ W ]] && {
        echo -ne "\n" # linebreak before
      }
      echo -ne $tartanswer
      [[ "$argstr" =~ w ]] && {
        echo -ne "\n" # linebreak after
      }
    }
  } || __tartify_reset_PS1_globs ALL
  return 0
}


#------------------------------------------------------------------------------
#
#             TARTIFY ADDONS
#
#------------------------------------------------------------------------------


tartitune(){
  # Quick tuner for tartify's COLOR-RELATED environment variables
  # (with completion)

  local myargs=$(echo "$*" | tr '[A-Z]' '[a-z]' | tr '-' ' ' | sed 's/tartify_//g')
  [ -z "$myargs" ] && { tartify e; return 0; }
  local myansw
  local mytest
  local myarg
  local myenv
#echo "myargs=$myargs"
  for myarg in $myargs; do
    case $myarg in

      # ENV VARS
      style_*|color_*) myenv=$myenv$myarg" "
#echo "myarg=$myarg"
                                      ;;

      # STYLES
      bold|emphasized)   myansw=$myansw$__EM_ ;;  underlined)        myansw=$myansw$__UN_ ;;
      i*)        myansw=$myansw$__RV_ ;;

      # COLORS
      black)     myansw=$myansw$__K_  ;;  red)        myansw=$myansw$__R_  ;;
      green)     myansw=$myansw$__G_  ;;  yellow)     myansw=$myansw$__Y_  ;;
      blue)      myansw=$myansw$__B_  ;;  magenta)    myansw=$myansw$__M_  ;;
      cyan)      myansw=$myansw$__C_  ;;  white)      myansw=$myansw$__W_  ;;

      # BACKGROUND COLORS
      bgblack)   myansw=$myansw$__BGK_ ;;  bgred)      myansw=$myansw$__BGR_;;
      bggreen)   myansw=$myansw$__BGG_ ;;  bgyellow)   myansw=$myansw$__BGY_;;
      bgblue)    myansw=$myansw$__BGB_ ;;  bgmagenta)  myansw=$myansw$__BGM_;;
      bgcyan)    myansw=$myansw$__BGC_ ;;  bgwhite)    myansw=$myansw$__BGW_;;

      # MISC
      test)      mytest="t"          ;;
      export)    mytest="t"          ;;

      # HELP
      h|help|?) cat <<HELPMSG

${__EMR_}NAME
     tartitune${__NN_} -- Quick color changer for ${__EM_}tartify${__NN_}

${__EMR_}SYNOPSIS${__NN_}
     ${__EMR_}tartitune${__NN_} [${__EMR_}-SHORTNAME${__NN_}][${__EMG_}TARTIFY_* ...${__NN_}][${__EMG_}compound${__NN_}]

${__EMR_}DESCRIPTION${__NN_}
     The order of command line arguments doesn't matter. When used
     without arguments, ${__EMR_}tartitune${__NN_} pretty prints a list of
     ALL tartify environment variables with their current value
     (same as \`tartify e\`)

     The options have the following meaning:

     ${__EMG_}TARTIFY_*${__NN_}
           any sequence of TARTIFY_COLOR_... or TARTIFY_STYLE_...
           environment variables, by full name (eg: TARTIFY_COLOR_BRANCH_STAGED)
                -> case insensitive
                -> run ${__EMR_}tartitune${__NN_} without any argument to get a complete
                   list of ALL tartify environment variables with their
                   current value)
                -> use ${__EMG_}T+completion${__NN_} to loop through ${__EM_}full${__NN_} names

     ${__EMR_}-SHORTNAME${__NN_}
           any sequence of TARTIFY_COLOR or TARTIFY_STYLE
           environment variables, by short name (eg: -COLOR_STAGED),
           prefixed with a ${__Y_}single-dash${__NN_}

            -> case insensitive
            -> use ${__EMG_}dash+completion${__NN_} to loop through ${__Y_}short${__NN_} names

           If no environement variable is specified, ${__EMR_}tartitune${__NN_}
           will print the compound color corresponding to ${__EMG_}compound${__NN_}
           to STDOUT

     ${__EMG_}compound${__NN_}  a list of any of the following words (case insensitive,
           use completion to loop through)

        ${__EMG_}*${__NN_} ${__G_}colors & styles${__NN_}
           ${__EM_}bold${__NN_}    ${__EM_}emphasized${__NN_} ${__UN_}underlined${__NN_} ${__RV_}inverse${__NN_}

           ${__K_}black${__NN_}   ${__R_}red${__NN_}        ${__G_}green${__NN_}     ${__Y_}yellow${__NN_}
           ${__B_}blue${__NN_}    ${__M_}magenta${__NN_}    ${__C_}cyan${__NN_}      ${__W_}white${__NN_}

           ${__BGK_}BGblack${__NN_} ${__BGR_}BGred${__NN_}      ${__K_}${__BGG_}BGgreen${__NN_}   ${__K_}${__BGY_}BGyellow${__NN_}
           ${__K_}${__BGB_}BGblue${__NN_}  ${__K_}${__BGM_}BGmagenta${__NN_}  ${__K_}${__BGC_}BGcyan${__NN_}    ${__K_}${__BGW_}BGwhite${__NN_}

        ${__EMG_}*${__NN_} ${__G_}Other${__NN_} ${__EM_}${__NN_}
           test      doesn't modify any environment variable, just simulates.
           export    print out the current TARTIFY environment in a form
                     that can be reused for initializing tartify (only the
                     diff with the default environmen is output)

${__EMR_}EXAMPLES${__NN_}

      ${__K_}\$ tartitune TARTIFY_COLOR_BRANCH_STAGED bold magenta${__NN_}
      ${__K_}\$ tartitune -COLOR_BRANCH_STAGED bold blue underline verbose${__NN_}
      TARTIFY_COLOR_BRANCH_STAGED (${__EMM_}was${__NN_}) (${__EMB_}${__UN_}now is${__NN_})
      ${__K_}\$ tartitune -COLOR_BRANCH_STAGED -COLOR_BRANCH_UPTODATE r i test${__NN_}
      TARTIFY_COLOR_BRANCH_STAGED (${__EMB_}${__UN_}was${__NN_}) (${__EMR_}${__RV_}*TEST*${__NN_})
      TARTIFY_COLOR_BRANCH_UPSTREAM_UPTODATE (${__EMG_}was${__NN_}) (${__EMR_}${__RV_}*TEST*${__NN_})
      ${__K_}\$ tartitune test bold cyan${__NN_}
      ${__EMC_}*TEST*${__NN_}
      ${__K_}\$ tartitune un yellow; echo \"colored string\"${__NN_}
      ${__Y_}${__UN_}colored string${__NN_}
      ${__K_}\$ MYENVVAR=\$(tartitune bo r); echo \$MYENVVAR\"colored string\"${__NN_}
      ${__EMR_}colored string${__NN_}

HELPMSG
        return 0                      ;;

     *) echo "Unknown argument $myarg"
        return 1
                                      ;;
    esac
  done;


  # OUTPUT
  [ -n "$myenv" ] && {
        # WITH ENV
        local thisenv
        for thisenv in $myenv; do
            thisenvUP="TARTIFY_"$(echo $thisenv | tr '[a-z]' '[A-Z]')
            [ -n "$myansw" ] && {
                printf "\n%s" "$thisenvUP ($(eval printf "%s" "\$$thisenvUP")was$__NN_)"
                [ "t" = "$mytest" ] && printf " %s\n" " (${myansw}*TEST*$__NN_)"|| {
                    printf " %s\n" " (${myansw}now is$__NN_)"
                    #ASSIGN env variable
                    eval "$thisenvUP=$myansw"
                }
            } || {
                printf "\n%s\n" "no option set."
                printf "%s\n" "$thisenvUP ($(eval printf "%s" "\$$thisenvUP")is$__NN_)"
            }
        done
        echo
  } || {
      # NO ENV
      [ "t" = "$mytest" ] && printf "%s\n" "${myansw}*TEST*$__NN_" || printf "%s" "${myansw}"
  }

}


__tartitune_completion()
{
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    optsVAR=$(env | grep "^TARTIFY_COLOR\|^TARTIFY_STYLE" | awk -F"=" '{printf("-%s ", $1)}' | sed 's/TARTIFY_//g')
    optsVARLONG=$(env | grep "^TARTIFY_COLOR\|^TARTIFY_STYLE" | awk -F"=" '{printf("%s ", $1)}')

    optsARG="bold emphasized underlined inverse black red green yellow
    blue magenta cyan white bgblack bgred bggreen bgyellow bgblue
    bgmagenta bgcyan bgwhite test help "

    #if [[ ${cur} == T* ]] ; then
    if [[ ${cur} == -* ]] ; then
        COMPREPLY=( $(compgen -W "${optsVAR}" -- ${cur}) )
        return 0
    elif [[ ${cur} == T* ]] ; then
        COMPREPLY=( $(compgen -W "${optsVARLONG}" -- ${cur}) )
        return 0
    else
        COMPREPLY=( $(compgen -W "${optsARG}" -- ${cur}) )
        return 0
    fi
}




#------------------------------------------------------------------------------
#
#             MAIN
#
#------------------------------------------------------------------------------

__tartify_define_colors_TPUT
__tartify_reset_PS1_globs ALL
#__tartify_init_PS1_globs
#__tartify_init_PS1_globs_EXPORT
__tartify_init_globs

# ADDONS

##TODO: ZSH compatibility
#if [[ -n ${ZSH_VERSION-} ]]; then
#  autoload -U compinit
#  autoload -U +X bashcompinit && bashcompinit
#fi

#if [[ -n ${ZSH_VERSION-} ]]; then
#  emulate -L bash
#  setopt KSH_TYPESET

#  # workaround zsh's bug that leaves 'words' as a special
#  # variable in versions < 4.3.12
#  typeset -h words
#fi

complete -F __tartitune_completion tartitune

#DEPREC:
#export __tartify_shell_loaded=1

# script is being executed, run the main command
# script is being sourced, exit with 0
[ "$__tartify_whocalled" = "exec" ] && tartify $__tartify_args || return 0


# REMOVE ANSI ESCAPE from string
# MACOS
# echo  $TOTO | sed -E "s/\\\\033\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
# LINUX
#               sed -r


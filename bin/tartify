#!/bin/bash
##################################################################################
#
#       Filename:  tartify
#
#    Description:  BASH PS1 with GIT support
#
#                  Colored command prompt adapted to GIT repository. VERY
#                  colorfull, not for the faint hearted
#
#  Configuration:  place this file somewhere in your PATH and source it in your
#                  .bashrc
#
#                     source /path/to/bashps1
#
#   Dependencies:  Depends on GIT, might work on windows with Cygwin
#
#   GVIM Version:  1.7+ (?)
#
#         Author:  Pierre Lhoste
#        Twitter:  http://twitter.com/peterhost
#
#        Version:  0.1
#        Created:  01.05.2011
#        License:  WTFPL V2
#
# DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE Version 2, December 2004
#
# Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>
#
# Everyone is permitted to copy and distribute verbatim or modified
# copies of this license document, and changing it is allowed as long as
# the name is changed.
#
#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE TERMS AND
#            CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
#
#  0. You just DO WHAT THE FUCK YOU WANT TO.
#
#------------------------------------------------------------------------------
#

# USAGE : Just call the tartify() function from the command line
#
#         PROMPT integration : call tartify() inside your $PS1. Examples:
#
#           PS1="\$(tartify) [\u@\h]\$ "
#           PS1="\$(tartify)\n[\u@\h]\$ "
#           ...
#
#         You can also pass arguments to tartify() to make it display only
#         certain informations
#
#           tartify -h
#
#

#PS1="${__PS1NN_}${__PS1EMK_}[${__PS1UC_}\u${__PS1EMK_}@${__PS1EMUC_}\h ${__PS1C_}\${NEW_PWD}${__PS1EMK_}] \$"
#PROMPT_COMMAND=tartify
#
#
#
#------------------------------------------------------------------------------
#
# ISSUE :
#
#   * no support for SVN upstream (as I don't use SVN), feel free to augment
#     this script
#
#

#   * conditionnal newline : there is no such thing in a prompt. Either a
#   newline is hardcoded in the prompt, or it's not. All linebreak(s) inserted
#   by an external command called in the PS1 variable via "$(command)" are
#   stripped out when $PS1 is evaluated.
#
#   Solution: if you need a multiline prompt, with the 'tartify' line only
#   inserted if you're being in a 'git' repository, consider using a
#   PROMPT_COMMAND like this :
#
#     prompt_command(){
#       ...
#       tartify w
#     }
#     PROMPT_COMMAND=prompt_command
#
#   The 'w' option to tartify issues a newline if the contents of \`tartify\`
#   is not an empty string.
#
#   * Line Wrapping Calculation
#
#     The one thing (that I know of) which confuse line wrapping (when browsing
#     command history with long lines, for ex) is non-printable characters
#     (such as ansi escape color codes, cursor movement,...). So:
#
#       1 - non-printable characters in the PS1 variable have to be "escaped"
#       by enclosing them between a pair of escaped brackets :
#
#           \[\033[0;30m\]   instead of  \033[0;30m
#
#       And this has to be done at PS1 definition-time, as PS1 is only assigned
#       ONCE but evaluated at EACH PROMPT.
#
#       2 - function calls inside the PS1 variable that issue non-printable
#       characters will confuse the prompt, naturally, if the said n-p-chars
#       are not escaped IN the PS1 variable itself at assignement time. Example :
#
#               PS1=">"
#               > pwd
#               /some/dir
#               > myfunc(){ echo  "\[\033[0;30m\]\$(pwd) > \[\033[0m\]"; }
#               > myfunc
#               \[\033[0;30m\]$(pwd) > \[\033[0m\]
#
#           this will work
#               > PS1=$(myfunc)
#               /some/dir > echo $PS1
#               \[\033[0;30m\]$(pwd) > \[\033[0m\]
#               /some/dir > cd tmp
#               /some/dir/tmp >
#
#            this won't:
#               /some/dir/tmp > PS1='$(myfunc)'
#               \[\]stevejobs~ echo $PS1
#               $(myfunc)

#            As you can see in the latter, there are no escaped ansi codes
#            whatsoever, just a function call.  the prompt will print
#            litterally '\[\033[0;30m\]' each time, as this escaped substring
#            was not hardcoded in the PS1 variable at the time when it was
#            assigned, but generated by a function call evaluated for each
#            prompt, INSIDE the PS1 variable

#       MORE: on the subject
#       http://www.issociate.de/board/post/481503/bash_command_substitution,_functions_and_quoting_:_need_help.html
#
#     Problem is : if a function used in the PS1 variable is to adapt it's colored
#                  output according to context, there is no way to hardcode that
#                  directly in $PS1 with the '\[' escapes.
#
#       -> better use `printf` rather than `echo` (which somewhat sucks and which
#       behaviour is inconsistant across shells and OSes)
#
#       OR...
#       -> need to be issued on a line prior to the last line of the prompt, with :
#           * either \n insertion,
#
#               PS1="\$(tartify)\n$ "
#
#           * or use of the PROMPT_COMMAND environment variable
#
#               __somefunc() {
#                 ...
#                 tartify
#                 ...
#               }
#               export PROMPT_COMMAND=__somefunc
#               PS1=...
#
#       otherwise they will confuse wrapping too. Hence, your PS1 better look
#       something like :
#
#
#
#       (SEE:http://hintsforums.macworld.com/archive/index.php/t-17068.html)
#
#    * Quick n dirty benchmark
#      loop over 1000 executions of `tartify` on a 3.06GHz Intel Core 2 Duo Imac
#      without any methodology
#
#       **execution-time (ms)**
#       _____________________________________________________________
#      |    REPO   | TINY       | SMALL     | MEDIUM    | LARGE      |
#      |           | ms   %     | ms   %    | ms   %    | ms   %     |
#      |___________|____________|___________|___________|____________|
#      |    remote | 48   25%   | 59   29%  | 92   27%  | 93  23%    |
#      |   1 stash | 56   30%   | 56   28%  | 179  52%  | 202 50%    |
#      |    branch | 60   32%   | 63   31%  | 46   13%  | 81  20%    |
#      |      repo | 14    7%   | 13    6%  | 13    4%  | 14   3%    |
#      |  timelast | 11    6%   | 11    5%  | 12    3%  | 12   3%    |
#      |           |            |           |           |            |
#      |     total | 189        | 202       | 342       | 402        |
#      |           |            |           |           |            |
#      | __git_ps1 |            |           |           | 63         |
#      |___________|____________|___________|___________|____________|
#
#
#------------------------------------------------------------------------------
#
# NOTA :
#          Special Character Codes
#          \a – an ASCII bell character (07)
#          \d – the date in “Weekday Month Date” format (e.g., “Tue May 26″)
#          \D{format} – the format is passed to strftime(3) and the result is inserted into the prompt string; an empty format results in a locale-specific time representation. The braces are required
#          \e – an ASCII escape character (033)  (hence : \e and \033 are equivalent)
#          \h – the hostname up to the first `.’
#          \H – the hostname
#          \j – the number of jobs currently managed by the shell
#          \l – the basename of the shell’s terminal device name
#          \n – newline
#          \r – carriage return
#          \s – the name of the shell, the basename of $0 (the portion following the final slash)
#          \t – the current time in 24-hour HH:MM:SS format
#          \T – the current time in 12-hour HH:MM:SS format
#          \@ – the current time in 12-hour am/pm format
#          \A – the current time in 24-hour HH:MM format
#          \u – the username of the current user
#          \v – the version of bash (e.g., 2.00)
#          \V – the release of bash, version + patchelvel (e.g., 2.00.0)
#          \w – the current working directory
#          \W – the basename of the current working directory
#          \! – the history number of this command
#          \# – the command number of this command
#          \$ – if the effective UID is 0, a #, otherwise a $
#          \nnn – the character corresponding to the octal number nnn
#          \\ – a backslash
#          \[ - begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt
#          \] – end a sequence of non-printing characters
#
#          (http://www.wiredrevolution.com/bash-programming/customize-the-bash-ps1-command-prompt)



#------------------------------------------------------------------------------
#
#             PRELIMINARY CHECKS
#
#------------------------------------------------------------------------------
# store command line params
__tartify_args="$*"

# Are we being sourced or executed ?
Prog="tartify"
__tartify_whocalled=
if [ "$(basename $0 2>/dev/null )" = "$Prog" ]; then
  __tartify_whocalled="exec"
else
  __tartify_whocalled="source"
fi



#------------------------------------------------------------------------------
#
#             SHELL DETECTION
#
#------------------------------------------------------------------------------

## SHELL detection
## SHELL      DARWIN      LINUX
## sh         path/to/sh  sh
## csh        -sh         -sh
## tcsh       -csh        -csh
## ksh        ksh         ksh
## bash       -bash       bash
## zsh        zsh         zsh

#__thisShell=`ps $$ | grep $$ | awk '{ print $5 }' | sed 's/\-/\\\-/g'`
#echo $__thisShell
#__thisShell=$(basename $__thisShell)
#echo $__thisShell
## Darwin detection
#if uname -s | grep "Darwin" >/dev/null 2>&1
#then
#  __OSflavor="Darwin" # macos
#fi

## BAIL if using SH on OSX, (scrambles "echo -ne" commands)
#[ "$__OSflavor" = "Darwin" ] && [ "$__thisShell" = "sh" ] && { echo " SH detected, exit";  exit 1; }

#------------------------------------------------------------------------------
#
#             MISC GLOBAL VARIABLES
#
#------------------------------------------------------------------------------

__tartify_define_colors() {
# COLOR VARS : declare those ANSI color codes in variables ONCE and for ALL.
#              This somewhat pollutes the GLOBAL SCOPE but the variable names
#              are (thought to be) unique enough so that won't cause problems
#
# Define Colors (to be used in standard echo & printf commands)

  # regular colors
  export __K_="\033[0;30m"    # black
  export __R_="\033[0;31m"    # red
  export __G_="\033[0;32m"    # green
  export __Y_="\033[0;33m"    # yellow
  export __B_="\033[0;34m"    # blue
  export __M_="\033[0;35m"    # magenta
  export __C_="\033[0;36m"    # cyan
  export __W_="\033[0;37m"    # white
  # empahsized (bolded) colors
  export __EMK_="\033[1;30m"
  export __EMR_="\033[1;31m"
  export __EMG_="\033[1;32m"
  export __EMY_="\033[1;33m"
  export __EMB_="\033[1;34m"
  export __EMM_="\033[1;35m"
  export __EMC_="\033[1;36m"
  export __EMW_="\033[1;37m"
  # background colors
  export __BGK_="\033[40m"
  export __BGR_="\033[41m"
  export __BGG_="\033[42m"
  export __BGY_="\033[43m"
  export __BGB_="\033[44m"
  export __BGM_="\033[45m"
  export __BGC_="\033[46m"
  export __BGW_="\033[47m"
  # styles
  export __NN_="\033[0m"  # unsets color to term's fg color
  export __EM_="\033[1m"  #bold
  export __DM_="\033[2m"  #dim
  export __UN_="\033[4m"  #underline
  export __BL_="\033[5m"  #blink
  export __RV_="\033[7m"  #reverse
  export __EMQ_="\033[21m" #END bold
  export __DMQ_="\033[22m" #END dim
  export __UNQ_="\033[24m" #END underline
  export __BLQ_="\033[25m" #END blink
  export __RVQ_="\033[27m" #END reverse
  # default user colors
  export __UC_=$__G_                         # user's color
  export __EMUC_=$__EMG_                     # user's bold color
  export __ERRUC_=$__R_                      # user's ERROR color
  export __ERREMUC_=$__EMR_                  # user's bold ERROR color
  # root colors
  [ $UID -eq "0" ] && __UC_=$__R_           # root's color
  [ $UID -eq "0" ] && __EMUC_=$__EMR_       # root's bold color
  [ $UID -eq "0" ] && __ERRUC_=$__K_        # root's ERROR color
  [ $UID -eq "0" ] && __ERREMUC_=$__EMK_    # root's bold ERROR color
}


__tartify_init_globs(){
# TARTIFY PARAMETERS : adapt to your needs


# // OVERWRITE
#TODO: TARTIFY_IGNORE_GITPS1_VARS

export TARTIFY_OW=""                             # a string containing tartify command-line params. If non empty, will
                                                 # overwrite any arguments the tartify command receives

# // TIME
export TARTIFY_TIME_BUGME=TRUE                   # non empty : will color and style the 'time since last commit' string
export TARTIFY_TIME_DISPLAY=LONG                 # LONG (min, hours, days) SHORT (mine | hours | days) CHAR (cf. next var)
export TARTIFY_STRING_TIME_DISPLAY="⟳ "               # string to display in case prec. var == CHAR

                                                 # Uncommited changes (staged, unstaged)
export TARTIFY_TIME_COULDCOMMIT=3600             #     *     nb seconds after which you COULD  commit
export TARTIFY_TIME_SHOULDCOMMIT=86400           #     * Max nb seconds after which you SHOULD commit
                                                 # (default is 86400, 24hours)


                                                 # colors applied to the 'time elapsed since last commit'
                                                 # string, in case of uncommited changes
export TARTIFY_STYLE_TIME_COULDCOMMIT=${__UN_}   #                                  UNDERLINED
export TARTIFY_STYLE_TIME_SHOULDCOMMIT=${__EM_}${__UN_} #                           BOLD UNDERLINED

                                                 # styles applied to the 'time elapsed since last commit'
                                                 # string in case of no uncommited changes
export TARTIFY_COLOR_TIME_ACTIVITY_HIGH=${__G_}  #                                  GREEN
export TARTIFY_COLOR_TIME_ACTIVITY_LOW=${__Y_}   #                                  YELLOW
export TARTIFY_COLOR_TIME_ACTIVITY_NON=${__R_}   #                                  RED

# //BRANCH
#DEPREC:
#export TARTIFY_STRING_NOBRANCH="nobranch"        # "branch name" replacement string for empty repository
export TARTIFY_STRING_DOTGIT="GIT_DIR!"          # "branch name" replacement string for .git directory
export TARTIFY_STRING_BARE="<BARE>"              # "branch name" replacement string for bare .git directory

export TARTIFY_STYLE_UNTRACKED=${__UN_}          # Untracked Files                  UNDERLINED

export TARTIFY_COLOR_UNSTAGED=${__EMR_}          # unstaged changes (first 2 chars) BOLD RED
export TARTIFY_COLOR_STAGED=${__M_}              # staged changes                   MAGENTA
export TARTIFY_COLOR_AHEADOFREMOTE=${__Y_}       # tracked remote behind HEAD       YELLOW
export TARTIFY_COLOR_UPTODATE=${__G_}            # tracked remote == HEAD           GREEN
export TARTIFY_COLOR_NOREMTRACK=${__B_}          # no remote tracking branch        BLUE
export TARTIFY_COLOR_NOCOMMITYET=${__EMK_}       # empty repo, no commit yet        BOLD DIM GREY

export TARTIFY_COLOR_GITDIR=${__C_}              # inside .git dir                  CYAN
export TARTIFY_COLOR_EMPTY=${__C_}               # empty repo (no commit yet)       CYAN
export TARTIFY_COLOR_MERGE_REBASE_CHERRY_BISECT=${__EMR_}  # color for the merge/rebase/cherry-pick/bisect status of current branch (if any)
                                                 #                                  BOLD RED

#TODO: unmerged : deprecated
export TARTIFY_STRING_UNMERGED="✖ "              # there are unmerged files
export TARTIFY_COLOR_UNMERGED=${__BL_}${__EMR_}  # unmerged files                   BOLD RED BLINKING
                                                 #                                  (yeah, obnoxious)
# // REPOSITORY
export TARTIFY_COLOR_REPONAME=${__DM_}${__K_}    # repository's "name"              DIM GREY

# // REMOTES
export TARTIFY_STRING_ORIGIN="O"                 # marker for remote repo called 'origin'
export TARTIFY_STRING_UPSTREAM="U"               # marker for remote repo called 'upstream'
export TARTIFY_STRING_REMOTE="⇧ "                # generic marker for remote repo
export TARTIFY_STRING_DIVERGE_SEP="/"            # separator for ahead/behind count

export TARTIFY_STRING_TRACKING="➝ "              # marker for tracked branch
export TARTIFY_COLOR_REMOTE_ORIGIN=${__G_}       # repository's "name"              GREEN
export TARTIFY_COLOR_REMOTE_UPSTREAM=${__M_}     # repository's "name"              MAGENTA
export TARTIFY_COLOR_REMOTE_OTHER=${__Y_}        # repository's "name"              YELLOW


export TARTIFY_COLOR_REMOTE_AHEAD=${__G_}        # nb commits ahead of remote       GREEN
export TARTIFY_COLOR_REMOTE_BEHIND=${__R_}       # nb commits behind of remote      RED


# // STASH
export TARTIFY_COUNTSTASHES=TRUE                 # non empty: print 1 $TARTIFY_STRING_STASH per existing stash
                                                 # (WARN: this is slow process, add ~50ms computing time)
export TARTIFY_STRING_STASH="☆ "                 # marker for stash
export TARTIFY_STRING_STASH="•"                 # marker for stash
export TARTIFY_COLOR_STASH_NOCOUNT=${__Y_}       # color when not counting          YELLOW
export TARTIFY_COLOR_STASH_COUNT=${__EMY_}       # color in "count mode"            BOLD YELLOW

# // UNPARSED CHARS
export TARTIFY_COLOR_DELIMITER=${__DM_}${__K_}   # color for (unparsed) delimiters  DIM GREY


# TODO: (restrict that to OLDSCHOOL)
# The usual environment variables from git-completion.bash still apply
# in "OLDSCHOOL" mode
#
#     GIT_PS1_SHOWDIRTYSTATE
#     GIT_PS1_SHOWSTASHSTATE
#     GIT_PS1_SHOWUNTRACKEDFILES
#     GIT_PS1_SHOWUPSTREAM
}


#------------------------------------------------------------------------------
#
#             HELPER FUNCTIONS
#
#------------------------------------------------------------------------------
#
__tartify_diff_count() {
#count the nb of commits between two branches of two repositorie
#   ex: __tartify_diff_count HEAD origin/master
#   ex: __tartify_diff_count upstream/dev HEAD
    echo "$(git rev-list $1..$2 2>/dev/null | awk 'END {print NR}')"
}

__tartify__branchname_and_state(){
  # assume _gitdir is a correct path to a ".git" directory
  local _gitdir=$1

  #----------------------------------------------------------------------------
  #
  # BEGIN
  #
  # chunk of original __git_ps1 (from bash_completion) tuned for tartify
  #----------------------------------------------------------------------------
  if [ -n "$_gitdir" ]; then
    local r=""
    local b=""
    if [ -f "$_gitdir/rebase-merge/interactive" ]; then
      r="|REBASE-i"
      b="$(cat "$_gitdir/rebase-merge/head-name")"
    elif [ -d "$_gitdir/rebase-merge" ]; then
      r="|REBASE-m"
      b="$(cat "$_gitdir/rebase-merge/head-name")"
    else
      if [ -d "$_gitdir/rebase-apply" ]; then
        if [ -f "$_gitdir/rebase-apply/rebasing" ]; then
          r="|REBASE"
        elif [ -f "$_gitdir/rebase-apply/applying" ]; then
          r="|AM"
        else
          r="|AM/REBASE"
        fi
      elif [ -f "$_gitdir/MERGE_HEAD" ]; then
        r="|MERGING"
      elif [ -f "$_gitdir/CHERRY_PICK_HEAD" ]; then
        r="|CHERRY-PICKING"
      elif [ -f "$_gitdir/BISECT_LOG" ]; then
        r="|BISECTING"
      fi

      b="$(git symbolic-ref HEAD 2>/dev/null)" || {

        b="$(
        case "${GIT_PS1_DESCRIBE_STYLE-}" in
        (contains)
          git describe --contains HEAD ;;
        (branch)
          git describe --contains --all HEAD ;;
        (describe)
          git describe HEAD ;;
        (* | default)
          git describe --tags --exact-match HEAD ;;
        esac 2>/dev/null)" ||

        b="$(cut -c1-7 "$_gitdir/HEAD" 2>/dev/null)..." ||
        b="unknown"
        b="($b)"
      }
    fi
  #----------------------------------------------------------------------------
  #
  # END
  #
  # chunk of original __git_ps1 (from bash_completion) tuned for tartify
  #----------------------------------------------------------------------------
  fi

  printf "%s" $a'.'$b
  # dirty way of returning 2 arguments
  #
  # '.' is a forbidden char for a branch name, we use it as a separator.
  # Then, for further extraction :
  #
  #   result=$(__tartify__branchname_and_state $gitdir)
  #   [ -n $result ] && {
  #     $a=${result/%.!(.)/}
  #     $b=${result/#!(.)./}
  #     [ $b = $a ] && b=
  #   }

}

#DEPREC
__tartify_find_tracked(){
  local __branchname=$1
  # find (possible) tracked remote for current branch in repository
  for remotename in $(git remote show); do
    # CURRENT BRANCH is tracked to CURRENT REMOTE ?
    if [[ $(git config --get branch.$__branchname.remote) =~ $remotename ]]; then
        echo $remotename
    fi
  done
}


__tartify_usage(){
# Display the help message
  echo -e "
  ${__UN_}Description${__UNQ_} : One-Liner condensed GIT infos (for your prompt, screen
                statusline, ...)

  ${__UN_}Usage${__UNQ_} is : ${__EM_}tartify${__EMQ_} [${__Y_}options${__NN_}]

  ${__UN_}Options${__UNQ_} is : a CASE-SENSITIVE sequence of characters.

      * The following characters are reserved tartify commands :
         ${__Y_}bBcehlLnNopqrRsSuvwW${__NN_}
      * any other character will be printed "as is", including spaces. You can use
      those to format the output of the tarttify command (as delimiters,...)
              \`tartify [r]b - l\` will output \"[repository]master - 12m\"

      * if you need multiple spaces, escape them \"\ \" :
              \`tartify [r]b -\ \ l\` will output \"[repository]master -  12m\"

      * following characters need to be escaped  ${__Y_}()<>;*\"\'\`#&|~)${__NN_}


      ${__Y_}[Elements]${__NN_} ${__EM_}${__NN_}

      ${__Y_}n${__NN_}       repository ${__EMY_}n${__NN_}ame     ${__Y_}N${__NN_}   same without colors
      ${__Y_}b${__NN_}       ${__EMY_}b${__NN_}ranch name         ${__Y_}B${__NN_}          \` \`
      ${__Y_}r${__NN_}       ${__EMY_}r${__NN_}emotes info        ${__Y_}R${__NN_}          \` \`
      ${__Y_}s${__NN_}       ${__EMY_}s${__NN_}tash info          ${__Y_}S${__NN_}          \` \`
      ${__Y_}l${__NN_}       ${__EMY_}l${__NN_}ast commit info    ${__Y_}L${__NN_}          \` \`

      ${__Y_}w${__NN_}       ne${__EMY_}w${__NN_}line append newline
      ${__Y_}W${__NN_}       ne${__EMY_}W${__NN_}line prepend newline

      ${__Y_}[Modes]${__NN_} ${__EM_}mutually exclusive (only first one counts)${__NN_}

      ${__Y_}u${__NN_}       s${__EMY_}u${__NN_}ccint    short version
      ${__Y_}q${__NN_}       ${__EMY_}q${__NN_}uiet      only update variables, no output
      ${__Y_}c${__NN_}       no${__EMY_}c${__NN_}olor    strip all colors
      ${__Y_}o${__NN_}       ${__EMY_}o${__NN_}ldschool  __git_ps1 mode
      ${__Y_}p${__NN_}       ${__EMY_}p${__NN_}s1 mode   string with escaped (\[...\])ansi escape codes
      ${__Y_}v${__NN_}       ${__EMY_}v${__NN_}im mode   result formated for the Vim tartify plugin
                         (color info appended to result)


      ${__Y_}[Help]${__NN_} ${__EM_}all other arguments are ignored${__NN_}

      ${__Y_}h${__NN_}     ${__EMY_}h${__NN_}elp      display this help message
      ${__Y_}e${__NN_}     ${__EMY_}e${__NN_}nv help  list customizable environment variables

  ${__UN_}Default${__UNQ_}   tartify   : is equivalent to ${__EM_}tartify${__EMQ_} ${__Y_}nbrsl${__NN_}
            tartify w : is equivalent to ${__EM_}tartify${__EMQ_} ${__Y_}nbrslw${__NN_}
            tartify o : is equivalent to ${__EM_}tartify${__EMQ_} ${__Y_}obsr${__NN_}


"
}


__tartify_reformat_timestamp(){
# prints a relative-formatted time string from unix timestamp
# arg: unix timestamp in seconds
# optional arg: true to include coloring
# copied from https://github.com/xtrementl/dev-bash-git-ps1.git
    local secs="$1"
    local yrs="$(( $secs / 31557600 ))"
    local div="$(( $secs % 31557600 ))"
    local days="$(( div / 86400 ))"
    div="$(( $secs % 86400 ))"
    local hrs="$(( $div / 3600 ))"
    div="$(( $secs % 3600 ))"
    local mins="$(( $div / 60 ))"

    # create the formatted time string
    local timestr
    [ 0 -lt "$yrs" ] && timestr="${yrs}y"
    if [ 0 -lt "$days" ]; then
        [ -n "$timestr" ] && timestr="$timestr,"
        timestr="${days}d"
    fi
    if [ 0 -lt "$hrs" ]; then
        [ -n "$timestr" ] && timestr="$timestr,"
        timestr="${timestr}${hrs}h"
    fi
    [ -n "$timestr" ] && timestr="${timestr},"
    timestr="${timestr}${mins}m"

    # TODO:
    # TARTIFY_STYLE_TIME_COULDCOMMIT
    # TARTIFY_STYLE_TIME_SHOULDCOMMIT
    # TARTIFY_TIME_DISPLAY
    # TARTIFY_STRING_TIME_DISPLAY

    # add a hint of color
    if [ "$2" = "false" ] && [ -n "$TARTIFY_TIME_BUGME" ]; then
    #if [ -n "$2" ] && [ -n "$TARTIFY_TIME_BUGME" ]; then
        local color
        if [ $TARTIFY_TIME_SHOULDCOMMIT -lt "$secs" ]; then # 30 mins
            color=$TARTIFY_COLOR_TIME_ACTIVITY_NON
        elif [ $TARTIFY_TIME_COULDCOMMIT -lt "$secs" ]; then # 10 mins
            color=$TARTIFY_COLOR_TIME_ACTIVITY_LOW
        else
            color=$TARTIFY_COLOR_TIME_ACTIVITY_HIGH
        fi
        timestr="${color}${timestr}${__NN_}"
    fi
    echo "$timestr"
}


#------------------------------------------------------------------------------
#
#             TARTIFY commands
#
# All the following functions are intended for use from the tartify command and
# assume we are inside a GIT repository.
#
#------------------------------------------------------------------------------
__tartify_repo_name()
{
  local _gitdir=$1
  local updir=""; [ $2 == "false" ] && updir="/.." #don't go 1 level up for bare repo
  local _nocolors=$3   #TRUE for no color
  local color

  # Print the REPO's name
  color=$TARTIFY_COLOR_REPONAME
  nocolor=$(echo `cd $_gitdir$updir; pwd` | sed 's,.*/,,' | tr -d '\n')
  color=$color$nocolor
  color=$color"${__NN_}"

  [ "true" = $_nocolors ] &&  echo -ne $nocolor || echo -ne $color
}


__tartify_branch() {

  # ARGUMENTS : $nocolor : FALSE|TRUE                (optionnal)
  #             $_mode    : OLDSCHOOL|VIM|QUIET|PS1   (optionnal)
  #
  # OLDSCHOOL _mode : output the same exact string __git_ps1 would
  #                  (except upstream, which is handled by __tartify_remote)
  #
  # VIM _mode
  #
  #   Return value:
  #
  #       $nci\|$branchname\|$merge_status
  #
  #     nci =~ /[U]?[SAONGBE][T]?/    (nci : no colors info)
  #
  #        [U]nstaged modif(s)
  #
  #        [S]taged modif(s),
  #        [A]head of remote     & nothing staged
  #        [O]K (remote == HEAD) & nothing staged
  #        [N]o tracked remote   & nothing staged
  #        inside .[G]it directory (branch info irrelevant)
  #        inside  [B]are repository (branch info irrelevant)
  #        [E]mpty repository (no branch)
  #
  #        un[T]racked files,
  #
  #     merge_infos : either one of these values, or "" :
  #
  #        REBASE-i, REBASE-m, REBASE, AM, AM/REBASE, MERGING, CHERRY-PICKING,
  #        BISECTING
  #
  # QUIET _mode
  #
  # PS1 _mode
  #
  #   will use on-the-fly variable-NAMES creation
  #
  #     TOTO=2
  #     TATA=TO
  #     TITI=$(eval "printf "%s" "\$${TATA}TO"")

  local _gitdir=$1
  local _isbare=$2             #TRUE for BARE repository
  local _hasstash=$3
  local _isinsideworktree=$4   #TRUE if inside working dir
  local _mode=$5               #either VIM | OLDSCHOOL | QUIET | PS1
  local _nocolors=$6           #TRUE for no color
  local color
  local color_base      # branch name base color
  local color_unstaged  # first 2 chars of branch name in case of unstaged modifs
  local style_untracked # special style in case of untracked files
  local nocolor
  local nci           # (VIM mode) store color infos
  local saongbe       # (VIM mode) branch status - store either one of these letters (SAONGBE)



  #DEPENDS : __gitdir
  #   local g=""    GITFIR
  #   local r=""    REBASE/MERGE/... info
  #   local b=""    BRANCH
  #   local w=""    UNSTAGED indicator "*"
  #   local i=""    STAGED indicator "+"  or NO COMMIT YET in HEAD "#"
  #   local s=""    STASH state $
  #   local u=""    UNTRACKED files %
  #   local f=""    "$w$i$s$u"  UNSTAGED STAGED STASH UNTRACKED
  #   local c=""    BARE: prefix to $b (BRANCH)
  #
  #   local p=""    ??empty string (at the end of printf)

  # __git_ps1 accepts 0 or 1 arguments (i.e., format string)
  # returns text to add to bash PS1 prompt (includes branch name)

  #----------------------------------------------------------------------------
  #
  # <<BEGIN
  #
  # chunk of original __git_ps1 (from bash_completion) tuned for tartify
  #----------------------------------------------------------------------------
  if [ -n "$_gitdir" ]; then
    local r=""
    local b=""
    if [ -f "$_gitdir/rebase-merge/interactive" ]; then
      r="|REBASE-i"
      b="$(cat "$_gitdir/rebase-merge/head-name")"
    elif [ -d "$_gitdir/rebase-merge" ]; then
      r="|REBASE-m"
      b="$(cat "$_gitdir/rebase-merge/head-name")"
    else
      if [ -d "$_gitdir/rebase-apply" ]; then
        if [ -f "$_gitdir/rebase-apply/rebasing" ]; then
          r="|REBASE"
        elif [ -f "$_gitdir/rebase-apply/applying" ]; then
          r="|AM"
        else
          r="|AM/REBASE"
        fi
      elif [ -f "$_gitdir/MERGE_HEAD" ]; then
        r="|MERGING"
      elif [ -f "$_gitdir/CHERRY_PICK_HEAD" ]; then
        r="|CHERRY-PICKING"
      elif [ -f "$_gitdir/BISECT_LOG" ]; then
        r="|BISECTING"
      fi

      b="$(git symbolic-ref HEAD 2>/dev/null)" || {

        b="$(
        case "${GIT_PS1_DESCRIBE_STYLE-}" in
        (contains)
          git describe --contains HEAD ;;
        (branch)
          git describe --contains --all HEAD ;;
        (describe)
          git describe HEAD ;;
        (* | default)
          git describe --tags --exact-match HEAD ;;
        esac 2>/dev/null)" ||

        b="$(cut -c1-7 "$_gitdir/HEAD" 2>/dev/null)..." ||
        b="unknown"
        b="($b)"
      }
    fi

    local w=""
    local i=""
    local s=""
    local u=""
    local c=""
    local p=""

    if [ "true" = "$(git rev-parse --is-inside-git-dir 2>/dev/null)" ]; then
      if [ "true" = "$_isbare" ]; then
        c="BARE:"
        saongbe="B"
      else
        b=$TARTIFY_STRING_DOTGIT
        saongbe="G"
      fi
    elif [ "true" = "$_isinsideworktree" ]; then
      if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ]; then
        if [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
          git diff --no-ext-diff --quiet --exit-code || w="*"
          if git rev-parse --quiet --verify HEAD >/dev/null; then
            git diff-index --cached --quiet HEAD -- || i="+"
            saongbe="S"
          else
            i="#"
            saongbe="E"
          fi
        fi
      fi
      if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ]; then
        [ "true" = "$_hasstash" ] && s="$"
      fi

      if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ]; then
         if [ -n "$(git ls-files --others --exclude-standard)" ]; then
            u="%"
         fi
      fi

    fi
  #----------------------------------------------------------------------------
  #
  # <<END
  #
  # chunk of original __git_ps1 (from bash_completion) tuned for tartify
  #----------------------------------------------------------------------------



    # ___________________
    #
    # Now for some OUTPUT
    # ___________________

    [ "$_mode" = "OLDSCHOOL" ] && {
      local f="$w$i$s$u"
      printf "%s" "$c${b##refs/heads/}${f:+ $f}$r$p"

      #printf "%s" "$c   ${b##refs/heads/}${f:+ $f}$r$p"
      #             $c   $b               $w       $i     $s    $u        $r           $p
      #             BARE:master           unstaged staged stash untracked rebase/merge empty
      #
      #             [ branch name ]       [red]    [**]   [OLDSC] [underl] [??]
    }


    [ "$_mode" = "VIM" ] && {
      [ -n "$w" ]     && nci=$nci"U"  #unstaged

      #SAONGBE : SGBE already taken care of
      #          Determine AON (tracking branch info)
      [ -n "$w" ] && saongbe="A"
      [ -n "$w" ] && saongbe="O"
      [ -n "$w" ] && saongbe="N"

      [ -n "$u" ] && nci=$nci"T"  #untracked
      printf "%s" $nci"|"${b##refs/heads/}$r #$r already includes the "|" separator
    }

    [ "$_mode" == "QUIET" ] && {
      :;
    }

    [ "$_mode" == "PS1" ] && {
      :;
    }

    [ "$_mode" == "NONE" ] && {
      printf "%s" "$c${b##refs/heads/}$r$p"
    }


  fi


}


__tartify_remote()
{
  # OLDSCHOOL :
  #
  #    #:no upstream

  local _gitdir=$1
  local _nocolors=$2   #TRUE for no color
  local color
  local nocolor

  local branchname=$(git branch 2>/dev/null| sed -n '/^\*/s/^\* //p')
  color="  "$__NN_

  # NON-EMPTY GIT REPO
  # VERIFY that .git/refs/heads/ directory is not empty
  if [ $(ls $_gitdir/refs/heads/ | wc -l) -gt 0 ]
  then

    # ------- REMOTES INFO ( + BRANCH TRACKED ) --------
    local marker
    local marker_color
    local before_traked
    local after_tracked
    local before_untraked
    local after_untracked

    # loop through remotes
    for remotename in $(git remote show); do

      # special markers for origin and upstream
      # nb: a tracked remote is preceded by a little ➝ symbol
      case $remotename in
          origin)   marker="O"; marker_color=$TARTIFY_COLOR_REMOTE_ORIGIN   ;;
        upstream)   marker="U"; marker_color=$TARTIFY_COLOR_REMOTE_UPSTREAM ;;
                *)   marker="⇧"; marker_color=$TARTIFY_COLOR_REMOTE_OTHER    ;;
      esac

      # CURRENT BRANCH is tracked to CURRENT REMOTE ?
      if [[ $(git config --get branch.$branchname.remote) =~ $remotename ]]
      then
        [ "true" = $_nocolors ]  &&  {
                              before_traked=" ➝ "; after_tracked="";
                              before_untraked=" "; after_untracked=""; 
                            } || {
                              before_traked=" ➝${__EM_} "; after_tracked="${_EMQ_}";
                              before_untraked=" "; after_untracked="";
                            }
      else
        before_traked=""; after_tracked="";before_traked=" "; after_tracked="";
      fi


      # nb of commits AHEAD/BEHIND
      local ahead_count="$(__tartify_diff_count $remotename/$branchname HEAD)"
      local behind_count="$(__tartify_diff_count HEAD $remotename/$branchname)"
      local diffcount=""
      local diffcountnocol=""
      if [ 0 -lt "$ahead_count" ]; then
          diffcount="${TARTIFY_COLOR_REMOTE_AHEAD}${ahead_count}"
          diffcountnocol="+${ahead_count}"
      fi

      if [ 0 -lt "$behind_count" ]; then
          [ -n "$diffcount" ] && {
                  diffcount=${diffcount}${marker_color}$TARTIFY_STRING_DIVERGE_SEP
                  diffcountnocol=${diffcountnocol}$TARTIFY_STRING_DIVERGE_SEP
                }
          diffcount="${diffcount}${TARTIFY_COLOR_REMOTE_BEHIND}${behind_count}"
          diffcountnocol="${diffcountnocol}-${behind_count}"
      fi

      [ -n "$diffcount" ] && diffcount=" ${marker_color}($diffcount${marker_color}) "
      [ -n "$diffcountnocol" ] && diffcountnocol=" ($diffcountnocol) "
      #echo "$diffcount"


      color=$color"${marker_color}${before_traked}${marker}${after_tracked}${diffcount}${__NN_}"
      nocolor=$nocolor"${before_traked}${marker}${after_tracked}${diffcountnocol}"

    done
  fi

  [ "true" = $_nocolors ] &&  echo -ne $nocolor || echo -e $color

  #TODO: oldschool 
      #if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
      #  __git_ps1_show_upstream
      #fi

}


#optimized
__tartify_stash()
{
  local _hasstash=$1
  local _isinsideworktree=$2   #TRUE if inside working dir
  local _mode=$3
  local _nocolors=$4           #TRUE for no color
  local color
  local nocolor
  #? are we inside a GIT repo's working tree
  #TODO: redundant test
  if [ "true" = "$_isinsideworktree" ]; then
    if [ "true" = "$_hasstash" ]; then
      if [ -n "$TARTIFY_COUNTSTASHES" ]; then
        # One star per stash
        color=$TARTIFY_COLOR_STASH_COUNT
        nocolor="  "
        #! `git stash list | wc -l` adds about 50ms
        for (( i=0; i< $(git stash list | wc -l); i++ ))
        do
          nocolor=$nocolor$TARTIFY_STRING_STASH
        done
        nocolor=$nocolor" "
      else
        color=$TARTIFY_COLOR_STASH_NOCOUNT
        nocolor=$TARTIFY_STRING_STASH
      fi
      color=$color$nocolor${__NN_}

      [[ "$_mode" =~ OLDSCHOOL ]] && nocolor="$"
    fi

    [ "true" = $_nocolors ] &&  echo -ne $nocolor || echo -e $color
  fi
}


__tartify_timelastcommit(){
  #TODO: COLORS !!!!!!!
  local _nocolors=$1           #TRUE for no color
  local color
  local nocolor

  #? are we inside a GIT repo
  if git rev-parse --git-dir >/dev/null 2>&1; then
    # calc relative time diff of last commit
    local secs="$(
      # get the unix timestamp for the lastest commit (seconds)
      # copied from https://github.com/xtrementl/dev-bash-git-ps1.git
          local now="$(date +%s)"
          local last_commit="$(git log --format='%at' -1 2>/dev/null)"
          if [ -z "$last_commit" ]; then # probably initial git init, no commits
              return
          fi
          if [ 0 -lt "$now" ] && [ 0 -lt "$last_commit" ]; then
              echo "$((now - last_commit))"
          fi
    )"
    #TODO: include $_nocolors
    [ -n "$secs" ] && echo -e "$(__tartify_reformat_timestamp $secs $_nocolors)"
  fi
}

#------------------------------------------------------------------------------
#
#             TARTIFY
#
#------------------------------------------------------------------------------

tartify()
{
  local argstr="$*"

  # -- PARSE help options and exit --
  # do that first to enable testing if 'tartify' is present with exit value of zero
  # Help
  [[ "$argstr" =~ h ]] && { __tartify_usage; return 0; }
  [[ "$argstr" =~ e ]] && {
    echo -ne "\nTartify's ENVIRONMENT variables are currently set to :"
    __TART_env=`env | grep "^TARTIFY_" |   sed 's/\(\\033\[\([0-9];\)*[0-9]*m\)\{1,2\}/&##########\\\\033\[0m/g' | sed 's/$/\\\\n/g' | sort -df `
    echo -ne "\n\n "$__TART_env | awk -F"=" '{printf("%-'35s' %'0s'\n", $1,$2)}'
    return 0
  }

  [ -n "$TARTIFY_OW" ] && argstr=$TARTIFY_OW


  # -- INIT local vars --
  # any one of these HAS to be non-empty (passed as positional parameters
  # to other functions)
  local gitdir="false"
  local isbare="false"
  local isinsideworktree="false"
  local hasstash="false"
  local nocolors="false"
  local mode="NONE"

  # -- BAIL if not INSIDE a GIT REPO --
  gitdir=`git rev-parse --git-dir 2>/dev/null`
  [ $? == 0  ] && {

    #Perform all cheap 'git' tests (used in more than one '__tartify_*' function)
    isbare=$( git rev-parse --is-bare-repository 2>/dev/null )
    isinsideworktree=$(git rev-parse --is-inside-work-tree 2>/dev/null)
    if [ "true" = "$isinsideworktree" ]; then
    #if [[ "$isinsideworktree" =~ true ]]; then
      git rev-parse --verify refs/stash >/dev/null 2>&1 && hasstash="true"
    fi

    
    #TODO:
    count="$(git rev-list --count --left-right "$upstream"...HEAD 2>/dev/null)"



    # (optionnal) argument expansion
    #TODO: these tests suck
    [[ "$argstr" == "w" ]] && argstr="nbrslw"                        #newline after
    [[ "$argstr" == "W" ]] && argstr="nbrslW"                        #newline before
    [[ "$argstr" == "Ww" || "$argstr" == "wW" ]] && argstr="nbrslwW" #newline BOTH
    [[ "$argstr" == "o" ]] && argstr="obsr"                          #oldschool
    [[ "$argstr" == "v" ]] && argstr="vnbrsl"                        #vim
    [ ${#argstr} == 0 ] && argstr="nbrsl"                            #no args

    local separator

    # -- MODES --
    # No Colors MODE : strip all color info, whatever the result
    [[ "$argstr" =~ c ]] && {
        nocolors="true"
    }
    # Vim MODE : no color, prepend color infos for 'branch', use '#' as separator
    [[ "$argstr" =~ v ]] && {
        # don't fucking change that
        separator="vimsplitsep"
        nocolors="true"
        mode="VIM"
    }
    # OldSchool MODE : no color, branch results with $*+, stash results with %
    [[ "$argstr" =~ o ]] && {
        #separator=" "
        nocolors="true"
        mode="OLDSCHOOL"
    }
    # Quiet mode (only update the __TART4PS1* variables)
    [[ "$argstr" =~ q ]] && {
        mode="QUIET"
    }
    # PS1 mode (ansi color codes escaped with '\[' and '\]' for PS1
    [[ "$argstr" =~ p ]] && {
        mode="PS1"
    }

    # -- PARSE remaining args --
    local tartAnswer=""
    local i
    for ((i=0;i<${#argstr};i++))
    do
      local ch=${argstr:$i:1}
      case $ch in
        n) tartAnswer=$tartAnswer$separator$( __tartify_repo_name $gitdir $isbare                                   $nocolors);;
        b) tartAnswer=$tartAnswer$separator$( __tartify_branch    $gitdir $isbare $hasstash $isinsideworktree $mode $nocolors);;
        r) tartAnswer=$tartAnswer$separator$( __tartify_remote    $gitdir                                           $nocolors);;
        s) tartAnswer=$tartAnswer$separator$( __tartify_stash                     $hasstash $isinsideworktree $mode $nocolors);;
        l) tartAnswer=$tartAnswer$separator$( __tartify_timelastcommit                                              $nocolors);;
        c) ;;
        o) ;;
        p) ;;
        q) ;;
        v) ;;
        w) ;;
        W) ;;
        #*) echo "Unknown option \"$ch\""; __tartify_usage; return 1 ;;
        #TODO: make that work with PS1 and NOCOLORS
        *) tartAnswer=$tartAnswer$TARTIFY_COLOR_DELIMITER$ch$__NN_;;
      esac
    done

    # Post Process
    # VIM mode : remove first occurence of $separator
    [ "$mode" = "VIM" ] && tartAnswer=${tartAnswer/#vimsplitsep/}

    # -- OUTPUT --
    # TODO: this test sucks (time lost in subshell)
    # remove ansi escapes
    local testforblank=$(echo  $tartAnswer | sed -E "s/\\\\033\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g")
    testforblank=${testforblank/ //}

    # only do something if answer is not empty
    [ ${#testforblank} != 0 ] && {
      [[ "$argstr" =~ W ]] && echo -ne "\n" # linebreak before
      echo -ne $tartAnswer
      [[ "$argstr" =~ w ]] && echo -ne "\n" # linebreak after
    }
  }
  return 0
}


#------------------------------------------------------------------------------
#
#             MAIN
#
#------------------------------------------------------------------------------
__tartify_define_colors
__tartify_init_globs

#DEPREC:
#export __tartify_shell_loaded=1

# in case the script in being executed and not sourced, run the main command
  [ "$__tartify_whocalled" = "exec" ] && {
    tartify $__tartify_args
  }


# REMOVE ANSI ESCAPE from string
# MACOS
# echo  $TOTO | sed -E "s/\\\\033\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
# LINUX
#               sed -r

